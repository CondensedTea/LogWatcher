package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/requests.LogUploader -o ./pkg/mocks/log_processor_mock.go

import (
	mm_requests "LogWatcher/pkg/requests"
	"LogWatcher/pkg/stats"
	"bytes"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LogUploaderMock implements requests.LogUploader
type LogUploaderMock struct {
	t minimock.Tester

	funcGetPickupGames          func(domain string) (g1 mm_requests.GamesResponse, err error)
	inspectFuncGetPickupGames   func(domain string)
	afterGetPickupGamesCounter  uint64
	beforeGetPickupGamesCounter uint64
	GetPickupGamesMock          mLogUploaderMockGetPickupGames

	funcMakeMultipartMap          func(_map string, domain string, pickupID int, buf bytes.Buffer) (m1 map[string]io.Reader)
	inspectFuncMakeMultipartMap   func(_map string, domain string, pickupID int, buf bytes.Buffer)
	afterMakeMultipartMapCounter  uint64
	beforeMakeMultipartMapCounter uint64
	MakeMultipartMapMock          mLogUploaderMockMakeMultipartMap

	funcResolvePlayers          func(domain string, players []*stats.PickupPlayer) (err error)
	inspectFuncResolvePlayers   func(domain string, players []*stats.PickupPlayer)
	afterResolvePlayersCounter  uint64
	beforeResolvePlayersCounter uint64
	ResolvePlayersMock          mLogUploaderMockResolvePlayers

	funcUploadLogFile          func(payload map[string]io.Reader) (err error)
	inspectFuncUploadLogFile   func(payload map[string]io.Reader)
	afterUploadLogFileCounter  uint64
	beforeUploadLogFileCounter uint64
	UploadLogFileMock          mLogUploaderMockUploadLogFile
}

// NewLogUploaderMock returns a mock for requests.LogUploader
func NewLogUploaderMock(t minimock.Tester) *LogUploaderMock {
	m := &LogUploaderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetPickupGamesMock = mLogUploaderMockGetPickupGames{mock: m}
	m.GetPickupGamesMock.callArgs = []*LogUploaderMockGetPickupGamesParams{}

	m.MakeMultipartMapMock = mLogUploaderMockMakeMultipartMap{mock: m}
	m.MakeMultipartMapMock.callArgs = []*LogUploaderMockMakeMultipartMapParams{}

	m.ResolvePlayersMock = mLogUploaderMockResolvePlayers{mock: m}
	m.ResolvePlayersMock.callArgs = []*LogUploaderMockResolvePlayersParams{}

	m.UploadLogFileMock = mLogUploaderMockUploadLogFile{mock: m}
	m.UploadLogFileMock.callArgs = []*LogUploaderMockUploadLogFileParams{}

	return m
}

type mLogUploaderMockGetPickupGames struct {
	mock               *LogUploaderMock
	defaultExpectation *LogUploaderMockGetPickupGamesExpectation
	expectations       []*LogUploaderMockGetPickupGamesExpectation

	callArgs []*LogUploaderMockGetPickupGamesParams
	mutex    sync.RWMutex
}

// LogUploaderMockGetPickupGamesExpectation specifies expectation struct of the LogUploader.GetPickupGames
type LogUploaderMockGetPickupGamesExpectation struct {
	mock    *LogUploaderMock
	params  *LogUploaderMockGetPickupGamesParams
	results *LogUploaderMockGetPickupGamesResults
	Counter uint64
}

// LogUploaderMockGetPickupGamesParams contains parameters of the LogUploader.GetPickupGames
type LogUploaderMockGetPickupGamesParams struct {
	domain string
}

// LogUploaderMockGetPickupGamesResults contains results of the LogUploader.GetPickupGames
type LogUploaderMockGetPickupGamesResults struct {
	g1  mm_requests.GamesResponse
	err error
}

// Expect sets up expected params for LogUploader.GetPickupGames
func (mmGetPickupGames *mLogUploaderMockGetPickupGames) Expect(domain string) *mLogUploaderMockGetPickupGames {
	if mmGetPickupGames.mock.funcGetPickupGames != nil {
		mmGetPickupGames.mock.t.Fatalf("LogUploaderMock.GetPickupGames mock is already set by Set")
	}

	if mmGetPickupGames.defaultExpectation == nil {
		mmGetPickupGames.defaultExpectation = &LogUploaderMockGetPickupGamesExpectation{}
	}

	mmGetPickupGames.defaultExpectation.params = &LogUploaderMockGetPickupGamesParams{domain}
	for _, e := range mmGetPickupGames.expectations {
		if minimock.Equal(e.params, mmGetPickupGames.defaultExpectation.params) {
			mmGetPickupGames.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPickupGames.defaultExpectation.params)
		}
	}

	return mmGetPickupGames
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.GetPickupGames
func (mmGetPickupGames *mLogUploaderMockGetPickupGames) Inspect(f func(domain string)) *mLogUploaderMockGetPickupGames {
	if mmGetPickupGames.mock.inspectFuncGetPickupGames != nil {
		mmGetPickupGames.mock.t.Fatalf("Inspect function is already set for LogUploaderMock.GetPickupGames")
	}

	mmGetPickupGames.mock.inspectFuncGetPickupGames = f

	return mmGetPickupGames
}

// Return sets up results that will be returned by LogUploader.GetPickupGames
func (mmGetPickupGames *mLogUploaderMockGetPickupGames) Return(g1 mm_requests.GamesResponse, err error) *LogUploaderMock {
	if mmGetPickupGames.mock.funcGetPickupGames != nil {
		mmGetPickupGames.mock.t.Fatalf("LogUploaderMock.GetPickupGames mock is already set by Set")
	}

	if mmGetPickupGames.defaultExpectation == nil {
		mmGetPickupGames.defaultExpectation = &LogUploaderMockGetPickupGamesExpectation{mock: mmGetPickupGames.mock}
	}
	mmGetPickupGames.defaultExpectation.results = &LogUploaderMockGetPickupGamesResults{g1, err}
	return mmGetPickupGames.mock
}

//Set uses given function f to mock the LogUploader.GetPickupGames method
func (mmGetPickupGames *mLogUploaderMockGetPickupGames) Set(f func(domain string) (g1 mm_requests.GamesResponse, err error)) *LogUploaderMock {
	if mmGetPickupGames.defaultExpectation != nil {
		mmGetPickupGames.mock.t.Fatalf("Default expectation is already set for the LogUploader.GetPickupGames method")
	}

	if len(mmGetPickupGames.expectations) > 0 {
		mmGetPickupGames.mock.t.Fatalf("Some expectations are already set for the LogUploader.GetPickupGames method")
	}

	mmGetPickupGames.mock.funcGetPickupGames = f
	return mmGetPickupGames.mock
}

// When sets expectation for the LogUploader.GetPickupGames which will trigger the result defined by the following
// Then helper
func (mmGetPickupGames *mLogUploaderMockGetPickupGames) When(domain string) *LogUploaderMockGetPickupGamesExpectation {
	if mmGetPickupGames.mock.funcGetPickupGames != nil {
		mmGetPickupGames.mock.t.Fatalf("LogUploaderMock.GetPickupGames mock is already set by Set")
	}

	expectation := &LogUploaderMockGetPickupGamesExpectation{
		mock:   mmGetPickupGames.mock,
		params: &LogUploaderMockGetPickupGamesParams{domain},
	}
	mmGetPickupGames.expectations = append(mmGetPickupGames.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.GetPickupGames return parameters for the expectation previously defined by the When method
func (e *LogUploaderMockGetPickupGamesExpectation) Then(g1 mm_requests.GamesResponse, err error) *LogUploaderMock {
	e.results = &LogUploaderMockGetPickupGamesResults{g1, err}
	return e.mock
}

// GetPickupGames implements requests.LogUploader
func (mmGetPickupGames *LogUploaderMock) GetPickupGames(domain string) (g1 mm_requests.GamesResponse, err error) {
	mm_atomic.AddUint64(&mmGetPickupGames.beforeGetPickupGamesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPickupGames.afterGetPickupGamesCounter, 1)

	if mmGetPickupGames.inspectFuncGetPickupGames != nil {
		mmGetPickupGames.inspectFuncGetPickupGames(domain)
	}

	mm_params := &LogUploaderMockGetPickupGamesParams{domain}

	// Record call args
	mmGetPickupGames.GetPickupGamesMock.mutex.Lock()
	mmGetPickupGames.GetPickupGamesMock.callArgs = append(mmGetPickupGames.GetPickupGamesMock.callArgs, mm_params)
	mmGetPickupGames.GetPickupGamesMock.mutex.Unlock()

	for _, e := range mmGetPickupGames.GetPickupGamesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.g1, e.results.err
		}
	}

	if mmGetPickupGames.GetPickupGamesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPickupGames.GetPickupGamesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPickupGames.GetPickupGamesMock.defaultExpectation.params
		mm_got := LogUploaderMockGetPickupGamesParams{domain}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPickupGames.t.Errorf("LogUploaderMock.GetPickupGames got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPickupGames.GetPickupGamesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPickupGames.t.Fatal("No results are set for the LogUploaderMock.GetPickupGames")
		}
		return (*mm_results).g1, (*mm_results).err
	}
	if mmGetPickupGames.funcGetPickupGames != nil {
		return mmGetPickupGames.funcGetPickupGames(domain)
	}
	mmGetPickupGames.t.Fatalf("Unexpected call to LogUploaderMock.GetPickupGames. %v", domain)
	return
}

// GetPickupGamesAfterCounter returns a count of finished LogUploaderMock.GetPickupGames invocations
func (mmGetPickupGames *LogUploaderMock) GetPickupGamesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPickupGames.afterGetPickupGamesCounter)
}

// GetPickupGamesBeforeCounter returns a count of LogUploaderMock.GetPickupGames invocations
func (mmGetPickupGames *LogUploaderMock) GetPickupGamesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPickupGames.beforeGetPickupGamesCounter)
}

// Calls returns a list of arguments used in each call to LogUploaderMock.GetPickupGames.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPickupGames *mLogUploaderMockGetPickupGames) Calls() []*LogUploaderMockGetPickupGamesParams {
	mmGetPickupGames.mutex.RLock()

	argCopy := make([]*LogUploaderMockGetPickupGamesParams, len(mmGetPickupGames.callArgs))
	copy(argCopy, mmGetPickupGames.callArgs)

	mmGetPickupGames.mutex.RUnlock()

	return argCopy
}

// MinimockGetPickupGamesDone returns true if the count of the GetPickupGames invocations corresponds
// the number of defined expectations
func (m *LogUploaderMock) MinimockGetPickupGamesDone() bool {
	for _, e := range m.GetPickupGamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPickupGamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPickupGamesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPickupGames != nil && mm_atomic.LoadUint64(&m.afterGetPickupGamesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPickupGamesInspect logs each unmet expectation
func (m *LogUploaderMock) MinimockGetPickupGamesInspect() {
	for _, e := range m.GetPickupGamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogUploaderMock.GetPickupGames with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPickupGamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPickupGamesCounter) < 1 {
		if m.GetPickupGamesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogUploaderMock.GetPickupGames")
		} else {
			m.t.Errorf("Expected call to LogUploaderMock.GetPickupGames with params: %#v", *m.GetPickupGamesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPickupGames != nil && mm_atomic.LoadUint64(&m.afterGetPickupGamesCounter) < 1 {
		m.t.Error("Expected call to LogUploaderMock.GetPickupGames")
	}
}

type mLogUploaderMockMakeMultipartMap struct {
	mock               *LogUploaderMock
	defaultExpectation *LogUploaderMockMakeMultipartMapExpectation
	expectations       []*LogUploaderMockMakeMultipartMapExpectation

	callArgs []*LogUploaderMockMakeMultipartMapParams
	mutex    sync.RWMutex
}

// LogUploaderMockMakeMultipartMapExpectation specifies expectation struct of the LogUploader.MakeMultipartMap
type LogUploaderMockMakeMultipartMapExpectation struct {
	mock    *LogUploaderMock
	params  *LogUploaderMockMakeMultipartMapParams
	results *LogUploaderMockMakeMultipartMapResults
	Counter uint64
}

// LogUploaderMockMakeMultipartMapParams contains parameters of the LogUploader.MakeMultipartMap
type LogUploaderMockMakeMultipartMapParams struct {
	_map     string
	domain   string
	pickupID int
	buf      bytes.Buffer
}

// LogUploaderMockMakeMultipartMapResults contains results of the LogUploader.MakeMultipartMap
type LogUploaderMockMakeMultipartMapResults struct {
	m1 map[string]io.Reader
}

// Expect sets up expected params for LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Expect(_map string, domain string, pickupID int, buf bytes.Buffer) *mLogUploaderMockMakeMultipartMap {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogUploaderMock.MakeMultipartMap mock is already set by Set")
	}

	if mmMakeMultipartMap.defaultExpectation == nil {
		mmMakeMultipartMap.defaultExpectation = &LogUploaderMockMakeMultipartMapExpectation{}
	}

	mmMakeMultipartMap.defaultExpectation.params = &LogUploaderMockMakeMultipartMapParams{_map, domain, pickupID, buf}
	for _, e := range mmMakeMultipartMap.expectations {
		if minimock.Equal(e.params, mmMakeMultipartMap.defaultExpectation.params) {
			mmMakeMultipartMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMakeMultipartMap.defaultExpectation.params)
		}
	}

	return mmMakeMultipartMap
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Inspect(f func(_map string, domain string, pickupID int, buf bytes.Buffer)) *mLogUploaderMockMakeMultipartMap {
	if mmMakeMultipartMap.mock.inspectFuncMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("Inspect function is already set for LogUploaderMock.MakeMultipartMap")
	}

	mmMakeMultipartMap.mock.inspectFuncMakeMultipartMap = f

	return mmMakeMultipartMap
}

// Return sets up results that will be returned by LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Return(m1 map[string]io.Reader) *LogUploaderMock {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogUploaderMock.MakeMultipartMap mock is already set by Set")
	}

	if mmMakeMultipartMap.defaultExpectation == nil {
		mmMakeMultipartMap.defaultExpectation = &LogUploaderMockMakeMultipartMapExpectation{mock: mmMakeMultipartMap.mock}
	}
	mmMakeMultipartMap.defaultExpectation.results = &LogUploaderMockMakeMultipartMapResults{m1}
	return mmMakeMultipartMap.mock
}

//Set uses given function f to mock the LogUploader.MakeMultipartMap method
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Set(f func(_map string, domain string, pickupID int, buf bytes.Buffer) (m1 map[string]io.Reader)) *LogUploaderMock {
	if mmMakeMultipartMap.defaultExpectation != nil {
		mmMakeMultipartMap.mock.t.Fatalf("Default expectation is already set for the LogUploader.MakeMultipartMap method")
	}

	if len(mmMakeMultipartMap.expectations) > 0 {
		mmMakeMultipartMap.mock.t.Fatalf("Some expectations are already set for the LogUploader.MakeMultipartMap method")
	}

	mmMakeMultipartMap.mock.funcMakeMultipartMap = f
	return mmMakeMultipartMap.mock
}

// When sets expectation for the LogUploader.MakeMultipartMap which will trigger the result defined by the following
// Then helper
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) When(_map string, domain string, pickupID int, buf bytes.Buffer) *LogUploaderMockMakeMultipartMapExpectation {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogUploaderMock.MakeMultipartMap mock is already set by Set")
	}

	expectation := &LogUploaderMockMakeMultipartMapExpectation{
		mock:   mmMakeMultipartMap.mock,
		params: &LogUploaderMockMakeMultipartMapParams{_map, domain, pickupID, buf},
	}
	mmMakeMultipartMap.expectations = append(mmMakeMultipartMap.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.MakeMultipartMap return parameters for the expectation previously defined by the When method
func (e *LogUploaderMockMakeMultipartMapExpectation) Then(m1 map[string]io.Reader) *LogUploaderMock {
	e.results = &LogUploaderMockMakeMultipartMapResults{m1}
	return e.mock
}

// MakeMultipartMap implements requests.LogUploader
func (mmMakeMultipartMap *LogUploaderMock) MakeMultipartMap(_map string, domain string, pickupID int, buf bytes.Buffer) (m1 map[string]io.Reader) {
	mm_atomic.AddUint64(&mmMakeMultipartMap.beforeMakeMultipartMapCounter, 1)
	defer mm_atomic.AddUint64(&mmMakeMultipartMap.afterMakeMultipartMapCounter, 1)

	if mmMakeMultipartMap.inspectFuncMakeMultipartMap != nil {
		mmMakeMultipartMap.inspectFuncMakeMultipartMap(_map, domain, pickupID, buf)
	}

	mm_params := &LogUploaderMockMakeMultipartMapParams{_map, domain, pickupID, buf}

	// Record call args
	mmMakeMultipartMap.MakeMultipartMapMock.mutex.Lock()
	mmMakeMultipartMap.MakeMultipartMapMock.callArgs = append(mmMakeMultipartMap.MakeMultipartMapMock.callArgs, mm_params)
	mmMakeMultipartMap.MakeMultipartMapMock.mutex.Unlock()

	for _, e := range mmMakeMultipartMap.MakeMultipartMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1
		}
	}

	if mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.Counter, 1)
		mm_want := mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.params
		mm_got := LogUploaderMockMakeMultipartMapParams{_map, domain, pickupID, buf}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMakeMultipartMap.t.Errorf("LogUploaderMock.MakeMultipartMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.results
		if mm_results == nil {
			mmMakeMultipartMap.t.Fatal("No results are set for the LogUploaderMock.MakeMultipartMap")
		}
		return (*mm_results).m1
	}
	if mmMakeMultipartMap.funcMakeMultipartMap != nil {
		return mmMakeMultipartMap.funcMakeMultipartMap(_map, domain, pickupID, buf)
	}
	mmMakeMultipartMap.t.Fatalf("Unexpected call to LogUploaderMock.MakeMultipartMap. %v %v %v %v", _map, domain, pickupID, buf)
	return
}

// MakeMultipartMapAfterCounter returns a count of finished LogUploaderMock.MakeMultipartMap invocations
func (mmMakeMultipartMap *LogUploaderMock) MakeMultipartMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeMultipartMap.afterMakeMultipartMapCounter)
}

// MakeMultipartMapBeforeCounter returns a count of LogUploaderMock.MakeMultipartMap invocations
func (mmMakeMultipartMap *LogUploaderMock) MakeMultipartMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeMultipartMap.beforeMakeMultipartMapCounter)
}

// Calls returns a list of arguments used in each call to LogUploaderMock.MakeMultipartMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Calls() []*LogUploaderMockMakeMultipartMapParams {
	mmMakeMultipartMap.mutex.RLock()

	argCopy := make([]*LogUploaderMockMakeMultipartMapParams, len(mmMakeMultipartMap.callArgs))
	copy(argCopy, mmMakeMultipartMap.callArgs)

	mmMakeMultipartMap.mutex.RUnlock()

	return argCopy
}

// MinimockMakeMultipartMapDone returns true if the count of the MakeMultipartMap invocations corresponds
// the number of defined expectations
func (m *LogUploaderMock) MinimockMakeMultipartMapDone() bool {
	for _, e := range m.MakeMultipartMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeMultipartMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeMultipartMap != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockMakeMultipartMapInspect logs each unmet expectation
func (m *LogUploaderMock) MinimockMakeMultipartMapInspect() {
	for _, e := range m.MakeMultipartMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogUploaderMock.MakeMultipartMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeMultipartMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		if m.MakeMultipartMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogUploaderMock.MakeMultipartMap")
		} else {
			m.t.Errorf("Expected call to LogUploaderMock.MakeMultipartMap with params: %#v", *m.MakeMultipartMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeMultipartMap != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		m.t.Error("Expected call to LogUploaderMock.MakeMultipartMap")
	}
}

type mLogUploaderMockResolvePlayers struct {
	mock               *LogUploaderMock
	defaultExpectation *LogUploaderMockResolvePlayersExpectation
	expectations       []*LogUploaderMockResolvePlayersExpectation

	callArgs []*LogUploaderMockResolvePlayersParams
	mutex    sync.RWMutex
}

// LogUploaderMockResolvePlayersExpectation specifies expectation struct of the LogUploader.ResolvePlayers
type LogUploaderMockResolvePlayersExpectation struct {
	mock    *LogUploaderMock
	params  *LogUploaderMockResolvePlayersParams
	results *LogUploaderMockResolvePlayersResults
	Counter uint64
}

// LogUploaderMockResolvePlayersParams contains parameters of the LogUploader.ResolvePlayers
type LogUploaderMockResolvePlayersParams struct {
	domain  string
	players []*stats.PickupPlayer
}

// LogUploaderMockResolvePlayersResults contains results of the LogUploader.ResolvePlayers
type LogUploaderMockResolvePlayersResults struct {
	err error
}

// Expect sets up expected params for LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Expect(domain string, players []*stats.PickupPlayer) *mLogUploaderMockResolvePlayers {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogUploaderMock.ResolvePlayers mock is already set by Set")
	}

	if mmResolvePlayers.defaultExpectation == nil {
		mmResolvePlayers.defaultExpectation = &LogUploaderMockResolvePlayersExpectation{}
	}

	mmResolvePlayers.defaultExpectation.params = &LogUploaderMockResolvePlayersParams{domain, players}
	for _, e := range mmResolvePlayers.expectations {
		if minimock.Equal(e.params, mmResolvePlayers.defaultExpectation.params) {
			mmResolvePlayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResolvePlayers.defaultExpectation.params)
		}
	}

	return mmResolvePlayers
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Inspect(f func(domain string, players []*stats.PickupPlayer)) *mLogUploaderMockResolvePlayers {
	if mmResolvePlayers.mock.inspectFuncResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("Inspect function is already set for LogUploaderMock.ResolvePlayers")
	}

	mmResolvePlayers.mock.inspectFuncResolvePlayers = f

	return mmResolvePlayers
}

// Return sets up results that will be returned by LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Return(err error) *LogUploaderMock {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogUploaderMock.ResolvePlayers mock is already set by Set")
	}

	if mmResolvePlayers.defaultExpectation == nil {
		mmResolvePlayers.defaultExpectation = &LogUploaderMockResolvePlayersExpectation{mock: mmResolvePlayers.mock}
	}
	mmResolvePlayers.defaultExpectation.results = &LogUploaderMockResolvePlayersResults{err}
	return mmResolvePlayers.mock
}

//Set uses given function f to mock the LogUploader.ResolvePlayers method
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Set(f func(domain string, players []*stats.PickupPlayer) (err error)) *LogUploaderMock {
	if mmResolvePlayers.defaultExpectation != nil {
		mmResolvePlayers.mock.t.Fatalf("Default expectation is already set for the LogUploader.ResolvePlayers method")
	}

	if len(mmResolvePlayers.expectations) > 0 {
		mmResolvePlayers.mock.t.Fatalf("Some expectations are already set for the LogUploader.ResolvePlayers method")
	}

	mmResolvePlayers.mock.funcResolvePlayers = f
	return mmResolvePlayers.mock
}

// When sets expectation for the LogUploader.ResolvePlayers which will trigger the result defined by the following
// Then helper
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) When(domain string, players []*stats.PickupPlayer) *LogUploaderMockResolvePlayersExpectation {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogUploaderMock.ResolvePlayers mock is already set by Set")
	}

	expectation := &LogUploaderMockResolvePlayersExpectation{
		mock:   mmResolvePlayers.mock,
		params: &LogUploaderMockResolvePlayersParams{domain, players},
	}
	mmResolvePlayers.expectations = append(mmResolvePlayers.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.ResolvePlayers return parameters for the expectation previously defined by the When method
func (e *LogUploaderMockResolvePlayersExpectation) Then(err error) *LogUploaderMock {
	e.results = &LogUploaderMockResolvePlayersResults{err}
	return e.mock
}

// ResolvePlayers implements requests.LogUploader
func (mmResolvePlayers *LogUploaderMock) ResolvePlayers(domain string, players []*stats.PickupPlayer) (err error) {
	mm_atomic.AddUint64(&mmResolvePlayers.beforeResolvePlayersCounter, 1)
	defer mm_atomic.AddUint64(&mmResolvePlayers.afterResolvePlayersCounter, 1)

	if mmResolvePlayers.inspectFuncResolvePlayers != nil {
		mmResolvePlayers.inspectFuncResolvePlayers(domain, players)
	}

	mm_params := &LogUploaderMockResolvePlayersParams{domain, players}

	// Record call args
	mmResolvePlayers.ResolvePlayersMock.mutex.Lock()
	mmResolvePlayers.ResolvePlayersMock.callArgs = append(mmResolvePlayers.ResolvePlayersMock.callArgs, mm_params)
	mmResolvePlayers.ResolvePlayersMock.mutex.Unlock()

	for _, e := range mmResolvePlayers.ResolvePlayersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmResolvePlayers.ResolvePlayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResolvePlayers.ResolvePlayersMock.defaultExpectation.Counter, 1)
		mm_want := mmResolvePlayers.ResolvePlayersMock.defaultExpectation.params
		mm_got := LogUploaderMockResolvePlayersParams{domain, players}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmResolvePlayers.t.Errorf("LogUploaderMock.ResolvePlayers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmResolvePlayers.ResolvePlayersMock.defaultExpectation.results
		if mm_results == nil {
			mmResolvePlayers.t.Fatal("No results are set for the LogUploaderMock.ResolvePlayers")
		}
		return (*mm_results).err
	}
	if mmResolvePlayers.funcResolvePlayers != nil {
		return mmResolvePlayers.funcResolvePlayers(domain, players)
	}
	mmResolvePlayers.t.Fatalf("Unexpected call to LogUploaderMock.ResolvePlayers. %v %v", domain, players)
	return
}

// ResolvePlayersAfterCounter returns a count of finished LogUploaderMock.ResolvePlayers invocations
func (mmResolvePlayers *LogUploaderMock) ResolvePlayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolvePlayers.afterResolvePlayersCounter)
}

// ResolvePlayersBeforeCounter returns a count of LogUploaderMock.ResolvePlayers invocations
func (mmResolvePlayers *LogUploaderMock) ResolvePlayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolvePlayers.beforeResolvePlayersCounter)
}

// Calls returns a list of arguments used in each call to LogUploaderMock.ResolvePlayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Calls() []*LogUploaderMockResolvePlayersParams {
	mmResolvePlayers.mutex.RLock()

	argCopy := make([]*LogUploaderMockResolvePlayersParams, len(mmResolvePlayers.callArgs))
	copy(argCopy, mmResolvePlayers.callArgs)

	mmResolvePlayers.mutex.RUnlock()

	return argCopy
}

// MinimockResolvePlayersDone returns true if the count of the ResolvePlayers invocations corresponds
// the number of defined expectations
func (m *LogUploaderMock) MinimockResolvePlayersDone() bool {
	for _, e := range m.ResolvePlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolvePlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolvePlayers != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		return false
	}
	return true
}

// MinimockResolvePlayersInspect logs each unmet expectation
func (m *LogUploaderMock) MinimockResolvePlayersInspect() {
	for _, e := range m.ResolvePlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogUploaderMock.ResolvePlayers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolvePlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		if m.ResolvePlayersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogUploaderMock.ResolvePlayers")
		} else {
			m.t.Errorf("Expected call to LogUploaderMock.ResolvePlayers with params: %#v", *m.ResolvePlayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolvePlayers != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		m.t.Error("Expected call to LogUploaderMock.ResolvePlayers")
	}
}

type mLogUploaderMockUploadLogFile struct {
	mock               *LogUploaderMock
	defaultExpectation *LogUploaderMockUploadLogFileExpectation
	expectations       []*LogUploaderMockUploadLogFileExpectation

	callArgs []*LogUploaderMockUploadLogFileParams
	mutex    sync.RWMutex
}

// LogUploaderMockUploadLogFileExpectation specifies expectation struct of the LogUploader.UploadLogFile
type LogUploaderMockUploadLogFileExpectation struct {
	mock    *LogUploaderMock
	params  *LogUploaderMockUploadLogFileParams
	results *LogUploaderMockUploadLogFileResults
	Counter uint64
}

// LogUploaderMockUploadLogFileParams contains parameters of the LogUploader.UploadLogFile
type LogUploaderMockUploadLogFileParams struct {
	payload map[string]io.Reader
}

// LogUploaderMockUploadLogFileResults contains results of the LogUploader.UploadLogFile
type LogUploaderMockUploadLogFileResults struct {
	err error
}

// Expect sets up expected params for LogUploader.UploadLogFile
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Expect(payload map[string]io.Reader) *mLogUploaderMockUploadLogFile {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogUploaderMock.UploadLogFile mock is already set by Set")
	}

	if mmUploadLogFile.defaultExpectation == nil {
		mmUploadLogFile.defaultExpectation = &LogUploaderMockUploadLogFileExpectation{}
	}

	mmUploadLogFile.defaultExpectation.params = &LogUploaderMockUploadLogFileParams{payload}
	for _, e := range mmUploadLogFile.expectations {
		if minimock.Equal(e.params, mmUploadLogFile.defaultExpectation.params) {
			mmUploadLogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadLogFile.defaultExpectation.params)
		}
	}

	return mmUploadLogFile
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.UploadLogFile
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Inspect(f func(payload map[string]io.Reader)) *mLogUploaderMockUploadLogFile {
	if mmUploadLogFile.mock.inspectFuncUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("Inspect function is already set for LogUploaderMock.UploadLogFile")
	}

	mmUploadLogFile.mock.inspectFuncUploadLogFile = f

	return mmUploadLogFile
}

// Return sets up results that will be returned by LogUploader.UploadLogFile
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Return(err error) *LogUploaderMock {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogUploaderMock.UploadLogFile mock is already set by Set")
	}

	if mmUploadLogFile.defaultExpectation == nil {
		mmUploadLogFile.defaultExpectation = &LogUploaderMockUploadLogFileExpectation{mock: mmUploadLogFile.mock}
	}
	mmUploadLogFile.defaultExpectation.results = &LogUploaderMockUploadLogFileResults{err}
	return mmUploadLogFile.mock
}

//Set uses given function f to mock the LogUploader.UploadLogFile method
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Set(f func(payload map[string]io.Reader) (err error)) *LogUploaderMock {
	if mmUploadLogFile.defaultExpectation != nil {
		mmUploadLogFile.mock.t.Fatalf("Default expectation is already set for the LogUploader.UploadLogFile method")
	}

	if len(mmUploadLogFile.expectations) > 0 {
		mmUploadLogFile.mock.t.Fatalf("Some expectations are already set for the LogUploader.UploadLogFile method")
	}

	mmUploadLogFile.mock.funcUploadLogFile = f
	return mmUploadLogFile.mock
}

// When sets expectation for the LogUploader.UploadLogFile which will trigger the result defined by the following
// Then helper
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) When(payload map[string]io.Reader) *LogUploaderMockUploadLogFileExpectation {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogUploaderMock.UploadLogFile mock is already set by Set")
	}

	expectation := &LogUploaderMockUploadLogFileExpectation{
		mock:   mmUploadLogFile.mock,
		params: &LogUploaderMockUploadLogFileParams{payload},
	}
	mmUploadLogFile.expectations = append(mmUploadLogFile.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.UploadLogFile return parameters for the expectation previously defined by the When method
func (e *LogUploaderMockUploadLogFileExpectation) Then(err error) *LogUploaderMock {
	e.results = &LogUploaderMockUploadLogFileResults{err}
	return e.mock
}

// UploadLogFile implements requests.LogUploader
func (mmUploadLogFile *LogUploaderMock) UploadLogFile(payload map[string]io.Reader) (err error) {
	mm_atomic.AddUint64(&mmUploadLogFile.beforeUploadLogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadLogFile.afterUploadLogFileCounter, 1)

	if mmUploadLogFile.inspectFuncUploadLogFile != nil {
		mmUploadLogFile.inspectFuncUploadLogFile(payload)
	}

	mm_params := &LogUploaderMockUploadLogFileParams{payload}

	// Record call args
	mmUploadLogFile.UploadLogFileMock.mutex.Lock()
	mmUploadLogFile.UploadLogFileMock.callArgs = append(mmUploadLogFile.UploadLogFileMock.callArgs, mm_params)
	mmUploadLogFile.UploadLogFileMock.mutex.Unlock()

	for _, e := range mmUploadLogFile.UploadLogFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadLogFile.UploadLogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadLogFile.UploadLogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadLogFile.UploadLogFileMock.defaultExpectation.params
		mm_got := LogUploaderMockUploadLogFileParams{payload}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadLogFile.t.Errorf("LogUploaderMock.UploadLogFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadLogFile.UploadLogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadLogFile.t.Fatal("No results are set for the LogUploaderMock.UploadLogFile")
		}
		return (*mm_results).err
	}
	if mmUploadLogFile.funcUploadLogFile != nil {
		return mmUploadLogFile.funcUploadLogFile(payload)
	}
	mmUploadLogFile.t.Fatalf("Unexpected call to LogUploaderMock.UploadLogFile. %v", payload)
	return
}

// UploadLogFileAfterCounter returns a count of finished LogUploaderMock.UploadLogFile invocations
func (mmUploadLogFile *LogUploaderMock) UploadLogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadLogFile.afterUploadLogFileCounter)
}

// UploadLogFileBeforeCounter returns a count of LogUploaderMock.UploadLogFile invocations
func (mmUploadLogFile *LogUploaderMock) UploadLogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadLogFile.beforeUploadLogFileCounter)
}

// Calls returns a list of arguments used in each call to LogUploaderMock.UploadLogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Calls() []*LogUploaderMockUploadLogFileParams {
	mmUploadLogFile.mutex.RLock()

	argCopy := make([]*LogUploaderMockUploadLogFileParams, len(mmUploadLogFile.callArgs))
	copy(argCopy, mmUploadLogFile.callArgs)

	mmUploadLogFile.mutex.RUnlock()

	return argCopy
}

// MinimockUploadLogFileDone returns true if the count of the UploadLogFile invocations corresponds
// the number of defined expectations
func (m *LogUploaderMock) MinimockUploadLogFileDone() bool {
	for _, e := range m.UploadLogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UploadLogFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadLogFile != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockUploadLogFileInspect logs each unmet expectation
func (m *LogUploaderMock) MinimockUploadLogFileInspect() {
	for _, e := range m.UploadLogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogUploaderMock.UploadLogFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UploadLogFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		if m.UploadLogFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogUploaderMock.UploadLogFile")
		} else {
			m.t.Errorf("Expected call to LogUploaderMock.UploadLogFile with params: %#v", *m.UploadLogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadLogFile != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		m.t.Error("Expected call to LogUploaderMock.UploadLogFile")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LogUploaderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetPickupGamesInspect()

		m.MinimockMakeMultipartMapInspect()

		m.MinimockResolvePlayersInspect()

		m.MinimockUploadLogFileInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LogUploaderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LogUploaderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetPickupGamesDone() &&
		m.MinimockMakeMultipartMapDone() &&
		m.MinimockResolvePlayersDone() &&
		m.MinimockUploadLogFileDone()
}
