package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/requests.LogUploader -o ./pkg/mocks/log_processor_mock.go

import (
	mm_requests "LogWatcher/pkg/requests"
	"LogWatcher/pkg/stats"
	"bytes"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LogProcessorMock implements requests.LogUploader
type LogProcessorMock struct {
	t minimock.Tester

	funcGetPickupGames          func(domain string) (g1 mm_requests.GamesResponse, err error)
	inspectFuncGetPickupGames   func(domain string)
	afterGetPickupGamesCounter  uint64
	beforeGetPickupGamesCounter uint64
	GetPickupGamesMock          mLogProcessorMockGetPickupGames

	funcMakeMultipartMap          func(_map string, domain string, pickupID int, buf bytes.Buffer) (m1 map[string]io.Reader)
	inspectFuncMakeMultipartMap   func(_map string, domain string, pickupID int, buf bytes.Buffer)
	afterMakeMultipartMapCounter  uint64
	beforeMakeMultipartMapCounter uint64
	MakeMultipartMapMock          mLogProcessorMockMakeMultipartMap

	funcResolvePlayers          func(domain string, players []*stats.PickupPlayer) (err error)
	inspectFuncResolvePlayers   func(domain string, players []*stats.PickupPlayer)
	afterResolvePlayersCounter  uint64
	beforeResolvePlayersCounter uint64
	ResolvePlayersMock          mLogProcessorMockResolvePlayers

	funcUploadLogFile          func(payload map[string]io.Reader) (err error)
	inspectFuncUploadLogFile   func(payload map[string]io.Reader)
	afterUploadLogFileCounter  uint64
	beforeUploadLogFileCounter uint64
	UploadLogFileMock          mLogProcessorMockUploadLogFile
}

// NewLogProcessorMock returns a mock for requests.LogUploader
func NewLogProcessorMock(t minimock.Tester) *LogProcessorMock {
	m := &LogProcessorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetPickupGamesMock = mLogProcessorMockGetPickupGames{mock: m}
	m.GetPickupGamesMock.callArgs = []*LogProcessorMockGetPickupGamesParams{}

	m.MakeMultipartMapMock = mLogProcessorMockMakeMultipartMap{mock: m}
	m.MakeMultipartMapMock.callArgs = []*LogProcessorMockMakeMultipartMapParams{}

	m.ResolvePlayersMock = mLogProcessorMockResolvePlayers{mock: m}
	m.ResolvePlayersMock.callArgs = []*LogProcessorMockResolvePlayersParams{}

	m.UploadLogFileMock = mLogProcessorMockUploadLogFile{mock: m}
	m.UploadLogFileMock.callArgs = []*LogProcessorMockUploadLogFileParams{}

	return m
}

type mLogProcessorMockGetPickupGames struct {
	mock               *LogProcessorMock
	defaultExpectation *LogProcessorMockGetPickupGamesExpectation
	expectations       []*LogProcessorMockGetPickupGamesExpectation

	callArgs []*LogProcessorMockGetPickupGamesParams
	mutex    sync.RWMutex
}

// LogProcessorMockGetPickupGamesExpectation specifies expectation struct of the LogUploader.GetPickupGames
type LogProcessorMockGetPickupGamesExpectation struct {
	mock    *LogProcessorMock
	params  *LogProcessorMockGetPickupGamesParams
	results *LogProcessorMockGetPickupGamesResults
	Counter uint64
}

// LogProcessorMockGetPickupGamesParams contains parameters of the LogUploader.GetPickupGames
type LogProcessorMockGetPickupGamesParams struct {
	domain string
}

// LogProcessorMockGetPickupGamesResults contains results of the LogUploader.GetPickupGames
type LogProcessorMockGetPickupGamesResults struct {
	g1  mm_requests.GamesResponse
	err error
}

// Expect sets up expected params for LogUploader.GetPickupGames
func (mmGetPickupGames *mLogProcessorMockGetPickupGames) Expect(domain string) *mLogProcessorMockGetPickupGames {
	if mmGetPickupGames.mock.funcGetPickupGames != nil {
		mmGetPickupGames.mock.t.Fatalf("LogProcessorMock.GetPickupGames mock is already set by Set")
	}

	if mmGetPickupGames.defaultExpectation == nil {
		mmGetPickupGames.defaultExpectation = &LogProcessorMockGetPickupGamesExpectation{}
	}

	mmGetPickupGames.defaultExpectation.params = &LogProcessorMockGetPickupGamesParams{domain}
	for _, e := range mmGetPickupGames.expectations {
		if minimock.Equal(e.params, mmGetPickupGames.defaultExpectation.params) {
			mmGetPickupGames.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPickupGames.defaultExpectation.params)
		}
	}

	return mmGetPickupGames
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.GetPickupGames
func (mmGetPickupGames *mLogProcessorMockGetPickupGames) Inspect(f func(domain string)) *mLogProcessorMockGetPickupGames {
	if mmGetPickupGames.mock.inspectFuncGetPickupGames != nil {
		mmGetPickupGames.mock.t.Fatalf("Inspect function is already set for LogProcessorMock.GetPickupGames")
	}

	mmGetPickupGames.mock.inspectFuncGetPickupGames = f

	return mmGetPickupGames
}

// Return sets up results that will be returned by LogUploader.GetPickupGames
func (mmGetPickupGames *mLogProcessorMockGetPickupGames) Return(g1 mm_requests.GamesResponse, err error) *LogProcessorMock {
	if mmGetPickupGames.mock.funcGetPickupGames != nil {
		mmGetPickupGames.mock.t.Fatalf("LogProcessorMock.GetPickupGames mock is already set by Set")
	}

	if mmGetPickupGames.defaultExpectation == nil {
		mmGetPickupGames.defaultExpectation = &LogProcessorMockGetPickupGamesExpectation{mock: mmGetPickupGames.mock}
	}
	mmGetPickupGames.defaultExpectation.results = &LogProcessorMockGetPickupGamesResults{g1, err}
	return mmGetPickupGames.mock
}

//Set uses given function f to mock the LogUploader.GetPickupGames method
func (mmGetPickupGames *mLogProcessorMockGetPickupGames) Set(f func(domain string) (g1 mm_requests.GamesResponse, err error)) *LogProcessorMock {
	if mmGetPickupGames.defaultExpectation != nil {
		mmGetPickupGames.mock.t.Fatalf("Default expectation is already set for the LogUploader.GetPickupGames method")
	}

	if len(mmGetPickupGames.expectations) > 0 {
		mmGetPickupGames.mock.t.Fatalf("Some expectations are already set for the LogUploader.GetPickupGames method")
	}

	mmGetPickupGames.mock.funcGetPickupGames = f
	return mmGetPickupGames.mock
}

// When sets expectation for the LogUploader.GetPickupGames which will trigger the result defined by the following
// Then helper
func (mmGetPickupGames *mLogProcessorMockGetPickupGames) When(domain string) *LogProcessorMockGetPickupGamesExpectation {
	if mmGetPickupGames.mock.funcGetPickupGames != nil {
		mmGetPickupGames.mock.t.Fatalf("LogProcessorMock.GetPickupGames mock is already set by Set")
	}

	expectation := &LogProcessorMockGetPickupGamesExpectation{
		mock:   mmGetPickupGames.mock,
		params: &LogProcessorMockGetPickupGamesParams{domain},
	}
	mmGetPickupGames.expectations = append(mmGetPickupGames.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.GetPickupGames return parameters for the expectation previously defined by the When method
func (e *LogProcessorMockGetPickupGamesExpectation) Then(g1 mm_requests.GamesResponse, err error) *LogProcessorMock {
	e.results = &LogProcessorMockGetPickupGamesResults{g1, err}
	return e.mock
}

// GetPickupGames implements requests.LogUploader
func (mmGetPickupGames *LogProcessorMock) GetPickupGames(domain string) (g1 mm_requests.GamesResponse, err error) {
	mm_atomic.AddUint64(&mmGetPickupGames.beforeGetPickupGamesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPickupGames.afterGetPickupGamesCounter, 1)

	if mmGetPickupGames.inspectFuncGetPickupGames != nil {
		mmGetPickupGames.inspectFuncGetPickupGames(domain)
	}

	mm_params := &LogProcessorMockGetPickupGamesParams{domain}

	// Record call args
	mmGetPickupGames.GetPickupGamesMock.mutex.Lock()
	mmGetPickupGames.GetPickupGamesMock.callArgs = append(mmGetPickupGames.GetPickupGamesMock.callArgs, mm_params)
	mmGetPickupGames.GetPickupGamesMock.mutex.Unlock()

	for _, e := range mmGetPickupGames.GetPickupGamesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.g1, e.results.err
		}
	}

	if mmGetPickupGames.GetPickupGamesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPickupGames.GetPickupGamesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPickupGames.GetPickupGamesMock.defaultExpectation.params
		mm_got := LogProcessorMockGetPickupGamesParams{domain}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPickupGames.t.Errorf("LogProcessorMock.GetPickupGames got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPickupGames.GetPickupGamesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPickupGames.t.Fatal("No results are set for the LogProcessorMock.GetPickupGames")
		}
		return (*mm_results).g1, (*mm_results).err
	}
	if mmGetPickupGames.funcGetPickupGames != nil {
		return mmGetPickupGames.funcGetPickupGames(domain)
	}
	mmGetPickupGames.t.Fatalf("Unexpected call to LogProcessorMock.GetPickupGames. %v", domain)
	return
}

// GetPickupGamesAfterCounter returns a count of finished LogProcessorMock.GetPickupGames invocations
func (mmGetPickupGames *LogProcessorMock) GetPickupGamesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPickupGames.afterGetPickupGamesCounter)
}

// GetPickupGamesBeforeCounter returns a count of LogProcessorMock.GetPickupGames invocations
func (mmGetPickupGames *LogProcessorMock) GetPickupGamesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPickupGames.beforeGetPickupGamesCounter)
}

// Calls returns a list of arguments used in each call to LogProcessorMock.GetPickupGames.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPickupGames *mLogProcessorMockGetPickupGames) Calls() []*LogProcessorMockGetPickupGamesParams {
	mmGetPickupGames.mutex.RLock()

	argCopy := make([]*LogProcessorMockGetPickupGamesParams, len(mmGetPickupGames.callArgs))
	copy(argCopy, mmGetPickupGames.callArgs)

	mmGetPickupGames.mutex.RUnlock()

	return argCopy
}

// MinimockGetPickupGamesDone returns true if the count of the GetPickupGames invocations corresponds
// the number of defined expectations
func (m *LogProcessorMock) MinimockGetPickupGamesDone() bool {
	for _, e := range m.GetPickupGamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPickupGamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPickupGamesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPickupGames != nil && mm_atomic.LoadUint64(&m.afterGetPickupGamesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPickupGamesInspect logs each unmet expectation
func (m *LogProcessorMock) MinimockGetPickupGamesInspect() {
	for _, e := range m.GetPickupGamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogProcessorMock.GetPickupGames with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPickupGamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPickupGamesCounter) < 1 {
		if m.GetPickupGamesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogProcessorMock.GetPickupGames")
		} else {
			m.t.Errorf("Expected call to LogProcessorMock.GetPickupGames with params: %#v", *m.GetPickupGamesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPickupGames != nil && mm_atomic.LoadUint64(&m.afterGetPickupGamesCounter) < 1 {
		m.t.Error("Expected call to LogProcessorMock.GetPickupGames")
	}
}

type mLogProcessorMockMakeMultipartMap struct {
	mock               *LogProcessorMock
	defaultExpectation *LogProcessorMockMakeMultipartMapExpectation
	expectations       []*LogProcessorMockMakeMultipartMapExpectation

	callArgs []*LogProcessorMockMakeMultipartMapParams
	mutex    sync.RWMutex
}

// LogProcessorMockMakeMultipartMapExpectation specifies expectation struct of the LogUploader.MakeMultipartMap
type LogProcessorMockMakeMultipartMapExpectation struct {
	mock    *LogProcessorMock
	params  *LogProcessorMockMakeMultipartMapParams
	results *LogProcessorMockMakeMultipartMapResults
	Counter uint64
}

// LogProcessorMockMakeMultipartMapParams contains parameters of the LogUploader.MakeMultipartMap
type LogProcessorMockMakeMultipartMapParams struct {
	_map     string
	domain   string
	pickupID int
	buf      bytes.Buffer
}

// LogProcessorMockMakeMultipartMapResults contains results of the LogUploader.MakeMultipartMap
type LogProcessorMockMakeMultipartMapResults struct {
	m1 map[string]io.Reader
}

// Expect sets up expected params for LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogProcessorMockMakeMultipartMap) Expect(_map string, domain string, pickupID int, buf bytes.Buffer) *mLogProcessorMockMakeMultipartMap {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogProcessorMock.MakeMultipartMap mock is already set by Set")
	}

	if mmMakeMultipartMap.defaultExpectation == nil {
		mmMakeMultipartMap.defaultExpectation = &LogProcessorMockMakeMultipartMapExpectation{}
	}

	mmMakeMultipartMap.defaultExpectation.params = &LogProcessorMockMakeMultipartMapParams{_map, domain, pickupID, buf}
	for _, e := range mmMakeMultipartMap.expectations {
		if minimock.Equal(e.params, mmMakeMultipartMap.defaultExpectation.params) {
			mmMakeMultipartMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMakeMultipartMap.defaultExpectation.params)
		}
	}

	return mmMakeMultipartMap
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogProcessorMockMakeMultipartMap) Inspect(f func(_map string, domain string, pickupID int, buf bytes.Buffer)) *mLogProcessorMockMakeMultipartMap {
	if mmMakeMultipartMap.mock.inspectFuncMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("Inspect function is already set for LogProcessorMock.MakeMultipartMap")
	}

	mmMakeMultipartMap.mock.inspectFuncMakeMultipartMap = f

	return mmMakeMultipartMap
}

// Return sets up results that will be returned by LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogProcessorMockMakeMultipartMap) Return(m1 map[string]io.Reader) *LogProcessorMock {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogProcessorMock.MakeMultipartMap mock is already set by Set")
	}

	if mmMakeMultipartMap.defaultExpectation == nil {
		mmMakeMultipartMap.defaultExpectation = &LogProcessorMockMakeMultipartMapExpectation{mock: mmMakeMultipartMap.mock}
	}
	mmMakeMultipartMap.defaultExpectation.results = &LogProcessorMockMakeMultipartMapResults{m1}
	return mmMakeMultipartMap.mock
}

//Set uses given function f to mock the LogUploader.MakeMultipartMap method
func (mmMakeMultipartMap *mLogProcessorMockMakeMultipartMap) Set(f func(_map string, domain string, pickupID int, buf bytes.Buffer) (m1 map[string]io.Reader)) *LogProcessorMock {
	if mmMakeMultipartMap.defaultExpectation != nil {
		mmMakeMultipartMap.mock.t.Fatalf("Default expectation is already set for the LogUploader.MakeMultipartMap method")
	}

	if len(mmMakeMultipartMap.expectations) > 0 {
		mmMakeMultipartMap.mock.t.Fatalf("Some expectations are already set for the LogUploader.MakeMultipartMap method")
	}

	mmMakeMultipartMap.mock.funcMakeMultipartMap = f
	return mmMakeMultipartMap.mock
}

// When sets expectation for the LogUploader.MakeMultipartMap which will trigger the result defined by the following
// Then helper
func (mmMakeMultipartMap *mLogProcessorMockMakeMultipartMap) When(_map string, domain string, pickupID int, buf bytes.Buffer) *LogProcessorMockMakeMultipartMapExpectation {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogProcessorMock.MakeMultipartMap mock is already set by Set")
	}

	expectation := &LogProcessorMockMakeMultipartMapExpectation{
		mock:   mmMakeMultipartMap.mock,
		params: &LogProcessorMockMakeMultipartMapParams{_map, domain, pickupID, buf},
	}
	mmMakeMultipartMap.expectations = append(mmMakeMultipartMap.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.MakeMultipartMap return parameters for the expectation previously defined by the When method
func (e *LogProcessorMockMakeMultipartMapExpectation) Then(m1 map[string]io.Reader) *LogProcessorMock {
	e.results = &LogProcessorMockMakeMultipartMapResults{m1}
	return e.mock
}

// MakeMultipartMap implements requests.LogUploader
func (mmMakeMultipartMap *LogProcessorMock) MakeMultipartMap(_map string, domain string, pickupID int, buf bytes.Buffer) (m1 map[string]io.Reader) {
	mm_atomic.AddUint64(&mmMakeMultipartMap.beforeMakeMultipartMapCounter, 1)
	defer mm_atomic.AddUint64(&mmMakeMultipartMap.afterMakeMultipartMapCounter, 1)

	if mmMakeMultipartMap.inspectFuncMakeMultipartMap != nil {
		mmMakeMultipartMap.inspectFuncMakeMultipartMap(_map, domain, pickupID, buf)
	}

	mm_params := &LogProcessorMockMakeMultipartMapParams{_map, domain, pickupID, buf}

	// Record call args
	mmMakeMultipartMap.MakeMultipartMapMock.mutex.Lock()
	mmMakeMultipartMap.MakeMultipartMapMock.callArgs = append(mmMakeMultipartMap.MakeMultipartMapMock.callArgs, mm_params)
	mmMakeMultipartMap.MakeMultipartMapMock.mutex.Unlock()

	for _, e := range mmMakeMultipartMap.MakeMultipartMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1
		}
	}

	if mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.Counter, 1)
		mm_want := mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.params
		mm_got := LogProcessorMockMakeMultipartMapParams{_map, domain, pickupID, buf}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMakeMultipartMap.t.Errorf("LogProcessorMock.MakeMultipartMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.results
		if mm_results == nil {
			mmMakeMultipartMap.t.Fatal("No results are set for the LogProcessorMock.MakeMultipartMap")
		}
		return (*mm_results).m1
	}
	if mmMakeMultipartMap.funcMakeMultipartMap != nil {
		return mmMakeMultipartMap.funcMakeMultipartMap(_map, domain, pickupID, buf)
	}
	mmMakeMultipartMap.t.Fatalf("Unexpected call to LogProcessorMock.MakeMultipartMap. %v %v %v %v", _map, domain, pickupID, buf)
	return
}

// MakeMultipartMapAfterCounter returns a count of finished LogProcessorMock.MakeMultipartMap invocations
func (mmMakeMultipartMap *LogProcessorMock) MakeMultipartMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeMultipartMap.afterMakeMultipartMapCounter)
}

// MakeMultipartMapBeforeCounter returns a count of LogProcessorMock.MakeMultipartMap invocations
func (mmMakeMultipartMap *LogProcessorMock) MakeMultipartMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeMultipartMap.beforeMakeMultipartMapCounter)
}

// Calls returns a list of arguments used in each call to LogProcessorMock.MakeMultipartMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMakeMultipartMap *mLogProcessorMockMakeMultipartMap) Calls() []*LogProcessorMockMakeMultipartMapParams {
	mmMakeMultipartMap.mutex.RLock()

	argCopy := make([]*LogProcessorMockMakeMultipartMapParams, len(mmMakeMultipartMap.callArgs))
	copy(argCopy, mmMakeMultipartMap.callArgs)

	mmMakeMultipartMap.mutex.RUnlock()

	return argCopy
}

// MinimockMakeMultipartMapDone returns true if the count of the MakeMultipartMap invocations corresponds
// the number of defined expectations
func (m *LogProcessorMock) MinimockMakeMultipartMapDone() bool {
	for _, e := range m.MakeMultipartMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeMultipartMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeMultipartMap != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockMakeMultipartMapInspect logs each unmet expectation
func (m *LogProcessorMock) MinimockMakeMultipartMapInspect() {
	for _, e := range m.MakeMultipartMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogProcessorMock.MakeMultipartMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeMultipartMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		if m.MakeMultipartMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogProcessorMock.MakeMultipartMap")
		} else {
			m.t.Errorf("Expected call to LogProcessorMock.MakeMultipartMap with params: %#v", *m.MakeMultipartMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeMultipartMap != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		m.t.Error("Expected call to LogProcessorMock.MakeMultipartMap")
	}
}

type mLogProcessorMockResolvePlayers struct {
	mock               *LogProcessorMock
	defaultExpectation *LogProcessorMockResolvePlayersExpectation
	expectations       []*LogProcessorMockResolvePlayersExpectation

	callArgs []*LogProcessorMockResolvePlayersParams
	mutex    sync.RWMutex
}

// LogProcessorMockResolvePlayersExpectation specifies expectation struct of the LogUploader.ResolvePlayers
type LogProcessorMockResolvePlayersExpectation struct {
	mock    *LogProcessorMock
	params  *LogProcessorMockResolvePlayersParams
	results *LogProcessorMockResolvePlayersResults
	Counter uint64
}

// LogProcessorMockResolvePlayersParams contains parameters of the LogUploader.ResolvePlayers
type LogProcessorMockResolvePlayersParams struct {
	domain  string
	players []*stats.PickupPlayer
}

// LogProcessorMockResolvePlayersResults contains results of the LogUploader.ResolvePlayers
type LogProcessorMockResolvePlayersResults struct {
	err error
}

// Expect sets up expected params for LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogProcessorMockResolvePlayers) Expect(domain string, players []*stats.PickupPlayer) *mLogProcessorMockResolvePlayers {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogProcessorMock.ResolvePlayers mock is already set by Set")
	}

	if mmResolvePlayers.defaultExpectation == nil {
		mmResolvePlayers.defaultExpectation = &LogProcessorMockResolvePlayersExpectation{}
	}

	mmResolvePlayers.defaultExpectation.params = &LogProcessorMockResolvePlayersParams{domain, players}
	for _, e := range mmResolvePlayers.expectations {
		if minimock.Equal(e.params, mmResolvePlayers.defaultExpectation.params) {
			mmResolvePlayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResolvePlayers.defaultExpectation.params)
		}
	}

	return mmResolvePlayers
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogProcessorMockResolvePlayers) Inspect(f func(domain string, players []*stats.PickupPlayer)) *mLogProcessorMockResolvePlayers {
	if mmResolvePlayers.mock.inspectFuncResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("Inspect function is already set for LogProcessorMock.ResolvePlayers")
	}

	mmResolvePlayers.mock.inspectFuncResolvePlayers = f

	return mmResolvePlayers
}

// Return sets up results that will be returned by LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogProcessorMockResolvePlayers) Return(err error) *LogProcessorMock {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogProcessorMock.ResolvePlayers mock is already set by Set")
	}

	if mmResolvePlayers.defaultExpectation == nil {
		mmResolvePlayers.defaultExpectation = &LogProcessorMockResolvePlayersExpectation{mock: mmResolvePlayers.mock}
	}
	mmResolvePlayers.defaultExpectation.results = &LogProcessorMockResolvePlayersResults{err}
	return mmResolvePlayers.mock
}

//Set uses given function f to mock the LogUploader.ResolvePlayers method
func (mmResolvePlayers *mLogProcessorMockResolvePlayers) Set(f func(domain string, players []*stats.PickupPlayer) (err error)) *LogProcessorMock {
	if mmResolvePlayers.defaultExpectation != nil {
		mmResolvePlayers.mock.t.Fatalf("Default expectation is already set for the LogUploader.ResolvePlayers method")
	}

	if len(mmResolvePlayers.expectations) > 0 {
		mmResolvePlayers.mock.t.Fatalf("Some expectations are already set for the LogUploader.ResolvePlayers method")
	}

	mmResolvePlayers.mock.funcResolvePlayers = f
	return mmResolvePlayers.mock
}

// When sets expectation for the LogUploader.ResolvePlayers which will trigger the result defined by the following
// Then helper
func (mmResolvePlayers *mLogProcessorMockResolvePlayers) When(domain string, players []*stats.PickupPlayer) *LogProcessorMockResolvePlayersExpectation {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogProcessorMock.ResolvePlayers mock is already set by Set")
	}

	expectation := &LogProcessorMockResolvePlayersExpectation{
		mock:   mmResolvePlayers.mock,
		params: &LogProcessorMockResolvePlayersParams{domain, players},
	}
	mmResolvePlayers.expectations = append(mmResolvePlayers.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.ResolvePlayers return parameters for the expectation previously defined by the When method
func (e *LogProcessorMockResolvePlayersExpectation) Then(err error) *LogProcessorMock {
	e.results = &LogProcessorMockResolvePlayersResults{err}
	return e.mock
}

// ResolvePlayers implements requests.LogUploader
func (mmResolvePlayers *LogProcessorMock) ResolvePlayers(domain string, players []*stats.PickupPlayer) (err error) {
	mm_atomic.AddUint64(&mmResolvePlayers.beforeResolvePlayersCounter, 1)
	defer mm_atomic.AddUint64(&mmResolvePlayers.afterResolvePlayersCounter, 1)

	if mmResolvePlayers.inspectFuncResolvePlayers != nil {
		mmResolvePlayers.inspectFuncResolvePlayers(domain, players)
	}

	mm_params := &LogProcessorMockResolvePlayersParams{domain, players}

	// Record call args
	mmResolvePlayers.ResolvePlayersMock.mutex.Lock()
	mmResolvePlayers.ResolvePlayersMock.callArgs = append(mmResolvePlayers.ResolvePlayersMock.callArgs, mm_params)
	mmResolvePlayers.ResolvePlayersMock.mutex.Unlock()

	for _, e := range mmResolvePlayers.ResolvePlayersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmResolvePlayers.ResolvePlayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResolvePlayers.ResolvePlayersMock.defaultExpectation.Counter, 1)
		mm_want := mmResolvePlayers.ResolvePlayersMock.defaultExpectation.params
		mm_got := LogProcessorMockResolvePlayersParams{domain, players}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmResolvePlayers.t.Errorf("LogProcessorMock.ResolvePlayers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmResolvePlayers.ResolvePlayersMock.defaultExpectation.results
		if mm_results == nil {
			mmResolvePlayers.t.Fatal("No results are set for the LogProcessorMock.ResolvePlayers")
		}
		return (*mm_results).err
	}
	if mmResolvePlayers.funcResolvePlayers != nil {
		return mmResolvePlayers.funcResolvePlayers(domain, players)
	}
	mmResolvePlayers.t.Fatalf("Unexpected call to LogProcessorMock.ResolvePlayers. %v %v", domain, players)
	return
}

// ResolvePlayersAfterCounter returns a count of finished LogProcessorMock.ResolvePlayers invocations
func (mmResolvePlayers *LogProcessorMock) ResolvePlayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolvePlayers.afterResolvePlayersCounter)
}

// ResolvePlayersBeforeCounter returns a count of LogProcessorMock.ResolvePlayers invocations
func (mmResolvePlayers *LogProcessorMock) ResolvePlayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolvePlayers.beforeResolvePlayersCounter)
}

// Calls returns a list of arguments used in each call to LogProcessorMock.ResolvePlayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResolvePlayers *mLogProcessorMockResolvePlayers) Calls() []*LogProcessorMockResolvePlayersParams {
	mmResolvePlayers.mutex.RLock()

	argCopy := make([]*LogProcessorMockResolvePlayersParams, len(mmResolvePlayers.callArgs))
	copy(argCopy, mmResolvePlayers.callArgs)

	mmResolvePlayers.mutex.RUnlock()

	return argCopy
}

// MinimockResolvePlayersDone returns true if the count of the ResolvePlayers invocations corresponds
// the number of defined expectations
func (m *LogProcessorMock) MinimockResolvePlayersDone() bool {
	for _, e := range m.ResolvePlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolvePlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolvePlayers != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		return false
	}
	return true
}

// MinimockResolvePlayersInspect logs each unmet expectation
func (m *LogProcessorMock) MinimockResolvePlayersInspect() {
	for _, e := range m.ResolvePlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogProcessorMock.ResolvePlayers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolvePlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		if m.ResolvePlayersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogProcessorMock.ResolvePlayers")
		} else {
			m.t.Errorf("Expected call to LogProcessorMock.ResolvePlayers with params: %#v", *m.ResolvePlayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolvePlayers != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		m.t.Error("Expected call to LogProcessorMock.ResolvePlayers")
	}
}

type mLogProcessorMockUploadLogFile struct {
	mock               *LogProcessorMock
	defaultExpectation *LogProcessorMockUploadLogFileExpectation
	expectations       []*LogProcessorMockUploadLogFileExpectation

	callArgs []*LogProcessorMockUploadLogFileParams
	mutex    sync.RWMutex
}

// LogProcessorMockUploadLogFileExpectation specifies expectation struct of the LogUploader.UploadLogFile
type LogProcessorMockUploadLogFileExpectation struct {
	mock    *LogProcessorMock
	params  *LogProcessorMockUploadLogFileParams
	results *LogProcessorMockUploadLogFileResults
	Counter uint64
}

// LogProcessorMockUploadLogFileParams contains parameters of the LogUploader.UploadLogFile
type LogProcessorMockUploadLogFileParams struct {
	payload map[string]io.Reader
}

// LogProcessorMockUploadLogFileResults contains results of the LogUploader.UploadLogFile
type LogProcessorMockUploadLogFileResults struct {
	err error
}

// Expect sets up expected params for LogUploader.UploadLogFile
func (mmUploadLogFile *mLogProcessorMockUploadLogFile) Expect(payload map[string]io.Reader) *mLogProcessorMockUploadLogFile {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogProcessorMock.UploadLogFile mock is already set by Set")
	}

	if mmUploadLogFile.defaultExpectation == nil {
		mmUploadLogFile.defaultExpectation = &LogProcessorMockUploadLogFileExpectation{}
	}

	mmUploadLogFile.defaultExpectation.params = &LogProcessorMockUploadLogFileParams{payload}
	for _, e := range mmUploadLogFile.expectations {
		if minimock.Equal(e.params, mmUploadLogFile.defaultExpectation.params) {
			mmUploadLogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadLogFile.defaultExpectation.params)
		}
	}

	return mmUploadLogFile
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.UploadLogFile
func (mmUploadLogFile *mLogProcessorMockUploadLogFile) Inspect(f func(payload map[string]io.Reader)) *mLogProcessorMockUploadLogFile {
	if mmUploadLogFile.mock.inspectFuncUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("Inspect function is already set for LogProcessorMock.UploadLogFile")
	}

	mmUploadLogFile.mock.inspectFuncUploadLogFile = f

	return mmUploadLogFile
}

// Return sets up results that will be returned by LogUploader.UploadLogFile
func (mmUploadLogFile *mLogProcessorMockUploadLogFile) Return(err error) *LogProcessorMock {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogProcessorMock.UploadLogFile mock is already set by Set")
	}

	if mmUploadLogFile.defaultExpectation == nil {
		mmUploadLogFile.defaultExpectation = &LogProcessorMockUploadLogFileExpectation{mock: mmUploadLogFile.mock}
	}
	mmUploadLogFile.defaultExpectation.results = &LogProcessorMockUploadLogFileResults{err}
	return mmUploadLogFile.mock
}

//Set uses given function f to mock the LogUploader.UploadLogFile method
func (mmUploadLogFile *mLogProcessorMockUploadLogFile) Set(f func(payload map[string]io.Reader) (err error)) *LogProcessorMock {
	if mmUploadLogFile.defaultExpectation != nil {
		mmUploadLogFile.mock.t.Fatalf("Default expectation is already set for the LogUploader.UploadLogFile method")
	}

	if len(mmUploadLogFile.expectations) > 0 {
		mmUploadLogFile.mock.t.Fatalf("Some expectations are already set for the LogUploader.UploadLogFile method")
	}

	mmUploadLogFile.mock.funcUploadLogFile = f
	return mmUploadLogFile.mock
}

// When sets expectation for the LogUploader.UploadLogFile which will trigger the result defined by the following
// Then helper
func (mmUploadLogFile *mLogProcessorMockUploadLogFile) When(payload map[string]io.Reader) *LogProcessorMockUploadLogFileExpectation {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogProcessorMock.UploadLogFile mock is already set by Set")
	}

	expectation := &LogProcessorMockUploadLogFileExpectation{
		mock:   mmUploadLogFile.mock,
		params: &LogProcessorMockUploadLogFileParams{payload},
	}
	mmUploadLogFile.expectations = append(mmUploadLogFile.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.UploadLogFile return parameters for the expectation previously defined by the When method
func (e *LogProcessorMockUploadLogFileExpectation) Then(err error) *LogProcessorMock {
	e.results = &LogProcessorMockUploadLogFileResults{err}
	return e.mock
}

// UploadLogFile implements requests.LogUploader
func (mmUploadLogFile *LogProcessorMock) UploadLogFile(payload map[string]io.Reader) (err error) {
	mm_atomic.AddUint64(&mmUploadLogFile.beforeUploadLogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadLogFile.afterUploadLogFileCounter, 1)

	if mmUploadLogFile.inspectFuncUploadLogFile != nil {
		mmUploadLogFile.inspectFuncUploadLogFile(payload)
	}

	mm_params := &LogProcessorMockUploadLogFileParams{payload}

	// Record call args
	mmUploadLogFile.UploadLogFileMock.mutex.Lock()
	mmUploadLogFile.UploadLogFileMock.callArgs = append(mmUploadLogFile.UploadLogFileMock.callArgs, mm_params)
	mmUploadLogFile.UploadLogFileMock.mutex.Unlock()

	for _, e := range mmUploadLogFile.UploadLogFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadLogFile.UploadLogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadLogFile.UploadLogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadLogFile.UploadLogFileMock.defaultExpectation.params
		mm_got := LogProcessorMockUploadLogFileParams{payload}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadLogFile.t.Errorf("LogProcessorMock.UploadLogFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadLogFile.UploadLogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadLogFile.t.Fatal("No results are set for the LogProcessorMock.UploadLogFile")
		}
		return (*mm_results).err
	}
	if mmUploadLogFile.funcUploadLogFile != nil {
		return mmUploadLogFile.funcUploadLogFile(payload)
	}
	mmUploadLogFile.t.Fatalf("Unexpected call to LogProcessorMock.UploadLogFile. %v", payload)
	return
}

// UploadLogFileAfterCounter returns a count of finished LogProcessorMock.UploadLogFile invocations
func (mmUploadLogFile *LogProcessorMock) UploadLogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadLogFile.afterUploadLogFileCounter)
}

// UploadLogFileBeforeCounter returns a count of LogProcessorMock.UploadLogFile invocations
func (mmUploadLogFile *LogProcessorMock) UploadLogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadLogFile.beforeUploadLogFileCounter)
}

// Calls returns a list of arguments used in each call to LogProcessorMock.UploadLogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadLogFile *mLogProcessorMockUploadLogFile) Calls() []*LogProcessorMockUploadLogFileParams {
	mmUploadLogFile.mutex.RLock()

	argCopy := make([]*LogProcessorMockUploadLogFileParams, len(mmUploadLogFile.callArgs))
	copy(argCopy, mmUploadLogFile.callArgs)

	mmUploadLogFile.mutex.RUnlock()

	return argCopy
}

// MinimockUploadLogFileDone returns true if the count of the UploadLogFile invocations corresponds
// the number of defined expectations
func (m *LogProcessorMock) MinimockUploadLogFileDone() bool {
	for _, e := range m.UploadLogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UploadLogFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadLogFile != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockUploadLogFileInspect logs each unmet expectation
func (m *LogProcessorMock) MinimockUploadLogFileInspect() {
	for _, e := range m.UploadLogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogProcessorMock.UploadLogFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UploadLogFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		if m.UploadLogFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogProcessorMock.UploadLogFile")
		} else {
			m.t.Errorf("Expected call to LogProcessorMock.UploadLogFile with params: %#v", *m.UploadLogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadLogFile != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		m.t.Error("Expected call to LogProcessorMock.UploadLogFile")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LogProcessorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetPickupGamesInspect()

		m.MinimockMakeMultipartMapInspect()

		m.MinimockResolvePlayersInspect()

		m.MinimockUploadLogFileInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LogProcessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LogProcessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetPickupGamesDone() &&
		m.MinimockMakeMultipartMapDone() &&
		m.MinimockResolvePlayersDone() &&
		m.MinimockUploadLogFileDone()
}
