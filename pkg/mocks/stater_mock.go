package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/stateMachine.Stater -o ./pkg/mocks/stater_mock.go

import (
	"LogWatcher/pkg/mongo"
	"LogWatcher/pkg/requests"
	"LogWatcher/pkg/server"
	mm_stateMachine "LogWatcher/pkg/stateMachine"
	"LogWatcher/pkg/stats"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StaterMock implements stateMachine.Stater
type StaterMock struct {
	t minimock.Tester

	funcChannel          func() (ch1 chan string)
	inspectFuncChannel   func()
	afterChannelCounter  uint64
	beforeChannelCounter uint64
	ChannelMock          mStaterMockChannel

	funcFile          func() (l1 server.LogFiler)
	inspectFuncFile   func()
	afterFileCounter  uint64
	beforeFileCounter uint64
	FileMock          mStaterMockFile

	funcInserter          func() (i1 mongo.Inserter)
	inspectFuncInserter   func()
	afterInserterCounter  uint64
	beforeInserterCounter uint64
	InserterMock          mStaterMockInserter

	funcMatch          func() (m1 stats.Matcher)
	inspectFuncMatch   func()
	afterMatchCounter  uint64
	beforeMatchCounter uint64
	MatchMock          mStaterMockMatch

	funcProcessGameLogLine          func(msg string)
	inspectFuncProcessGameLogLine   func(msg string)
	afterProcessGameLogLineCounter  uint64
	beforeProcessGameLogLineCounter uint64
	ProcessGameLogLineMock          mStaterMockProcessGameLogLine

	funcProcessGameOverEvent          func(msg string)
	inspectFuncProcessGameOverEvent   func(msg string)
	afterProcessGameOverEventCounter  uint64
	beforeProcessGameOverEventCounter uint64
	ProcessGameOverEventMock          mStaterMockProcessGameOverEvent

	funcProcessGameStartedEvent          func(msg string)
	inspectFuncProcessGameStartedEvent   func(msg string)
	afterProcessGameStartedEventCounter  uint64
	beforeProcessGameStartedEventCounter uint64
	ProcessGameStartedEventMock          mStaterMockProcessGameStartedEvent

	funcProcessLogLine          func(msg string)
	inspectFuncProcessLogLine   func(msg string)
	afterProcessLogLineCounter  uint64
	beforeProcessLogLineCounter uint64
	ProcessLogLineMock          mStaterMockProcessLogLine

	funcSetState          func(state mm_stateMachine.StateType)
	inspectFuncSetState   func(state mm_stateMachine.StateType)
	afterSetStateCounter  uint64
	beforeSetStateCounter uint64
	SetStateMock          mStaterMockSetState

	funcStartWorker          func()
	inspectFuncStartWorker   func()
	afterStartWorkerCounter  uint64
	beforeStartWorkerCounter uint64
	StartWorkerMock          mStaterMockStartWorker

	funcState          func() (s1 mm_stateMachine.StateType)
	inspectFuncState   func()
	afterStateCounter  uint64
	beforeStateCounter uint64
	StateMock          mStaterMockState

	funcUpdatePickupInfo          func() (err error)
	inspectFuncUpdatePickupInfo   func()
	afterUpdatePickupInfoCounter  uint64
	beforeUpdatePickupInfoCounter uint64
	UpdatePickupInfoMock          mStaterMockUpdatePickupInfo

	funcUploader          func() (l1 requests.LogUploader)
	inspectFuncUploader   func()
	afterUploaderCounter  uint64
	beforeUploaderCounter uint64
	UploaderMock          mStaterMockUploader
}

// NewStaterMock returns a mock for stateMachine.Stater
func NewStaterMock(t minimock.Tester) *StaterMock {
	m := &StaterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChannelMock = mStaterMockChannel{mock: m}

	m.FileMock = mStaterMockFile{mock: m}

	m.InserterMock = mStaterMockInserter{mock: m}

	m.MatchMock = mStaterMockMatch{mock: m}

	m.ProcessGameLogLineMock = mStaterMockProcessGameLogLine{mock: m}
	m.ProcessGameLogLineMock.callArgs = []*StaterMockProcessGameLogLineParams{}

	m.ProcessGameOverEventMock = mStaterMockProcessGameOverEvent{mock: m}
	m.ProcessGameOverEventMock.callArgs = []*StaterMockProcessGameOverEventParams{}

	m.ProcessGameStartedEventMock = mStaterMockProcessGameStartedEvent{mock: m}
	m.ProcessGameStartedEventMock.callArgs = []*StaterMockProcessGameStartedEventParams{}

	m.ProcessLogLineMock = mStaterMockProcessLogLine{mock: m}
	m.ProcessLogLineMock.callArgs = []*StaterMockProcessLogLineParams{}

	m.SetStateMock = mStaterMockSetState{mock: m}
	m.SetStateMock.callArgs = []*StaterMockSetStateParams{}

	m.StartWorkerMock = mStaterMockStartWorker{mock: m}

	m.StateMock = mStaterMockState{mock: m}

	m.UpdatePickupInfoMock = mStaterMockUpdatePickupInfo{mock: m}

	m.UploaderMock = mStaterMockUploader{mock: m}

	return m
}

type mStaterMockChannel struct {
	mock               *StaterMock
	defaultExpectation *StaterMockChannelExpectation
	expectations       []*StaterMockChannelExpectation
}

// StaterMockChannelExpectation specifies expectation struct of the Stater.Channel
type StaterMockChannelExpectation struct {
	mock *StaterMock

	results *StaterMockChannelResults
	Counter uint64
}

// StaterMockChannelResults contains results of the Stater.Channel
type StaterMockChannelResults struct {
	ch1 chan string
}

// Expect sets up expected params for Stater.Channel
func (mmChannel *mStaterMockChannel) Expect() *mStaterMockChannel {
	if mmChannel.mock.funcChannel != nil {
		mmChannel.mock.t.Fatalf("StaterMock.Channel mock is already set by Set")
	}

	if mmChannel.defaultExpectation == nil {
		mmChannel.defaultExpectation = &StaterMockChannelExpectation{}
	}

	return mmChannel
}

// Inspect accepts an inspector function that has same arguments as the Stater.Channel
func (mmChannel *mStaterMockChannel) Inspect(f func()) *mStaterMockChannel {
	if mmChannel.mock.inspectFuncChannel != nil {
		mmChannel.mock.t.Fatalf("Inspect function is already set for StaterMock.Channel")
	}

	mmChannel.mock.inspectFuncChannel = f

	return mmChannel
}

// Return sets up results that will be returned by Stater.Channel
func (mmChannel *mStaterMockChannel) Return(ch1 chan string) *StaterMock {
	if mmChannel.mock.funcChannel != nil {
		mmChannel.mock.t.Fatalf("StaterMock.Channel mock is already set by Set")
	}

	if mmChannel.defaultExpectation == nil {
		mmChannel.defaultExpectation = &StaterMockChannelExpectation{mock: mmChannel.mock}
	}
	mmChannel.defaultExpectation.results = &StaterMockChannelResults{ch1}
	return mmChannel.mock
}

//Set uses given function f to mock the Stater.Channel method
func (mmChannel *mStaterMockChannel) Set(f func() (ch1 chan string)) *StaterMock {
	if mmChannel.defaultExpectation != nil {
		mmChannel.mock.t.Fatalf("Default expectation is already set for the Stater.Channel method")
	}

	if len(mmChannel.expectations) > 0 {
		mmChannel.mock.t.Fatalf("Some expectations are already set for the Stater.Channel method")
	}

	mmChannel.mock.funcChannel = f
	return mmChannel.mock
}

// Channel implements stateMachine.Stater
func (mmChannel *StaterMock) Channel() (ch1 chan string) {
	mm_atomic.AddUint64(&mmChannel.beforeChannelCounter, 1)
	defer mm_atomic.AddUint64(&mmChannel.afterChannelCounter, 1)

	if mmChannel.inspectFuncChannel != nil {
		mmChannel.inspectFuncChannel()
	}

	if mmChannel.ChannelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChannel.ChannelMock.defaultExpectation.Counter, 1)

		mm_results := mmChannel.ChannelMock.defaultExpectation.results
		if mm_results == nil {
			mmChannel.t.Fatal("No results are set for the StaterMock.Channel")
		}
		return (*mm_results).ch1
	}
	if mmChannel.funcChannel != nil {
		return mmChannel.funcChannel()
	}
	mmChannel.t.Fatalf("Unexpected call to StaterMock.Channel.")
	return
}

// ChannelAfterCounter returns a count of finished StaterMock.Channel invocations
func (mmChannel *StaterMock) ChannelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChannel.afterChannelCounter)
}

// ChannelBeforeCounter returns a count of StaterMock.Channel invocations
func (mmChannel *StaterMock) ChannelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChannel.beforeChannelCounter)
}

// MinimockChannelDone returns true if the count of the Channel invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockChannelDone() bool {
	for _, e := range m.ChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChannelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChannel != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		return false
	}
	return true
}

// MinimockChannelInspect logs each unmet expectation
func (m *StaterMock) MinimockChannelInspect() {
	for _, e := range m.ChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StaterMock.Channel")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChannelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		m.t.Error("Expected call to StaterMock.Channel")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChannel != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		m.t.Error("Expected call to StaterMock.Channel")
	}
}

type mStaterMockFile struct {
	mock               *StaterMock
	defaultExpectation *StaterMockFileExpectation
	expectations       []*StaterMockFileExpectation
}

// StaterMockFileExpectation specifies expectation struct of the Stater.File
type StaterMockFileExpectation struct {
	mock *StaterMock

	results *StaterMockFileResults
	Counter uint64
}

// StaterMockFileResults contains results of the Stater.File
type StaterMockFileResults struct {
	l1 server.LogFiler
}

// Expect sets up expected params for Stater.File
func (mmFile *mStaterMockFile) Expect() *mStaterMockFile {
	if mmFile.mock.funcFile != nil {
		mmFile.mock.t.Fatalf("StaterMock.File mock is already set by Set")
	}

	if mmFile.defaultExpectation == nil {
		mmFile.defaultExpectation = &StaterMockFileExpectation{}
	}

	return mmFile
}

// Inspect accepts an inspector function that has same arguments as the Stater.File
func (mmFile *mStaterMockFile) Inspect(f func()) *mStaterMockFile {
	if mmFile.mock.inspectFuncFile != nil {
		mmFile.mock.t.Fatalf("Inspect function is already set for StaterMock.File")
	}

	mmFile.mock.inspectFuncFile = f

	return mmFile
}

// Return sets up results that will be returned by Stater.File
func (mmFile *mStaterMockFile) Return(l1 server.LogFiler) *StaterMock {
	if mmFile.mock.funcFile != nil {
		mmFile.mock.t.Fatalf("StaterMock.File mock is already set by Set")
	}

	if mmFile.defaultExpectation == nil {
		mmFile.defaultExpectation = &StaterMockFileExpectation{mock: mmFile.mock}
	}
	mmFile.defaultExpectation.results = &StaterMockFileResults{l1}
	return mmFile.mock
}

//Set uses given function f to mock the Stater.File method
func (mmFile *mStaterMockFile) Set(f func() (l1 server.LogFiler)) *StaterMock {
	if mmFile.defaultExpectation != nil {
		mmFile.mock.t.Fatalf("Default expectation is already set for the Stater.File method")
	}

	if len(mmFile.expectations) > 0 {
		mmFile.mock.t.Fatalf("Some expectations are already set for the Stater.File method")
	}

	mmFile.mock.funcFile = f
	return mmFile.mock
}

// File implements stateMachine.Stater
func (mmFile *StaterMock) File() (l1 server.LogFiler) {
	mm_atomic.AddUint64(&mmFile.beforeFileCounter, 1)
	defer mm_atomic.AddUint64(&mmFile.afterFileCounter, 1)

	if mmFile.inspectFuncFile != nil {
		mmFile.inspectFuncFile()
	}

	if mmFile.FileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFile.FileMock.defaultExpectation.Counter, 1)

		mm_results := mmFile.FileMock.defaultExpectation.results
		if mm_results == nil {
			mmFile.t.Fatal("No results are set for the StaterMock.File")
		}
		return (*mm_results).l1
	}
	if mmFile.funcFile != nil {
		return mmFile.funcFile()
	}
	mmFile.t.Fatalf("Unexpected call to StaterMock.File.")
	return
}

// FileAfterCounter returns a count of finished StaterMock.File invocations
func (mmFile *StaterMock) FileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFile.afterFileCounter)
}

// FileBeforeCounter returns a count of StaterMock.File invocations
func (mmFile *StaterMock) FileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFile.beforeFileCounter)
}

// MinimockFileDone returns true if the count of the File invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockFileDone() bool {
	for _, e := range m.FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFile != nil && mm_atomic.LoadUint64(&m.afterFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockFileInspect logs each unmet expectation
func (m *StaterMock) MinimockFileInspect() {
	for _, e := range m.FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StaterMock.File")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFileCounter) < 1 {
		m.t.Error("Expected call to StaterMock.File")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFile != nil && mm_atomic.LoadUint64(&m.afterFileCounter) < 1 {
		m.t.Error("Expected call to StaterMock.File")
	}
}

type mStaterMockInserter struct {
	mock               *StaterMock
	defaultExpectation *StaterMockInserterExpectation
	expectations       []*StaterMockInserterExpectation
}

// StaterMockInserterExpectation specifies expectation struct of the Stater.Inserter
type StaterMockInserterExpectation struct {
	mock *StaterMock

	results *StaterMockInserterResults
	Counter uint64
}

// StaterMockInserterResults contains results of the Stater.Inserter
type StaterMockInserterResults struct {
	i1 mongo.Inserter
}

// Expect sets up expected params for Stater.Inserter
func (mmInserter *mStaterMockInserter) Expect() *mStaterMockInserter {
	if mmInserter.mock.funcInserter != nil {
		mmInserter.mock.t.Fatalf("StaterMock.Inserter mock is already set by Set")
	}

	if mmInserter.defaultExpectation == nil {
		mmInserter.defaultExpectation = &StaterMockInserterExpectation{}
	}

	return mmInserter
}

// Inspect accepts an inspector function that has same arguments as the Stater.Inserter
func (mmInserter *mStaterMockInserter) Inspect(f func()) *mStaterMockInserter {
	if mmInserter.mock.inspectFuncInserter != nil {
		mmInserter.mock.t.Fatalf("Inspect function is already set for StaterMock.Inserter")
	}

	mmInserter.mock.inspectFuncInserter = f

	return mmInserter
}

// Return sets up results that will be returned by Stater.Inserter
func (mmInserter *mStaterMockInserter) Return(i1 mongo.Inserter) *StaterMock {
	if mmInserter.mock.funcInserter != nil {
		mmInserter.mock.t.Fatalf("StaterMock.Inserter mock is already set by Set")
	}

	if mmInserter.defaultExpectation == nil {
		mmInserter.defaultExpectation = &StaterMockInserterExpectation{mock: mmInserter.mock}
	}
	mmInserter.defaultExpectation.results = &StaterMockInserterResults{i1}
	return mmInserter.mock
}

//Set uses given function f to mock the Stater.Inserter method
func (mmInserter *mStaterMockInserter) Set(f func() (i1 mongo.Inserter)) *StaterMock {
	if mmInserter.defaultExpectation != nil {
		mmInserter.mock.t.Fatalf("Default expectation is already set for the Stater.Inserter method")
	}

	if len(mmInserter.expectations) > 0 {
		mmInserter.mock.t.Fatalf("Some expectations are already set for the Stater.Inserter method")
	}

	mmInserter.mock.funcInserter = f
	return mmInserter.mock
}

// Inserter implements stateMachine.Stater
func (mmInserter *StaterMock) Inserter() (i1 mongo.Inserter) {
	mm_atomic.AddUint64(&mmInserter.beforeInserterCounter, 1)
	defer mm_atomic.AddUint64(&mmInserter.afterInserterCounter, 1)

	if mmInserter.inspectFuncInserter != nil {
		mmInserter.inspectFuncInserter()
	}

	if mmInserter.InserterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInserter.InserterMock.defaultExpectation.Counter, 1)

		mm_results := mmInserter.InserterMock.defaultExpectation.results
		if mm_results == nil {
			mmInserter.t.Fatal("No results are set for the StaterMock.Inserter")
		}
		return (*mm_results).i1
	}
	if mmInserter.funcInserter != nil {
		return mmInserter.funcInserter()
	}
	mmInserter.t.Fatalf("Unexpected call to StaterMock.Inserter.")
	return
}

// InserterAfterCounter returns a count of finished StaterMock.Inserter invocations
func (mmInserter *StaterMock) InserterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInserter.afterInserterCounter)
}

// InserterBeforeCounter returns a count of StaterMock.Inserter invocations
func (mmInserter *StaterMock) InserterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInserter.beforeInserterCounter)
}

// MinimockInserterDone returns true if the count of the Inserter invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockInserterDone() bool {
	for _, e := range m.InserterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InserterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInserterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInserter != nil && mm_atomic.LoadUint64(&m.afterInserterCounter) < 1 {
		return false
	}
	return true
}

// MinimockInserterInspect logs each unmet expectation
func (m *StaterMock) MinimockInserterInspect() {
	for _, e := range m.InserterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StaterMock.Inserter")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InserterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInserterCounter) < 1 {
		m.t.Error("Expected call to StaterMock.Inserter")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInserter != nil && mm_atomic.LoadUint64(&m.afterInserterCounter) < 1 {
		m.t.Error("Expected call to StaterMock.Inserter")
	}
}

type mStaterMockMatch struct {
	mock               *StaterMock
	defaultExpectation *StaterMockMatchExpectation
	expectations       []*StaterMockMatchExpectation
}

// StaterMockMatchExpectation specifies expectation struct of the Stater.Match
type StaterMockMatchExpectation struct {
	mock *StaterMock

	results *StaterMockMatchResults
	Counter uint64
}

// StaterMockMatchResults contains results of the Stater.Match
type StaterMockMatchResults struct {
	m1 stats.Matcher
}

// Expect sets up expected params for Stater.Match
func (mmMatch *mStaterMockMatch) Expect() *mStaterMockMatch {
	if mmMatch.mock.funcMatch != nil {
		mmMatch.mock.t.Fatalf("StaterMock.Match mock is already set by Set")
	}

	if mmMatch.defaultExpectation == nil {
		mmMatch.defaultExpectation = &StaterMockMatchExpectation{}
	}

	return mmMatch
}

// Inspect accepts an inspector function that has same arguments as the Stater.Match
func (mmMatch *mStaterMockMatch) Inspect(f func()) *mStaterMockMatch {
	if mmMatch.mock.inspectFuncMatch != nil {
		mmMatch.mock.t.Fatalf("Inspect function is already set for StaterMock.Match")
	}

	mmMatch.mock.inspectFuncMatch = f

	return mmMatch
}

// Return sets up results that will be returned by Stater.Match
func (mmMatch *mStaterMockMatch) Return(m1 stats.Matcher) *StaterMock {
	if mmMatch.mock.funcMatch != nil {
		mmMatch.mock.t.Fatalf("StaterMock.Match mock is already set by Set")
	}

	if mmMatch.defaultExpectation == nil {
		mmMatch.defaultExpectation = &StaterMockMatchExpectation{mock: mmMatch.mock}
	}
	mmMatch.defaultExpectation.results = &StaterMockMatchResults{m1}
	return mmMatch.mock
}

//Set uses given function f to mock the Stater.Match method
func (mmMatch *mStaterMockMatch) Set(f func() (m1 stats.Matcher)) *StaterMock {
	if mmMatch.defaultExpectation != nil {
		mmMatch.mock.t.Fatalf("Default expectation is already set for the Stater.Match method")
	}

	if len(mmMatch.expectations) > 0 {
		mmMatch.mock.t.Fatalf("Some expectations are already set for the Stater.Match method")
	}

	mmMatch.mock.funcMatch = f
	return mmMatch.mock
}

// Match implements stateMachine.Stater
func (mmMatch *StaterMock) Match() (m1 stats.Matcher) {
	mm_atomic.AddUint64(&mmMatch.beforeMatchCounter, 1)
	defer mm_atomic.AddUint64(&mmMatch.afterMatchCounter, 1)

	if mmMatch.inspectFuncMatch != nil {
		mmMatch.inspectFuncMatch()
	}

	if mmMatch.MatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMatch.MatchMock.defaultExpectation.Counter, 1)

		mm_results := mmMatch.MatchMock.defaultExpectation.results
		if mm_results == nil {
			mmMatch.t.Fatal("No results are set for the StaterMock.Match")
		}
		return (*mm_results).m1
	}
	if mmMatch.funcMatch != nil {
		return mmMatch.funcMatch()
	}
	mmMatch.t.Fatalf("Unexpected call to StaterMock.Match.")
	return
}

// MatchAfterCounter returns a count of finished StaterMock.Match invocations
func (mmMatch *StaterMock) MatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMatch.afterMatchCounter)
}

// MatchBeforeCounter returns a count of StaterMock.Match invocations
func (mmMatch *StaterMock) MatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMatch.beforeMatchCounter)
}

// MinimockMatchDone returns true if the count of the Match invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockMatchDone() bool {
	for _, e := range m.MatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMatch != nil && mm_atomic.LoadUint64(&m.afterMatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockMatchInspect logs each unmet expectation
func (m *StaterMock) MinimockMatchInspect() {
	for _, e := range m.MatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StaterMock.Match")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMatchCounter) < 1 {
		m.t.Error("Expected call to StaterMock.Match")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMatch != nil && mm_atomic.LoadUint64(&m.afterMatchCounter) < 1 {
		m.t.Error("Expected call to StaterMock.Match")
	}
}

type mStaterMockProcessGameLogLine struct {
	mock               *StaterMock
	defaultExpectation *StaterMockProcessGameLogLineExpectation
	expectations       []*StaterMockProcessGameLogLineExpectation

	callArgs []*StaterMockProcessGameLogLineParams
	mutex    sync.RWMutex
}

// StaterMockProcessGameLogLineExpectation specifies expectation struct of the Stater.ProcessGameLogLine
type StaterMockProcessGameLogLineExpectation struct {
	mock   *StaterMock
	params *StaterMockProcessGameLogLineParams

	Counter uint64
}

// StaterMockProcessGameLogLineParams contains parameters of the Stater.ProcessGameLogLine
type StaterMockProcessGameLogLineParams struct {
	msg string
}

// Expect sets up expected params for Stater.ProcessGameLogLine
func (mmProcessGameLogLine *mStaterMockProcessGameLogLine) Expect(msg string) *mStaterMockProcessGameLogLine {
	if mmProcessGameLogLine.mock.funcProcessGameLogLine != nil {
		mmProcessGameLogLine.mock.t.Fatalf("StaterMock.ProcessGameLogLine mock is already set by Set")
	}

	if mmProcessGameLogLine.defaultExpectation == nil {
		mmProcessGameLogLine.defaultExpectation = &StaterMockProcessGameLogLineExpectation{}
	}

	mmProcessGameLogLine.defaultExpectation.params = &StaterMockProcessGameLogLineParams{msg}
	for _, e := range mmProcessGameLogLine.expectations {
		if minimock.Equal(e.params, mmProcessGameLogLine.defaultExpectation.params) {
			mmProcessGameLogLine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessGameLogLine.defaultExpectation.params)
		}
	}

	return mmProcessGameLogLine
}

// Inspect accepts an inspector function that has same arguments as the Stater.ProcessGameLogLine
func (mmProcessGameLogLine *mStaterMockProcessGameLogLine) Inspect(f func(msg string)) *mStaterMockProcessGameLogLine {
	if mmProcessGameLogLine.mock.inspectFuncProcessGameLogLine != nil {
		mmProcessGameLogLine.mock.t.Fatalf("Inspect function is already set for StaterMock.ProcessGameLogLine")
	}

	mmProcessGameLogLine.mock.inspectFuncProcessGameLogLine = f

	return mmProcessGameLogLine
}

// Return sets up results that will be returned by Stater.ProcessGameLogLine
func (mmProcessGameLogLine *mStaterMockProcessGameLogLine) Return() *StaterMock {
	if mmProcessGameLogLine.mock.funcProcessGameLogLine != nil {
		mmProcessGameLogLine.mock.t.Fatalf("StaterMock.ProcessGameLogLine mock is already set by Set")
	}

	if mmProcessGameLogLine.defaultExpectation == nil {
		mmProcessGameLogLine.defaultExpectation = &StaterMockProcessGameLogLineExpectation{mock: mmProcessGameLogLine.mock}
	}

	return mmProcessGameLogLine.mock
}

//Set uses given function f to mock the Stater.ProcessGameLogLine method
func (mmProcessGameLogLine *mStaterMockProcessGameLogLine) Set(f func(msg string)) *StaterMock {
	if mmProcessGameLogLine.defaultExpectation != nil {
		mmProcessGameLogLine.mock.t.Fatalf("Default expectation is already set for the Stater.ProcessGameLogLine method")
	}

	if len(mmProcessGameLogLine.expectations) > 0 {
		mmProcessGameLogLine.mock.t.Fatalf("Some expectations are already set for the Stater.ProcessGameLogLine method")
	}

	mmProcessGameLogLine.mock.funcProcessGameLogLine = f
	return mmProcessGameLogLine.mock
}

// ProcessGameLogLine implements stateMachine.Stater
func (mmProcessGameLogLine *StaterMock) ProcessGameLogLine(msg string) {
	mm_atomic.AddUint64(&mmProcessGameLogLine.beforeProcessGameLogLineCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessGameLogLine.afterProcessGameLogLineCounter, 1)

	if mmProcessGameLogLine.inspectFuncProcessGameLogLine != nil {
		mmProcessGameLogLine.inspectFuncProcessGameLogLine(msg)
	}

	mm_params := &StaterMockProcessGameLogLineParams{msg}

	// Record call args
	mmProcessGameLogLine.ProcessGameLogLineMock.mutex.Lock()
	mmProcessGameLogLine.ProcessGameLogLineMock.callArgs = append(mmProcessGameLogLine.ProcessGameLogLineMock.callArgs, mm_params)
	mmProcessGameLogLine.ProcessGameLogLineMock.mutex.Unlock()

	for _, e := range mmProcessGameLogLine.ProcessGameLogLineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmProcessGameLogLine.ProcessGameLogLineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessGameLogLine.ProcessGameLogLineMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessGameLogLine.ProcessGameLogLineMock.defaultExpectation.params
		mm_got := StaterMockProcessGameLogLineParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessGameLogLine.t.Errorf("StaterMock.ProcessGameLogLine got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmProcessGameLogLine.funcProcessGameLogLine != nil {
		mmProcessGameLogLine.funcProcessGameLogLine(msg)
		return
	}
	mmProcessGameLogLine.t.Fatalf("Unexpected call to StaterMock.ProcessGameLogLine. %v", msg)

}

// ProcessGameLogLineAfterCounter returns a count of finished StaterMock.ProcessGameLogLine invocations
func (mmProcessGameLogLine *StaterMock) ProcessGameLogLineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessGameLogLine.afterProcessGameLogLineCounter)
}

// ProcessGameLogLineBeforeCounter returns a count of StaterMock.ProcessGameLogLine invocations
func (mmProcessGameLogLine *StaterMock) ProcessGameLogLineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessGameLogLine.beforeProcessGameLogLineCounter)
}

// Calls returns a list of arguments used in each call to StaterMock.ProcessGameLogLine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessGameLogLine *mStaterMockProcessGameLogLine) Calls() []*StaterMockProcessGameLogLineParams {
	mmProcessGameLogLine.mutex.RLock()

	argCopy := make([]*StaterMockProcessGameLogLineParams, len(mmProcessGameLogLine.callArgs))
	copy(argCopy, mmProcessGameLogLine.callArgs)

	mmProcessGameLogLine.mutex.RUnlock()

	return argCopy
}

// MinimockProcessGameLogLineDone returns true if the count of the ProcessGameLogLine invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockProcessGameLogLineDone() bool {
	for _, e := range m.ProcessGameLogLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessGameLogLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessGameLogLineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessGameLogLine != nil && mm_atomic.LoadUint64(&m.afterProcessGameLogLineCounter) < 1 {
		return false
	}
	return true
}

// MinimockProcessGameLogLineInspect logs each unmet expectation
func (m *StaterMock) MinimockProcessGameLogLineInspect() {
	for _, e := range m.ProcessGameLogLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StaterMock.ProcessGameLogLine with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessGameLogLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessGameLogLineCounter) < 1 {
		if m.ProcessGameLogLineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StaterMock.ProcessGameLogLine")
		} else {
			m.t.Errorf("Expected call to StaterMock.ProcessGameLogLine with params: %#v", *m.ProcessGameLogLineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessGameLogLine != nil && mm_atomic.LoadUint64(&m.afterProcessGameLogLineCounter) < 1 {
		m.t.Error("Expected call to StaterMock.ProcessGameLogLine")
	}
}

type mStaterMockProcessGameOverEvent struct {
	mock               *StaterMock
	defaultExpectation *StaterMockProcessGameOverEventExpectation
	expectations       []*StaterMockProcessGameOverEventExpectation

	callArgs []*StaterMockProcessGameOverEventParams
	mutex    sync.RWMutex
}

// StaterMockProcessGameOverEventExpectation specifies expectation struct of the Stater.ProcessGameOverEvent
type StaterMockProcessGameOverEventExpectation struct {
	mock   *StaterMock
	params *StaterMockProcessGameOverEventParams

	Counter uint64
}

// StaterMockProcessGameOverEventParams contains parameters of the Stater.ProcessGameOverEvent
type StaterMockProcessGameOverEventParams struct {
	msg string
}

// Expect sets up expected params for Stater.ProcessGameOverEvent
func (mmProcessGameOverEvent *mStaterMockProcessGameOverEvent) Expect(msg string) *mStaterMockProcessGameOverEvent {
	if mmProcessGameOverEvent.mock.funcProcessGameOverEvent != nil {
		mmProcessGameOverEvent.mock.t.Fatalf("StaterMock.ProcessGameOverEvent mock is already set by Set")
	}

	if mmProcessGameOverEvent.defaultExpectation == nil {
		mmProcessGameOverEvent.defaultExpectation = &StaterMockProcessGameOverEventExpectation{}
	}

	mmProcessGameOverEvent.defaultExpectation.params = &StaterMockProcessGameOverEventParams{msg}
	for _, e := range mmProcessGameOverEvent.expectations {
		if minimock.Equal(e.params, mmProcessGameOverEvent.defaultExpectation.params) {
			mmProcessGameOverEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessGameOverEvent.defaultExpectation.params)
		}
	}

	return mmProcessGameOverEvent
}

// Inspect accepts an inspector function that has same arguments as the Stater.ProcessGameOverEvent
func (mmProcessGameOverEvent *mStaterMockProcessGameOverEvent) Inspect(f func(msg string)) *mStaterMockProcessGameOverEvent {
	if mmProcessGameOverEvent.mock.inspectFuncProcessGameOverEvent != nil {
		mmProcessGameOverEvent.mock.t.Fatalf("Inspect function is already set for StaterMock.ProcessGameOverEvent")
	}

	mmProcessGameOverEvent.mock.inspectFuncProcessGameOverEvent = f

	return mmProcessGameOverEvent
}

// Return sets up results that will be returned by Stater.ProcessGameOverEvent
func (mmProcessGameOverEvent *mStaterMockProcessGameOverEvent) Return() *StaterMock {
	if mmProcessGameOverEvent.mock.funcProcessGameOverEvent != nil {
		mmProcessGameOverEvent.mock.t.Fatalf("StaterMock.ProcessGameOverEvent mock is already set by Set")
	}

	if mmProcessGameOverEvent.defaultExpectation == nil {
		mmProcessGameOverEvent.defaultExpectation = &StaterMockProcessGameOverEventExpectation{mock: mmProcessGameOverEvent.mock}
	}

	return mmProcessGameOverEvent.mock
}

//Set uses given function f to mock the Stater.ProcessGameOverEvent method
func (mmProcessGameOverEvent *mStaterMockProcessGameOverEvent) Set(f func(msg string)) *StaterMock {
	if mmProcessGameOverEvent.defaultExpectation != nil {
		mmProcessGameOverEvent.mock.t.Fatalf("Default expectation is already set for the Stater.ProcessGameOverEvent method")
	}

	if len(mmProcessGameOverEvent.expectations) > 0 {
		mmProcessGameOverEvent.mock.t.Fatalf("Some expectations are already set for the Stater.ProcessGameOverEvent method")
	}

	mmProcessGameOverEvent.mock.funcProcessGameOverEvent = f
	return mmProcessGameOverEvent.mock
}

// ProcessGameOverEvent implements stateMachine.Stater
func (mmProcessGameOverEvent *StaterMock) ProcessGameOverEvent(msg string) {
	mm_atomic.AddUint64(&mmProcessGameOverEvent.beforeProcessGameOverEventCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessGameOverEvent.afterProcessGameOverEventCounter, 1)

	if mmProcessGameOverEvent.inspectFuncProcessGameOverEvent != nil {
		mmProcessGameOverEvent.inspectFuncProcessGameOverEvent(msg)
	}

	mm_params := &StaterMockProcessGameOverEventParams{msg}

	// Record call args
	mmProcessGameOverEvent.ProcessGameOverEventMock.mutex.Lock()
	mmProcessGameOverEvent.ProcessGameOverEventMock.callArgs = append(mmProcessGameOverEvent.ProcessGameOverEventMock.callArgs, mm_params)
	mmProcessGameOverEvent.ProcessGameOverEventMock.mutex.Unlock()

	for _, e := range mmProcessGameOverEvent.ProcessGameOverEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmProcessGameOverEvent.ProcessGameOverEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessGameOverEvent.ProcessGameOverEventMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessGameOverEvent.ProcessGameOverEventMock.defaultExpectation.params
		mm_got := StaterMockProcessGameOverEventParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessGameOverEvent.t.Errorf("StaterMock.ProcessGameOverEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmProcessGameOverEvent.funcProcessGameOverEvent != nil {
		mmProcessGameOverEvent.funcProcessGameOverEvent(msg)
		return
	}
	mmProcessGameOverEvent.t.Fatalf("Unexpected call to StaterMock.ProcessGameOverEvent. %v", msg)

}

// ProcessGameOverEventAfterCounter returns a count of finished StaterMock.ProcessGameOverEvent invocations
func (mmProcessGameOverEvent *StaterMock) ProcessGameOverEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessGameOverEvent.afterProcessGameOverEventCounter)
}

// ProcessGameOverEventBeforeCounter returns a count of StaterMock.ProcessGameOverEvent invocations
func (mmProcessGameOverEvent *StaterMock) ProcessGameOverEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessGameOverEvent.beforeProcessGameOverEventCounter)
}

// Calls returns a list of arguments used in each call to StaterMock.ProcessGameOverEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessGameOverEvent *mStaterMockProcessGameOverEvent) Calls() []*StaterMockProcessGameOverEventParams {
	mmProcessGameOverEvent.mutex.RLock()

	argCopy := make([]*StaterMockProcessGameOverEventParams, len(mmProcessGameOverEvent.callArgs))
	copy(argCopy, mmProcessGameOverEvent.callArgs)

	mmProcessGameOverEvent.mutex.RUnlock()

	return argCopy
}

// MinimockProcessGameOverEventDone returns true if the count of the ProcessGameOverEvent invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockProcessGameOverEventDone() bool {
	for _, e := range m.ProcessGameOverEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessGameOverEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessGameOverEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessGameOverEvent != nil && mm_atomic.LoadUint64(&m.afterProcessGameOverEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockProcessGameOverEventInspect logs each unmet expectation
func (m *StaterMock) MinimockProcessGameOverEventInspect() {
	for _, e := range m.ProcessGameOverEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StaterMock.ProcessGameOverEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessGameOverEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessGameOverEventCounter) < 1 {
		if m.ProcessGameOverEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StaterMock.ProcessGameOverEvent")
		} else {
			m.t.Errorf("Expected call to StaterMock.ProcessGameOverEvent with params: %#v", *m.ProcessGameOverEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessGameOverEvent != nil && mm_atomic.LoadUint64(&m.afterProcessGameOverEventCounter) < 1 {
		m.t.Error("Expected call to StaterMock.ProcessGameOverEvent")
	}
}

type mStaterMockProcessGameStartedEvent struct {
	mock               *StaterMock
	defaultExpectation *StaterMockProcessGameStartedEventExpectation
	expectations       []*StaterMockProcessGameStartedEventExpectation

	callArgs []*StaterMockProcessGameStartedEventParams
	mutex    sync.RWMutex
}

// StaterMockProcessGameStartedEventExpectation specifies expectation struct of the Stater.ProcessGameStartedEvent
type StaterMockProcessGameStartedEventExpectation struct {
	mock   *StaterMock
	params *StaterMockProcessGameStartedEventParams

	Counter uint64
}

// StaterMockProcessGameStartedEventParams contains parameters of the Stater.ProcessGameStartedEvent
type StaterMockProcessGameStartedEventParams struct {
	msg string
}

// Expect sets up expected params for Stater.ProcessGameStartedEvent
func (mmProcessGameStartedEvent *mStaterMockProcessGameStartedEvent) Expect(msg string) *mStaterMockProcessGameStartedEvent {
	if mmProcessGameStartedEvent.mock.funcProcessGameStartedEvent != nil {
		mmProcessGameStartedEvent.mock.t.Fatalf("StaterMock.ProcessGameStartedEvent mock is already set by Set")
	}

	if mmProcessGameStartedEvent.defaultExpectation == nil {
		mmProcessGameStartedEvent.defaultExpectation = &StaterMockProcessGameStartedEventExpectation{}
	}

	mmProcessGameStartedEvent.defaultExpectation.params = &StaterMockProcessGameStartedEventParams{msg}
	for _, e := range mmProcessGameStartedEvent.expectations {
		if minimock.Equal(e.params, mmProcessGameStartedEvent.defaultExpectation.params) {
			mmProcessGameStartedEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessGameStartedEvent.defaultExpectation.params)
		}
	}

	return mmProcessGameStartedEvent
}

// Inspect accepts an inspector function that has same arguments as the Stater.ProcessGameStartedEvent
func (mmProcessGameStartedEvent *mStaterMockProcessGameStartedEvent) Inspect(f func(msg string)) *mStaterMockProcessGameStartedEvent {
	if mmProcessGameStartedEvent.mock.inspectFuncProcessGameStartedEvent != nil {
		mmProcessGameStartedEvent.mock.t.Fatalf("Inspect function is already set for StaterMock.ProcessGameStartedEvent")
	}

	mmProcessGameStartedEvent.mock.inspectFuncProcessGameStartedEvent = f

	return mmProcessGameStartedEvent
}

// Return sets up results that will be returned by Stater.ProcessGameStartedEvent
func (mmProcessGameStartedEvent *mStaterMockProcessGameStartedEvent) Return() *StaterMock {
	if mmProcessGameStartedEvent.mock.funcProcessGameStartedEvent != nil {
		mmProcessGameStartedEvent.mock.t.Fatalf("StaterMock.ProcessGameStartedEvent mock is already set by Set")
	}

	if mmProcessGameStartedEvent.defaultExpectation == nil {
		mmProcessGameStartedEvent.defaultExpectation = &StaterMockProcessGameStartedEventExpectation{mock: mmProcessGameStartedEvent.mock}
	}

	return mmProcessGameStartedEvent.mock
}

//Set uses given function f to mock the Stater.ProcessGameStartedEvent method
func (mmProcessGameStartedEvent *mStaterMockProcessGameStartedEvent) Set(f func(msg string)) *StaterMock {
	if mmProcessGameStartedEvent.defaultExpectation != nil {
		mmProcessGameStartedEvent.mock.t.Fatalf("Default expectation is already set for the Stater.ProcessGameStartedEvent method")
	}

	if len(mmProcessGameStartedEvent.expectations) > 0 {
		mmProcessGameStartedEvent.mock.t.Fatalf("Some expectations are already set for the Stater.ProcessGameStartedEvent method")
	}

	mmProcessGameStartedEvent.mock.funcProcessGameStartedEvent = f
	return mmProcessGameStartedEvent.mock
}

// ProcessGameStartedEvent implements stateMachine.Stater
func (mmProcessGameStartedEvent *StaterMock) ProcessGameStartedEvent(msg string) {
	mm_atomic.AddUint64(&mmProcessGameStartedEvent.beforeProcessGameStartedEventCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessGameStartedEvent.afterProcessGameStartedEventCounter, 1)

	if mmProcessGameStartedEvent.inspectFuncProcessGameStartedEvent != nil {
		mmProcessGameStartedEvent.inspectFuncProcessGameStartedEvent(msg)
	}

	mm_params := &StaterMockProcessGameStartedEventParams{msg}

	// Record call args
	mmProcessGameStartedEvent.ProcessGameStartedEventMock.mutex.Lock()
	mmProcessGameStartedEvent.ProcessGameStartedEventMock.callArgs = append(mmProcessGameStartedEvent.ProcessGameStartedEventMock.callArgs, mm_params)
	mmProcessGameStartedEvent.ProcessGameStartedEventMock.mutex.Unlock()

	for _, e := range mmProcessGameStartedEvent.ProcessGameStartedEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmProcessGameStartedEvent.ProcessGameStartedEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessGameStartedEvent.ProcessGameStartedEventMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessGameStartedEvent.ProcessGameStartedEventMock.defaultExpectation.params
		mm_got := StaterMockProcessGameStartedEventParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessGameStartedEvent.t.Errorf("StaterMock.ProcessGameStartedEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmProcessGameStartedEvent.funcProcessGameStartedEvent != nil {
		mmProcessGameStartedEvent.funcProcessGameStartedEvent(msg)
		return
	}
	mmProcessGameStartedEvent.t.Fatalf("Unexpected call to StaterMock.ProcessGameStartedEvent. %v", msg)

}

// ProcessGameStartedEventAfterCounter returns a count of finished StaterMock.ProcessGameStartedEvent invocations
func (mmProcessGameStartedEvent *StaterMock) ProcessGameStartedEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessGameStartedEvent.afterProcessGameStartedEventCounter)
}

// ProcessGameStartedEventBeforeCounter returns a count of StaterMock.ProcessGameStartedEvent invocations
func (mmProcessGameStartedEvent *StaterMock) ProcessGameStartedEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessGameStartedEvent.beforeProcessGameStartedEventCounter)
}

// Calls returns a list of arguments used in each call to StaterMock.ProcessGameStartedEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessGameStartedEvent *mStaterMockProcessGameStartedEvent) Calls() []*StaterMockProcessGameStartedEventParams {
	mmProcessGameStartedEvent.mutex.RLock()

	argCopy := make([]*StaterMockProcessGameStartedEventParams, len(mmProcessGameStartedEvent.callArgs))
	copy(argCopy, mmProcessGameStartedEvent.callArgs)

	mmProcessGameStartedEvent.mutex.RUnlock()

	return argCopy
}

// MinimockProcessGameStartedEventDone returns true if the count of the ProcessGameStartedEvent invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockProcessGameStartedEventDone() bool {
	for _, e := range m.ProcessGameStartedEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessGameStartedEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessGameStartedEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessGameStartedEvent != nil && mm_atomic.LoadUint64(&m.afterProcessGameStartedEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockProcessGameStartedEventInspect logs each unmet expectation
func (m *StaterMock) MinimockProcessGameStartedEventInspect() {
	for _, e := range m.ProcessGameStartedEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StaterMock.ProcessGameStartedEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessGameStartedEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessGameStartedEventCounter) < 1 {
		if m.ProcessGameStartedEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StaterMock.ProcessGameStartedEvent")
		} else {
			m.t.Errorf("Expected call to StaterMock.ProcessGameStartedEvent with params: %#v", *m.ProcessGameStartedEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessGameStartedEvent != nil && mm_atomic.LoadUint64(&m.afterProcessGameStartedEventCounter) < 1 {
		m.t.Error("Expected call to StaterMock.ProcessGameStartedEvent")
	}
}

type mStaterMockProcessLogLine struct {
	mock               *StaterMock
	defaultExpectation *StaterMockProcessLogLineExpectation
	expectations       []*StaterMockProcessLogLineExpectation

	callArgs []*StaterMockProcessLogLineParams
	mutex    sync.RWMutex
}

// StaterMockProcessLogLineExpectation specifies expectation struct of the Stater.ProcessLogLine
type StaterMockProcessLogLineExpectation struct {
	mock   *StaterMock
	params *StaterMockProcessLogLineParams

	Counter uint64
}

// StaterMockProcessLogLineParams contains parameters of the Stater.ProcessLogLine
type StaterMockProcessLogLineParams struct {
	msg string
}

// Expect sets up expected params for Stater.ProcessLogLine
func (mmProcessLogLine *mStaterMockProcessLogLine) Expect(msg string) *mStaterMockProcessLogLine {
	if mmProcessLogLine.mock.funcProcessLogLine != nil {
		mmProcessLogLine.mock.t.Fatalf("StaterMock.ProcessLogLine mock is already set by Set")
	}

	if mmProcessLogLine.defaultExpectation == nil {
		mmProcessLogLine.defaultExpectation = &StaterMockProcessLogLineExpectation{}
	}

	mmProcessLogLine.defaultExpectation.params = &StaterMockProcessLogLineParams{msg}
	for _, e := range mmProcessLogLine.expectations {
		if minimock.Equal(e.params, mmProcessLogLine.defaultExpectation.params) {
			mmProcessLogLine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessLogLine.defaultExpectation.params)
		}
	}

	return mmProcessLogLine
}

// Inspect accepts an inspector function that has same arguments as the Stater.ProcessLogLine
func (mmProcessLogLine *mStaterMockProcessLogLine) Inspect(f func(msg string)) *mStaterMockProcessLogLine {
	if mmProcessLogLine.mock.inspectFuncProcessLogLine != nil {
		mmProcessLogLine.mock.t.Fatalf("Inspect function is already set for StaterMock.ProcessLogLine")
	}

	mmProcessLogLine.mock.inspectFuncProcessLogLine = f

	return mmProcessLogLine
}

// Return sets up results that will be returned by Stater.ProcessLogLine
func (mmProcessLogLine *mStaterMockProcessLogLine) Return() *StaterMock {
	if mmProcessLogLine.mock.funcProcessLogLine != nil {
		mmProcessLogLine.mock.t.Fatalf("StaterMock.ProcessLogLine mock is already set by Set")
	}

	if mmProcessLogLine.defaultExpectation == nil {
		mmProcessLogLine.defaultExpectation = &StaterMockProcessLogLineExpectation{mock: mmProcessLogLine.mock}
	}

	return mmProcessLogLine.mock
}

//Set uses given function f to mock the Stater.ProcessLogLine method
func (mmProcessLogLine *mStaterMockProcessLogLine) Set(f func(msg string)) *StaterMock {
	if mmProcessLogLine.defaultExpectation != nil {
		mmProcessLogLine.mock.t.Fatalf("Default expectation is already set for the Stater.ProcessLogLine method")
	}

	if len(mmProcessLogLine.expectations) > 0 {
		mmProcessLogLine.mock.t.Fatalf("Some expectations are already set for the Stater.ProcessLogLine method")
	}

	mmProcessLogLine.mock.funcProcessLogLine = f
	return mmProcessLogLine.mock
}

// ProcessLogLine implements stateMachine.Stater
func (mmProcessLogLine *StaterMock) ProcessLogLine(msg string) {
	mm_atomic.AddUint64(&mmProcessLogLine.beforeProcessLogLineCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessLogLine.afterProcessLogLineCounter, 1)

	if mmProcessLogLine.inspectFuncProcessLogLine != nil {
		mmProcessLogLine.inspectFuncProcessLogLine(msg)
	}

	mm_params := &StaterMockProcessLogLineParams{msg}

	// Record call args
	mmProcessLogLine.ProcessLogLineMock.mutex.Lock()
	mmProcessLogLine.ProcessLogLineMock.callArgs = append(mmProcessLogLine.ProcessLogLineMock.callArgs, mm_params)
	mmProcessLogLine.ProcessLogLineMock.mutex.Unlock()

	for _, e := range mmProcessLogLine.ProcessLogLineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmProcessLogLine.ProcessLogLineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessLogLine.ProcessLogLineMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessLogLine.ProcessLogLineMock.defaultExpectation.params
		mm_got := StaterMockProcessLogLineParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessLogLine.t.Errorf("StaterMock.ProcessLogLine got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmProcessLogLine.funcProcessLogLine != nil {
		mmProcessLogLine.funcProcessLogLine(msg)
		return
	}
	mmProcessLogLine.t.Fatalf("Unexpected call to StaterMock.ProcessLogLine. %v", msg)

}

// ProcessLogLineAfterCounter returns a count of finished StaterMock.ProcessLogLine invocations
func (mmProcessLogLine *StaterMock) ProcessLogLineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessLogLine.afterProcessLogLineCounter)
}

// ProcessLogLineBeforeCounter returns a count of StaterMock.ProcessLogLine invocations
func (mmProcessLogLine *StaterMock) ProcessLogLineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessLogLine.beforeProcessLogLineCounter)
}

// Calls returns a list of arguments used in each call to StaterMock.ProcessLogLine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessLogLine *mStaterMockProcessLogLine) Calls() []*StaterMockProcessLogLineParams {
	mmProcessLogLine.mutex.RLock()

	argCopy := make([]*StaterMockProcessLogLineParams, len(mmProcessLogLine.callArgs))
	copy(argCopy, mmProcessLogLine.callArgs)

	mmProcessLogLine.mutex.RUnlock()

	return argCopy
}

// MinimockProcessLogLineDone returns true if the count of the ProcessLogLine invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockProcessLogLineDone() bool {
	for _, e := range m.ProcessLogLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessLogLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessLogLineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessLogLine != nil && mm_atomic.LoadUint64(&m.afterProcessLogLineCounter) < 1 {
		return false
	}
	return true
}

// MinimockProcessLogLineInspect logs each unmet expectation
func (m *StaterMock) MinimockProcessLogLineInspect() {
	for _, e := range m.ProcessLogLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StaterMock.ProcessLogLine with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessLogLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessLogLineCounter) < 1 {
		if m.ProcessLogLineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StaterMock.ProcessLogLine")
		} else {
			m.t.Errorf("Expected call to StaterMock.ProcessLogLine with params: %#v", *m.ProcessLogLineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessLogLine != nil && mm_atomic.LoadUint64(&m.afterProcessLogLineCounter) < 1 {
		m.t.Error("Expected call to StaterMock.ProcessLogLine")
	}
}

type mStaterMockSetState struct {
	mock               *StaterMock
	defaultExpectation *StaterMockSetStateExpectation
	expectations       []*StaterMockSetStateExpectation

	callArgs []*StaterMockSetStateParams
	mutex    sync.RWMutex
}

// StaterMockSetStateExpectation specifies expectation struct of the Stater.SetState
type StaterMockSetStateExpectation struct {
	mock   *StaterMock
	params *StaterMockSetStateParams

	Counter uint64
}

// StaterMockSetStateParams contains parameters of the Stater.SetState
type StaterMockSetStateParams struct {
	state mm_stateMachine.StateType
}

// Expect sets up expected params for Stater.SetState
func (mmSetState *mStaterMockSetState) Expect(state mm_stateMachine.StateType) *mStaterMockSetState {
	if mmSetState.mock.funcSetState != nil {
		mmSetState.mock.t.Fatalf("StaterMock.SetState mock is already set by Set")
	}

	if mmSetState.defaultExpectation == nil {
		mmSetState.defaultExpectation = &StaterMockSetStateExpectation{}
	}

	mmSetState.defaultExpectation.params = &StaterMockSetStateParams{state}
	for _, e := range mmSetState.expectations {
		if minimock.Equal(e.params, mmSetState.defaultExpectation.params) {
			mmSetState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetState.defaultExpectation.params)
		}
	}

	return mmSetState
}

// Inspect accepts an inspector function that has same arguments as the Stater.SetState
func (mmSetState *mStaterMockSetState) Inspect(f func(state mm_stateMachine.StateType)) *mStaterMockSetState {
	if mmSetState.mock.inspectFuncSetState != nil {
		mmSetState.mock.t.Fatalf("Inspect function is already set for StaterMock.SetState")
	}

	mmSetState.mock.inspectFuncSetState = f

	return mmSetState
}

// Return sets up results that will be returned by Stater.SetState
func (mmSetState *mStaterMockSetState) Return() *StaterMock {
	if mmSetState.mock.funcSetState != nil {
		mmSetState.mock.t.Fatalf("StaterMock.SetState mock is already set by Set")
	}

	if mmSetState.defaultExpectation == nil {
		mmSetState.defaultExpectation = &StaterMockSetStateExpectation{mock: mmSetState.mock}
	}

	return mmSetState.mock
}

//Set uses given function f to mock the Stater.SetState method
func (mmSetState *mStaterMockSetState) Set(f func(state mm_stateMachine.StateType)) *StaterMock {
	if mmSetState.defaultExpectation != nil {
		mmSetState.mock.t.Fatalf("Default expectation is already set for the Stater.SetState method")
	}

	if len(mmSetState.expectations) > 0 {
		mmSetState.mock.t.Fatalf("Some expectations are already set for the Stater.SetState method")
	}

	mmSetState.mock.funcSetState = f
	return mmSetState.mock
}

// SetState implements stateMachine.Stater
func (mmSetState *StaterMock) SetState(state mm_stateMachine.StateType) {
	mm_atomic.AddUint64(&mmSetState.beforeSetStateCounter, 1)
	defer mm_atomic.AddUint64(&mmSetState.afterSetStateCounter, 1)

	if mmSetState.inspectFuncSetState != nil {
		mmSetState.inspectFuncSetState(state)
	}

	mm_params := &StaterMockSetStateParams{state}

	// Record call args
	mmSetState.SetStateMock.mutex.Lock()
	mmSetState.SetStateMock.callArgs = append(mmSetState.SetStateMock.callArgs, mm_params)
	mmSetState.SetStateMock.mutex.Unlock()

	for _, e := range mmSetState.SetStateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetState.SetStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetState.SetStateMock.defaultExpectation.Counter, 1)
		mm_want := mmSetState.SetStateMock.defaultExpectation.params
		mm_got := StaterMockSetStateParams{state}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetState.t.Errorf("StaterMock.SetState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetState.funcSetState != nil {
		mmSetState.funcSetState(state)
		return
	}
	mmSetState.t.Fatalf("Unexpected call to StaterMock.SetState. %v", state)

}

// SetStateAfterCounter returns a count of finished StaterMock.SetState invocations
func (mmSetState *StaterMock) SetStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetState.afterSetStateCounter)
}

// SetStateBeforeCounter returns a count of StaterMock.SetState invocations
func (mmSetState *StaterMock) SetStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetState.beforeSetStateCounter)
}

// Calls returns a list of arguments used in each call to StaterMock.SetState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetState *mStaterMockSetState) Calls() []*StaterMockSetStateParams {
	mmSetState.mutex.RLock()

	argCopy := make([]*StaterMockSetStateParams, len(mmSetState.callArgs))
	copy(argCopy, mmSetState.callArgs)

	mmSetState.mutex.RUnlock()

	return argCopy
}

// MinimockSetStateDone returns true if the count of the SetState invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockSetStateDone() bool {
	for _, e := range m.SetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetState != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStateInspect logs each unmet expectation
func (m *StaterMock) MinimockSetStateInspect() {
	for _, e := range m.SetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StaterMock.SetState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		if m.SetStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StaterMock.SetState")
		} else {
			m.t.Errorf("Expected call to StaterMock.SetState with params: %#v", *m.SetStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetState != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		m.t.Error("Expected call to StaterMock.SetState")
	}
}

type mStaterMockStartWorker struct {
	mock               *StaterMock
	defaultExpectation *StaterMockStartWorkerExpectation
	expectations       []*StaterMockStartWorkerExpectation
}

// StaterMockStartWorkerExpectation specifies expectation struct of the Stater.StartWorker
type StaterMockStartWorkerExpectation struct {
	mock *StaterMock

	Counter uint64
}

// Expect sets up expected params for Stater.StartWorker
func (mmStartWorker *mStaterMockStartWorker) Expect() *mStaterMockStartWorker {
	if mmStartWorker.mock.funcStartWorker != nil {
		mmStartWorker.mock.t.Fatalf("StaterMock.StartWorker mock is already set by Set")
	}

	if mmStartWorker.defaultExpectation == nil {
		mmStartWorker.defaultExpectation = &StaterMockStartWorkerExpectation{}
	}

	return mmStartWorker
}

// Inspect accepts an inspector function that has same arguments as the Stater.StartWorker
func (mmStartWorker *mStaterMockStartWorker) Inspect(f func()) *mStaterMockStartWorker {
	if mmStartWorker.mock.inspectFuncStartWorker != nil {
		mmStartWorker.mock.t.Fatalf("Inspect function is already set for StaterMock.StartWorker")
	}

	mmStartWorker.mock.inspectFuncStartWorker = f

	return mmStartWorker
}

// Return sets up results that will be returned by Stater.StartWorker
func (mmStartWorker *mStaterMockStartWorker) Return() *StaterMock {
	if mmStartWorker.mock.funcStartWorker != nil {
		mmStartWorker.mock.t.Fatalf("StaterMock.StartWorker mock is already set by Set")
	}

	if mmStartWorker.defaultExpectation == nil {
		mmStartWorker.defaultExpectation = &StaterMockStartWorkerExpectation{mock: mmStartWorker.mock}
	}

	return mmStartWorker.mock
}

//Set uses given function f to mock the Stater.StartWorker method
func (mmStartWorker *mStaterMockStartWorker) Set(f func()) *StaterMock {
	if mmStartWorker.defaultExpectation != nil {
		mmStartWorker.mock.t.Fatalf("Default expectation is already set for the Stater.StartWorker method")
	}

	if len(mmStartWorker.expectations) > 0 {
		mmStartWorker.mock.t.Fatalf("Some expectations are already set for the Stater.StartWorker method")
	}

	mmStartWorker.mock.funcStartWorker = f
	return mmStartWorker.mock
}

// StartWorker implements stateMachine.Stater
func (mmStartWorker *StaterMock) StartWorker() {
	mm_atomic.AddUint64(&mmStartWorker.beforeStartWorkerCounter, 1)
	defer mm_atomic.AddUint64(&mmStartWorker.afterStartWorkerCounter, 1)

	if mmStartWorker.inspectFuncStartWorker != nil {
		mmStartWorker.inspectFuncStartWorker()
	}

	if mmStartWorker.StartWorkerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartWorker.StartWorkerMock.defaultExpectation.Counter, 1)

		return

	}
	if mmStartWorker.funcStartWorker != nil {
		mmStartWorker.funcStartWorker()
		return
	}
	mmStartWorker.t.Fatalf("Unexpected call to StaterMock.StartWorker.")

}

// StartWorkerAfterCounter returns a count of finished StaterMock.StartWorker invocations
func (mmStartWorker *StaterMock) StartWorkerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartWorker.afterStartWorkerCounter)
}

// StartWorkerBeforeCounter returns a count of StaterMock.StartWorker invocations
func (mmStartWorker *StaterMock) StartWorkerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartWorker.beforeStartWorkerCounter)
}

// MinimockStartWorkerDone returns true if the count of the StartWorker invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockStartWorkerDone() bool {
	for _, e := range m.StartWorkerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartWorkerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartWorkerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartWorker != nil && mm_atomic.LoadUint64(&m.afterStartWorkerCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartWorkerInspect logs each unmet expectation
func (m *StaterMock) MinimockStartWorkerInspect() {
	for _, e := range m.StartWorkerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StaterMock.StartWorker")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartWorkerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartWorkerCounter) < 1 {
		m.t.Error("Expected call to StaterMock.StartWorker")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartWorker != nil && mm_atomic.LoadUint64(&m.afterStartWorkerCounter) < 1 {
		m.t.Error("Expected call to StaterMock.StartWorker")
	}
}

type mStaterMockState struct {
	mock               *StaterMock
	defaultExpectation *StaterMockStateExpectation
	expectations       []*StaterMockStateExpectation
}

// StaterMockStateExpectation specifies expectation struct of the Stater.State
type StaterMockStateExpectation struct {
	mock *StaterMock

	results *StaterMockStateResults
	Counter uint64
}

// StaterMockStateResults contains results of the Stater.State
type StaterMockStateResults struct {
	s1 mm_stateMachine.StateType
}

// Expect sets up expected params for Stater.State
func (mmState *mStaterMockState) Expect() *mStaterMockState {
	if mmState.mock.funcState != nil {
		mmState.mock.t.Fatalf("StaterMock.State mock is already set by Set")
	}

	if mmState.defaultExpectation == nil {
		mmState.defaultExpectation = &StaterMockStateExpectation{}
	}

	return mmState
}

// Inspect accepts an inspector function that has same arguments as the Stater.State
func (mmState *mStaterMockState) Inspect(f func()) *mStaterMockState {
	if mmState.mock.inspectFuncState != nil {
		mmState.mock.t.Fatalf("Inspect function is already set for StaterMock.State")
	}

	mmState.mock.inspectFuncState = f

	return mmState
}

// Return sets up results that will be returned by Stater.State
func (mmState *mStaterMockState) Return(s1 mm_stateMachine.StateType) *StaterMock {
	if mmState.mock.funcState != nil {
		mmState.mock.t.Fatalf("StaterMock.State mock is already set by Set")
	}

	if mmState.defaultExpectation == nil {
		mmState.defaultExpectation = &StaterMockStateExpectation{mock: mmState.mock}
	}
	mmState.defaultExpectation.results = &StaterMockStateResults{s1}
	return mmState.mock
}

//Set uses given function f to mock the Stater.State method
func (mmState *mStaterMockState) Set(f func() (s1 mm_stateMachine.StateType)) *StaterMock {
	if mmState.defaultExpectation != nil {
		mmState.mock.t.Fatalf("Default expectation is already set for the Stater.State method")
	}

	if len(mmState.expectations) > 0 {
		mmState.mock.t.Fatalf("Some expectations are already set for the Stater.State method")
	}

	mmState.mock.funcState = f
	return mmState.mock
}

// State implements stateMachine.Stater
func (mmState *StaterMock) State() (s1 mm_stateMachine.StateType) {
	mm_atomic.AddUint64(&mmState.beforeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmState.afterStateCounter, 1)

	if mmState.inspectFuncState != nil {
		mmState.inspectFuncState()
	}

	if mmState.StateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmState.StateMock.defaultExpectation.Counter, 1)

		mm_results := mmState.StateMock.defaultExpectation.results
		if mm_results == nil {
			mmState.t.Fatal("No results are set for the StaterMock.State")
		}
		return (*mm_results).s1
	}
	if mmState.funcState != nil {
		return mmState.funcState()
	}
	mmState.t.Fatalf("Unexpected call to StaterMock.State.")
	return
}

// StateAfterCounter returns a count of finished StaterMock.State invocations
func (mmState *StaterMock) StateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmState.afterStateCounter)
}

// StateBeforeCounter returns a count of StaterMock.State invocations
func (mmState *StaterMock) StateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmState.beforeStateCounter)
}

// MinimockStateDone returns true if the count of the State invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockStateDone() bool {
	for _, e := range m.StateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcState != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockStateInspect logs each unmet expectation
func (m *StaterMock) MinimockStateInspect() {
	for _, e := range m.StateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StaterMock.State")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		m.t.Error("Expected call to StaterMock.State")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcState != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		m.t.Error("Expected call to StaterMock.State")
	}
}

type mStaterMockUpdatePickupInfo struct {
	mock               *StaterMock
	defaultExpectation *StaterMockUpdatePickupInfoExpectation
	expectations       []*StaterMockUpdatePickupInfoExpectation
}

// StaterMockUpdatePickupInfoExpectation specifies expectation struct of the Stater.UpdatePickupInfo
type StaterMockUpdatePickupInfoExpectation struct {
	mock *StaterMock

	results *StaterMockUpdatePickupInfoResults
	Counter uint64
}

// StaterMockUpdatePickupInfoResults contains results of the Stater.UpdatePickupInfo
type StaterMockUpdatePickupInfoResults struct {
	err error
}

// Expect sets up expected params for Stater.UpdatePickupInfo
func (mmUpdatePickupInfo *mStaterMockUpdatePickupInfo) Expect() *mStaterMockUpdatePickupInfo {
	if mmUpdatePickupInfo.mock.funcUpdatePickupInfo != nil {
		mmUpdatePickupInfo.mock.t.Fatalf("StaterMock.UpdatePickupInfo mock is already set by Set")
	}

	if mmUpdatePickupInfo.defaultExpectation == nil {
		mmUpdatePickupInfo.defaultExpectation = &StaterMockUpdatePickupInfoExpectation{}
	}

	return mmUpdatePickupInfo
}

// Inspect accepts an inspector function that has same arguments as the Stater.UpdatePickupInfo
func (mmUpdatePickupInfo *mStaterMockUpdatePickupInfo) Inspect(f func()) *mStaterMockUpdatePickupInfo {
	if mmUpdatePickupInfo.mock.inspectFuncUpdatePickupInfo != nil {
		mmUpdatePickupInfo.mock.t.Fatalf("Inspect function is already set for StaterMock.UpdatePickupInfo")
	}

	mmUpdatePickupInfo.mock.inspectFuncUpdatePickupInfo = f

	return mmUpdatePickupInfo
}

// Return sets up results that will be returned by Stater.UpdatePickupInfo
func (mmUpdatePickupInfo *mStaterMockUpdatePickupInfo) Return(err error) *StaterMock {
	if mmUpdatePickupInfo.mock.funcUpdatePickupInfo != nil {
		mmUpdatePickupInfo.mock.t.Fatalf("StaterMock.UpdatePickupInfo mock is already set by Set")
	}

	if mmUpdatePickupInfo.defaultExpectation == nil {
		mmUpdatePickupInfo.defaultExpectation = &StaterMockUpdatePickupInfoExpectation{mock: mmUpdatePickupInfo.mock}
	}
	mmUpdatePickupInfo.defaultExpectation.results = &StaterMockUpdatePickupInfoResults{err}
	return mmUpdatePickupInfo.mock
}

//Set uses given function f to mock the Stater.UpdatePickupInfo method
func (mmUpdatePickupInfo *mStaterMockUpdatePickupInfo) Set(f func() (err error)) *StaterMock {
	if mmUpdatePickupInfo.defaultExpectation != nil {
		mmUpdatePickupInfo.mock.t.Fatalf("Default expectation is already set for the Stater.UpdatePickupInfo method")
	}

	if len(mmUpdatePickupInfo.expectations) > 0 {
		mmUpdatePickupInfo.mock.t.Fatalf("Some expectations are already set for the Stater.UpdatePickupInfo method")
	}

	mmUpdatePickupInfo.mock.funcUpdatePickupInfo = f
	return mmUpdatePickupInfo.mock
}

// UpdatePickupInfo implements stateMachine.Stater
func (mmUpdatePickupInfo *StaterMock) UpdatePickupInfo() (err error) {
	mm_atomic.AddUint64(&mmUpdatePickupInfo.beforeUpdatePickupInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePickupInfo.afterUpdatePickupInfoCounter, 1)

	if mmUpdatePickupInfo.inspectFuncUpdatePickupInfo != nil {
		mmUpdatePickupInfo.inspectFuncUpdatePickupInfo()
	}

	if mmUpdatePickupInfo.UpdatePickupInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePickupInfo.UpdatePickupInfoMock.defaultExpectation.Counter, 1)

		mm_results := mmUpdatePickupInfo.UpdatePickupInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePickupInfo.t.Fatal("No results are set for the StaterMock.UpdatePickupInfo")
		}
		return (*mm_results).err
	}
	if mmUpdatePickupInfo.funcUpdatePickupInfo != nil {
		return mmUpdatePickupInfo.funcUpdatePickupInfo()
	}
	mmUpdatePickupInfo.t.Fatalf("Unexpected call to StaterMock.UpdatePickupInfo.")
	return
}

// UpdatePickupInfoAfterCounter returns a count of finished StaterMock.UpdatePickupInfo invocations
func (mmUpdatePickupInfo *StaterMock) UpdatePickupInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePickupInfo.afterUpdatePickupInfoCounter)
}

// UpdatePickupInfoBeforeCounter returns a count of StaterMock.UpdatePickupInfo invocations
func (mmUpdatePickupInfo *StaterMock) UpdatePickupInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePickupInfo.beforeUpdatePickupInfoCounter)
}

// MinimockUpdatePickupInfoDone returns true if the count of the UpdatePickupInfo invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockUpdatePickupInfoDone() bool {
	for _, e := range m.UpdatePickupInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePickupInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatePickupInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePickupInfo != nil && mm_atomic.LoadUint64(&m.afterUpdatePickupInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdatePickupInfoInspect logs each unmet expectation
func (m *StaterMock) MinimockUpdatePickupInfoInspect() {
	for _, e := range m.UpdatePickupInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StaterMock.UpdatePickupInfo")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePickupInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatePickupInfoCounter) < 1 {
		m.t.Error("Expected call to StaterMock.UpdatePickupInfo")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePickupInfo != nil && mm_atomic.LoadUint64(&m.afterUpdatePickupInfoCounter) < 1 {
		m.t.Error("Expected call to StaterMock.UpdatePickupInfo")
	}
}

type mStaterMockUploader struct {
	mock               *StaterMock
	defaultExpectation *StaterMockUploaderExpectation
	expectations       []*StaterMockUploaderExpectation
}

// StaterMockUploaderExpectation specifies expectation struct of the Stater.Uploader
type StaterMockUploaderExpectation struct {
	mock *StaterMock

	results *StaterMockUploaderResults
	Counter uint64
}

// StaterMockUploaderResults contains results of the Stater.Uploader
type StaterMockUploaderResults struct {
	l1 requests.LogUploader
}

// Expect sets up expected params for Stater.Uploader
func (mmUploader *mStaterMockUploader) Expect() *mStaterMockUploader {
	if mmUploader.mock.funcUploader != nil {
		mmUploader.mock.t.Fatalf("StaterMock.Uploader mock is already set by Set")
	}

	if mmUploader.defaultExpectation == nil {
		mmUploader.defaultExpectation = &StaterMockUploaderExpectation{}
	}

	return mmUploader
}

// Inspect accepts an inspector function that has same arguments as the Stater.Uploader
func (mmUploader *mStaterMockUploader) Inspect(f func()) *mStaterMockUploader {
	if mmUploader.mock.inspectFuncUploader != nil {
		mmUploader.mock.t.Fatalf("Inspect function is already set for StaterMock.Uploader")
	}

	mmUploader.mock.inspectFuncUploader = f

	return mmUploader
}

// Return sets up results that will be returned by Stater.Uploader
func (mmUploader *mStaterMockUploader) Return(l1 requests.LogUploader) *StaterMock {
	if mmUploader.mock.funcUploader != nil {
		mmUploader.mock.t.Fatalf("StaterMock.Uploader mock is already set by Set")
	}

	if mmUploader.defaultExpectation == nil {
		mmUploader.defaultExpectation = &StaterMockUploaderExpectation{mock: mmUploader.mock}
	}
	mmUploader.defaultExpectation.results = &StaterMockUploaderResults{l1}
	return mmUploader.mock
}

//Set uses given function f to mock the Stater.Uploader method
func (mmUploader *mStaterMockUploader) Set(f func() (l1 requests.LogUploader)) *StaterMock {
	if mmUploader.defaultExpectation != nil {
		mmUploader.mock.t.Fatalf("Default expectation is already set for the Stater.Uploader method")
	}

	if len(mmUploader.expectations) > 0 {
		mmUploader.mock.t.Fatalf("Some expectations are already set for the Stater.Uploader method")
	}

	mmUploader.mock.funcUploader = f
	return mmUploader.mock
}

// Uploader implements stateMachine.Stater
func (mmUploader *StaterMock) Uploader() (l1 requests.LogUploader) {
	mm_atomic.AddUint64(&mmUploader.beforeUploaderCounter, 1)
	defer mm_atomic.AddUint64(&mmUploader.afterUploaderCounter, 1)

	if mmUploader.inspectFuncUploader != nil {
		mmUploader.inspectFuncUploader()
	}

	if mmUploader.UploaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploader.UploaderMock.defaultExpectation.Counter, 1)

		mm_results := mmUploader.UploaderMock.defaultExpectation.results
		if mm_results == nil {
			mmUploader.t.Fatal("No results are set for the StaterMock.Uploader")
		}
		return (*mm_results).l1
	}
	if mmUploader.funcUploader != nil {
		return mmUploader.funcUploader()
	}
	mmUploader.t.Fatalf("Unexpected call to StaterMock.Uploader.")
	return
}

// UploaderAfterCounter returns a count of finished StaterMock.Uploader invocations
func (mmUploader *StaterMock) UploaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploader.afterUploaderCounter)
}

// UploaderBeforeCounter returns a count of StaterMock.Uploader invocations
func (mmUploader *StaterMock) UploaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploader.beforeUploaderCounter)
}

// MinimockUploaderDone returns true if the count of the Uploader invocations corresponds
// the number of defined expectations
func (m *StaterMock) MinimockUploaderDone() bool {
	for _, e := range m.UploaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UploaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUploaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploader != nil && mm_atomic.LoadUint64(&m.afterUploaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockUploaderInspect logs each unmet expectation
func (m *StaterMock) MinimockUploaderInspect() {
	for _, e := range m.UploaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StaterMock.Uploader")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UploaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUploaderCounter) < 1 {
		m.t.Error("Expected call to StaterMock.Uploader")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploader != nil && mm_atomic.LoadUint64(&m.afterUploaderCounter) < 1 {
		m.t.Error("Expected call to StaterMock.Uploader")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StaterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChannelInspect()

		m.MinimockFileInspect()

		m.MinimockInserterInspect()

		m.MinimockMatchInspect()

		m.MinimockProcessGameLogLineInspect()

		m.MinimockProcessGameOverEventInspect()

		m.MinimockProcessGameStartedEventInspect()

		m.MinimockProcessLogLineInspect()

		m.MinimockSetStateInspect()

		m.MinimockStartWorkerInspect()

		m.MinimockStateInspect()

		m.MinimockUpdatePickupInfoInspect()

		m.MinimockUploaderInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StaterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StaterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChannelDone() &&
		m.MinimockFileDone() &&
		m.MinimockInserterDone() &&
		m.MinimockMatchDone() &&
		m.MinimockProcessGameLogLineDone() &&
		m.MinimockProcessGameOverEventDone() &&
		m.MinimockProcessGameStartedEventDone() &&
		m.MinimockProcessLogLineDone() &&
		m.MinimockSetStateDone() &&
		m.MinimockStartWorkerDone() &&
		m.MinimockStateDone() &&
		m.MinimockUpdatePickupInfoDone() &&
		m.MinimockUploaderDone()
}
