package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/requests.LogUploader -o ./pkg/mocks/log_uploader_mock.go

import (
	mm_requests "LogWatcher/pkg/requests"
	"LogWatcher/pkg/stats"
	"bytes"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LogUploaderMock implements requests.LogUploader
type LogUploaderMock struct {
	t minimock.Tester

	funcFindMatchingPickup          func(domain string, Map string) (pp1 *mm_requests.Pickup, err error)
	inspectFuncFindMatchingPickup   func(domain string, Map string)
	afterFindMatchingPickupCounter  uint64
	beforeFindMatchingPickupCounter uint64
	FindMatchingPickupMock          mLogUploaderMockFindMatchingPickup

	funcMakeMultipartMap          func(matcher stats.Matcher, buf bytes.Buffer) (m1 map[string]io.Reader)
	inspectFuncMakeMultipartMap   func(matcher stats.Matcher, buf bytes.Buffer)
	afterMakeMultipartMapCounter  uint64
	beforeMakeMultipartMapCounter uint64
	MakeMultipartMapMock          mLogUploaderMockMakeMultipartMap

	funcResolvePlayers          func(domain string, players []*stats.PickupPlayer) (err error)
	inspectFuncResolvePlayers   func(domain string, players []*stats.PickupPlayer)
	afterResolvePlayersCounter  uint64
	beforeResolvePlayersCounter uint64
	ResolvePlayersMock          mLogUploaderMockResolvePlayers

	funcUploadLogFile          func(payload map[string]io.Reader) (err error)
	inspectFuncUploadLogFile   func(payload map[string]io.Reader)
	afterUploadLogFileCounter  uint64
	beforeUploadLogFileCounter uint64
	UploadLogFileMock          mLogUploaderMockUploadLogFile
}

// NewLogUploaderMock returns a mock for requests.LogUploader
func NewLogUploaderMock(t minimock.Tester) *LogUploaderMock {
	m := &LogUploaderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FindMatchingPickupMock = mLogUploaderMockFindMatchingPickup{mock: m}
	m.FindMatchingPickupMock.callArgs = []*LogUploaderMockFindMatchingPickupParams{}

	m.MakeMultipartMapMock = mLogUploaderMockMakeMultipartMap{mock: m}
	m.MakeMultipartMapMock.callArgs = []*LogUploaderMockMakeMultipartMapParams{}

	m.ResolvePlayersMock = mLogUploaderMockResolvePlayers{mock: m}
	m.ResolvePlayersMock.callArgs = []*LogUploaderMockResolvePlayersParams{}

	m.UploadLogFileMock = mLogUploaderMockUploadLogFile{mock: m}
	m.UploadLogFileMock.callArgs = []*LogUploaderMockUploadLogFileParams{}

	return m
}

type mLogUploaderMockFindMatchingPickup struct {
	mock               *LogUploaderMock
	defaultExpectation *LogUploaderMockFindMatchingPickupExpectation
	expectations       []*LogUploaderMockFindMatchingPickupExpectation

	callArgs []*LogUploaderMockFindMatchingPickupParams
	mutex    sync.RWMutex
}

// LogUploaderMockFindMatchingPickupExpectation specifies expectation struct of the LogUploader.FindMatchingPickup
type LogUploaderMockFindMatchingPickupExpectation struct {
	mock    *LogUploaderMock
	params  *LogUploaderMockFindMatchingPickupParams
	results *LogUploaderMockFindMatchingPickupResults
	Counter uint64
}

// LogUploaderMockFindMatchingPickupParams contains parameters of the LogUploader.FindMatchingPickup
type LogUploaderMockFindMatchingPickupParams struct {
	domain string
	Map    string
}

// LogUploaderMockFindMatchingPickupResults contains results of the LogUploader.FindMatchingPickup
type LogUploaderMockFindMatchingPickupResults struct {
	pp1 *mm_requests.Pickup
	err error
}

// Expect sets up expected params for LogUploader.FindMatchingPickup
func (mmFindMatchingPickup *mLogUploaderMockFindMatchingPickup) Expect(domain string, Map string) *mLogUploaderMockFindMatchingPickup {
	if mmFindMatchingPickup.mock.funcFindMatchingPickup != nil {
		mmFindMatchingPickup.mock.t.Fatalf("LogUploaderMock.FindMatchingPickup mock is already set by Set")
	}

	if mmFindMatchingPickup.defaultExpectation == nil {
		mmFindMatchingPickup.defaultExpectation = &LogUploaderMockFindMatchingPickupExpectation{}
	}

	mmFindMatchingPickup.defaultExpectation.params = &LogUploaderMockFindMatchingPickupParams{domain, Map}
	for _, e := range mmFindMatchingPickup.expectations {
		if minimock.Equal(e.params, mmFindMatchingPickup.defaultExpectation.params) {
			mmFindMatchingPickup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindMatchingPickup.defaultExpectation.params)
		}
	}

	return mmFindMatchingPickup
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.FindMatchingPickup
func (mmFindMatchingPickup *mLogUploaderMockFindMatchingPickup) Inspect(f func(domain string, Map string)) *mLogUploaderMockFindMatchingPickup {
	if mmFindMatchingPickup.mock.inspectFuncFindMatchingPickup != nil {
		mmFindMatchingPickup.mock.t.Fatalf("Inspect function is already set for LogUploaderMock.FindMatchingPickup")
	}

	mmFindMatchingPickup.mock.inspectFuncFindMatchingPickup = f

	return mmFindMatchingPickup
}

// Return sets up results that will be returned by LogUploader.FindMatchingPickup
func (mmFindMatchingPickup *mLogUploaderMockFindMatchingPickup) Return(pp1 *mm_requests.Pickup, err error) *LogUploaderMock {
	if mmFindMatchingPickup.mock.funcFindMatchingPickup != nil {
		mmFindMatchingPickup.mock.t.Fatalf("LogUploaderMock.FindMatchingPickup mock is already set by Set")
	}

	if mmFindMatchingPickup.defaultExpectation == nil {
		mmFindMatchingPickup.defaultExpectation = &LogUploaderMockFindMatchingPickupExpectation{mock: mmFindMatchingPickup.mock}
	}
	mmFindMatchingPickup.defaultExpectation.results = &LogUploaderMockFindMatchingPickupResults{pp1, err}
	return mmFindMatchingPickup.mock
}

//Set uses given function f to mock the LogUploader.FindMatchingPickup method
func (mmFindMatchingPickup *mLogUploaderMockFindMatchingPickup) Set(f func(domain string, Map string) (pp1 *mm_requests.Pickup, err error)) *LogUploaderMock {
	if mmFindMatchingPickup.defaultExpectation != nil {
		mmFindMatchingPickup.mock.t.Fatalf("Default expectation is already set for the LogUploader.FindMatchingPickup method")
	}

	if len(mmFindMatchingPickup.expectations) > 0 {
		mmFindMatchingPickup.mock.t.Fatalf("Some expectations are already set for the LogUploader.FindMatchingPickup method")
	}

	mmFindMatchingPickup.mock.funcFindMatchingPickup = f
	return mmFindMatchingPickup.mock
}

// When sets expectation for the LogUploader.FindMatchingPickup which will trigger the result defined by the following
// Then helper
func (mmFindMatchingPickup *mLogUploaderMockFindMatchingPickup) When(domain string, Map string) *LogUploaderMockFindMatchingPickupExpectation {
	if mmFindMatchingPickup.mock.funcFindMatchingPickup != nil {
		mmFindMatchingPickup.mock.t.Fatalf("LogUploaderMock.FindMatchingPickup mock is already set by Set")
	}

	expectation := &LogUploaderMockFindMatchingPickupExpectation{
		mock:   mmFindMatchingPickup.mock,
		params: &LogUploaderMockFindMatchingPickupParams{domain, Map},
	}
	mmFindMatchingPickup.expectations = append(mmFindMatchingPickup.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.FindMatchingPickup return parameters for the expectation previously defined by the When method
func (e *LogUploaderMockFindMatchingPickupExpectation) Then(pp1 *mm_requests.Pickup, err error) *LogUploaderMock {
	e.results = &LogUploaderMockFindMatchingPickupResults{pp1, err}
	return e.mock
}

// FindMatchingPickup implements requests.LogUploader
func (mmFindMatchingPickup *LogUploaderMock) FindMatchingPickup(domain string, Map string) (pp1 *mm_requests.Pickup, err error) {
	mm_atomic.AddUint64(&mmFindMatchingPickup.beforeFindMatchingPickupCounter, 1)
	defer mm_atomic.AddUint64(&mmFindMatchingPickup.afterFindMatchingPickupCounter, 1)

	if mmFindMatchingPickup.inspectFuncFindMatchingPickup != nil {
		mmFindMatchingPickup.inspectFuncFindMatchingPickup(domain, Map)
	}

	mm_params := &LogUploaderMockFindMatchingPickupParams{domain, Map}

	// Record call args
	mmFindMatchingPickup.FindMatchingPickupMock.mutex.Lock()
	mmFindMatchingPickup.FindMatchingPickupMock.callArgs = append(mmFindMatchingPickup.FindMatchingPickupMock.callArgs, mm_params)
	mmFindMatchingPickup.FindMatchingPickupMock.mutex.Unlock()

	for _, e := range mmFindMatchingPickup.FindMatchingPickupMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmFindMatchingPickup.FindMatchingPickupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindMatchingPickup.FindMatchingPickupMock.defaultExpectation.Counter, 1)
		mm_want := mmFindMatchingPickup.FindMatchingPickupMock.defaultExpectation.params
		mm_got := LogUploaderMockFindMatchingPickupParams{domain, Map}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindMatchingPickup.t.Errorf("LogUploaderMock.FindMatchingPickup got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindMatchingPickup.FindMatchingPickupMock.defaultExpectation.results
		if mm_results == nil {
			mmFindMatchingPickup.t.Fatal("No results are set for the LogUploaderMock.FindMatchingPickup")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmFindMatchingPickup.funcFindMatchingPickup != nil {
		return mmFindMatchingPickup.funcFindMatchingPickup(domain, Map)
	}
	mmFindMatchingPickup.t.Fatalf("Unexpected call to LogUploaderMock.FindMatchingPickup. %v %v", domain, Map)
	return
}

// FindMatchingPickupAfterCounter returns a count of finished LogUploaderMock.FindMatchingPickup invocations
func (mmFindMatchingPickup *LogUploaderMock) FindMatchingPickupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindMatchingPickup.afterFindMatchingPickupCounter)
}

// FindMatchingPickupBeforeCounter returns a count of LogUploaderMock.FindMatchingPickup invocations
func (mmFindMatchingPickup *LogUploaderMock) FindMatchingPickupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindMatchingPickup.beforeFindMatchingPickupCounter)
}

// Calls returns a list of arguments used in each call to LogUploaderMock.FindMatchingPickup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindMatchingPickup *mLogUploaderMockFindMatchingPickup) Calls() []*LogUploaderMockFindMatchingPickupParams {
	mmFindMatchingPickup.mutex.RLock()

	argCopy := make([]*LogUploaderMockFindMatchingPickupParams, len(mmFindMatchingPickup.callArgs))
	copy(argCopy, mmFindMatchingPickup.callArgs)

	mmFindMatchingPickup.mutex.RUnlock()

	return argCopy
}

// MinimockFindMatchingPickupDone returns true if the count of the FindMatchingPickup invocations corresponds
// the number of defined expectations
func (m *LogUploaderMock) MinimockFindMatchingPickupDone() bool {
	for _, e := range m.FindMatchingPickupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindMatchingPickupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindMatchingPickupCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindMatchingPickup != nil && mm_atomic.LoadUint64(&m.afterFindMatchingPickupCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindMatchingPickupInspect logs each unmet expectation
func (m *LogUploaderMock) MinimockFindMatchingPickupInspect() {
	for _, e := range m.FindMatchingPickupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogUploaderMock.FindMatchingPickup with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindMatchingPickupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindMatchingPickupCounter) < 1 {
		if m.FindMatchingPickupMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogUploaderMock.FindMatchingPickup")
		} else {
			m.t.Errorf("Expected call to LogUploaderMock.FindMatchingPickup with params: %#v", *m.FindMatchingPickupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindMatchingPickup != nil && mm_atomic.LoadUint64(&m.afterFindMatchingPickupCounter) < 1 {
		m.t.Error("Expected call to LogUploaderMock.FindMatchingPickup")
	}
}

type mLogUploaderMockMakeMultipartMap struct {
	mock               *LogUploaderMock
	defaultExpectation *LogUploaderMockMakeMultipartMapExpectation
	expectations       []*LogUploaderMockMakeMultipartMapExpectation

	callArgs []*LogUploaderMockMakeMultipartMapParams
	mutex    sync.RWMutex
}

// LogUploaderMockMakeMultipartMapExpectation specifies expectation struct of the LogUploader.MakeMultipartMap
type LogUploaderMockMakeMultipartMapExpectation struct {
	mock    *LogUploaderMock
	params  *LogUploaderMockMakeMultipartMapParams
	results *LogUploaderMockMakeMultipartMapResults
	Counter uint64
}

// LogUploaderMockMakeMultipartMapParams contains parameters of the LogUploader.MakeMultipartMap
type LogUploaderMockMakeMultipartMapParams struct {
	matcher stats.Matcher
	buf     bytes.Buffer
}

// LogUploaderMockMakeMultipartMapResults contains results of the LogUploader.MakeMultipartMap
type LogUploaderMockMakeMultipartMapResults struct {
	m1 map[string]io.Reader
}

// Expect sets up expected params for LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Expect(matcher stats.Matcher, buf bytes.Buffer) *mLogUploaderMockMakeMultipartMap {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogUploaderMock.MakeMultipartMap mock is already set by Set")
	}

	if mmMakeMultipartMap.defaultExpectation == nil {
		mmMakeMultipartMap.defaultExpectation = &LogUploaderMockMakeMultipartMapExpectation{}
	}

	mmMakeMultipartMap.defaultExpectation.params = &LogUploaderMockMakeMultipartMapParams{matcher, buf}
	for _, e := range mmMakeMultipartMap.expectations {
		if minimock.Equal(e.params, mmMakeMultipartMap.defaultExpectation.params) {
			mmMakeMultipartMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMakeMultipartMap.defaultExpectation.params)
		}
	}

	return mmMakeMultipartMap
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Inspect(f func(matcher stats.Matcher, buf bytes.Buffer)) *mLogUploaderMockMakeMultipartMap {
	if mmMakeMultipartMap.mock.inspectFuncMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("Inspect function is already set for LogUploaderMock.MakeMultipartMap")
	}

	mmMakeMultipartMap.mock.inspectFuncMakeMultipartMap = f

	return mmMakeMultipartMap
}

// Return sets up results that will be returned by LogUploader.MakeMultipartMap
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Return(m1 map[string]io.Reader) *LogUploaderMock {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogUploaderMock.MakeMultipartMap mock is already set by Set")
	}

	if mmMakeMultipartMap.defaultExpectation == nil {
		mmMakeMultipartMap.defaultExpectation = &LogUploaderMockMakeMultipartMapExpectation{mock: mmMakeMultipartMap.mock}
	}
	mmMakeMultipartMap.defaultExpectation.results = &LogUploaderMockMakeMultipartMapResults{m1}
	return mmMakeMultipartMap.mock
}

//Set uses given function f to mock the LogUploader.MakeMultipartMap method
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Set(f func(matcher stats.Matcher, buf bytes.Buffer) (m1 map[string]io.Reader)) *LogUploaderMock {
	if mmMakeMultipartMap.defaultExpectation != nil {
		mmMakeMultipartMap.mock.t.Fatalf("Default expectation is already set for the LogUploader.MakeMultipartMap method")
	}

	if len(mmMakeMultipartMap.expectations) > 0 {
		mmMakeMultipartMap.mock.t.Fatalf("Some expectations are already set for the LogUploader.MakeMultipartMap method")
	}

	mmMakeMultipartMap.mock.funcMakeMultipartMap = f
	return mmMakeMultipartMap.mock
}

// When sets expectation for the LogUploader.MakeMultipartMap which will trigger the result defined by the following
// Then helper
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) When(matcher stats.Matcher, buf bytes.Buffer) *LogUploaderMockMakeMultipartMapExpectation {
	if mmMakeMultipartMap.mock.funcMakeMultipartMap != nil {
		mmMakeMultipartMap.mock.t.Fatalf("LogUploaderMock.MakeMultipartMap mock is already set by Set")
	}

	expectation := &LogUploaderMockMakeMultipartMapExpectation{
		mock:   mmMakeMultipartMap.mock,
		params: &LogUploaderMockMakeMultipartMapParams{matcher, buf},
	}
	mmMakeMultipartMap.expectations = append(mmMakeMultipartMap.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.MakeMultipartMap return parameters for the expectation previously defined by the When method
func (e *LogUploaderMockMakeMultipartMapExpectation) Then(m1 map[string]io.Reader) *LogUploaderMock {
	e.results = &LogUploaderMockMakeMultipartMapResults{m1}
	return e.mock
}

// MakeMultipartMap implements requests.LogUploader
func (mmMakeMultipartMap *LogUploaderMock) MakeMultipartMap(matcher stats.Matcher, buf bytes.Buffer) (m1 map[string]io.Reader) {
	mm_atomic.AddUint64(&mmMakeMultipartMap.beforeMakeMultipartMapCounter, 1)
	defer mm_atomic.AddUint64(&mmMakeMultipartMap.afterMakeMultipartMapCounter, 1)

	if mmMakeMultipartMap.inspectFuncMakeMultipartMap != nil {
		mmMakeMultipartMap.inspectFuncMakeMultipartMap(matcher, buf)
	}

	mm_params := &LogUploaderMockMakeMultipartMapParams{matcher, buf}

	// Record call args
	mmMakeMultipartMap.MakeMultipartMapMock.mutex.Lock()
	mmMakeMultipartMap.MakeMultipartMapMock.callArgs = append(mmMakeMultipartMap.MakeMultipartMapMock.callArgs, mm_params)
	mmMakeMultipartMap.MakeMultipartMapMock.mutex.Unlock()

	for _, e := range mmMakeMultipartMap.MakeMultipartMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1
		}
	}

	if mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.Counter, 1)
		mm_want := mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.params
		mm_got := LogUploaderMockMakeMultipartMapParams{matcher, buf}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMakeMultipartMap.t.Errorf("LogUploaderMock.MakeMultipartMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMakeMultipartMap.MakeMultipartMapMock.defaultExpectation.results
		if mm_results == nil {
			mmMakeMultipartMap.t.Fatal("No results are set for the LogUploaderMock.MakeMultipartMap")
		}
		return (*mm_results).m1
	}
	if mmMakeMultipartMap.funcMakeMultipartMap != nil {
		return mmMakeMultipartMap.funcMakeMultipartMap(matcher, buf)
	}
	mmMakeMultipartMap.t.Fatalf("Unexpected call to LogUploaderMock.MakeMultipartMap. %v %v", matcher, buf)
	return
}

// MakeMultipartMapAfterCounter returns a count of finished LogUploaderMock.MakeMultipartMap invocations
func (mmMakeMultipartMap *LogUploaderMock) MakeMultipartMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeMultipartMap.afterMakeMultipartMapCounter)
}

// MakeMultipartMapBeforeCounter returns a count of LogUploaderMock.MakeMultipartMap invocations
func (mmMakeMultipartMap *LogUploaderMock) MakeMultipartMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeMultipartMap.beforeMakeMultipartMapCounter)
}

// Calls returns a list of arguments used in each call to LogUploaderMock.MakeMultipartMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMakeMultipartMap *mLogUploaderMockMakeMultipartMap) Calls() []*LogUploaderMockMakeMultipartMapParams {
	mmMakeMultipartMap.mutex.RLock()

	argCopy := make([]*LogUploaderMockMakeMultipartMapParams, len(mmMakeMultipartMap.callArgs))
	copy(argCopy, mmMakeMultipartMap.callArgs)

	mmMakeMultipartMap.mutex.RUnlock()

	return argCopy
}

// MinimockMakeMultipartMapDone returns true if the count of the MakeMultipartMap invocations corresponds
// the number of defined expectations
func (m *LogUploaderMock) MinimockMakeMultipartMapDone() bool {
	for _, e := range m.MakeMultipartMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeMultipartMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeMultipartMap != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockMakeMultipartMapInspect logs each unmet expectation
func (m *LogUploaderMock) MinimockMakeMultipartMapInspect() {
	for _, e := range m.MakeMultipartMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogUploaderMock.MakeMultipartMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeMultipartMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		if m.MakeMultipartMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogUploaderMock.MakeMultipartMap")
		} else {
			m.t.Errorf("Expected call to LogUploaderMock.MakeMultipartMap with params: %#v", *m.MakeMultipartMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeMultipartMap != nil && mm_atomic.LoadUint64(&m.afterMakeMultipartMapCounter) < 1 {
		m.t.Error("Expected call to LogUploaderMock.MakeMultipartMap")
	}
}

type mLogUploaderMockResolvePlayers struct {
	mock               *LogUploaderMock
	defaultExpectation *LogUploaderMockResolvePlayersExpectation
	expectations       []*LogUploaderMockResolvePlayersExpectation

	callArgs []*LogUploaderMockResolvePlayersParams
	mutex    sync.RWMutex
}

// LogUploaderMockResolvePlayersExpectation specifies expectation struct of the LogUploader.ResolvePlayers
type LogUploaderMockResolvePlayersExpectation struct {
	mock    *LogUploaderMock
	params  *LogUploaderMockResolvePlayersParams
	results *LogUploaderMockResolvePlayersResults
	Counter uint64
}

// LogUploaderMockResolvePlayersParams contains parameters of the LogUploader.ResolvePlayers
type LogUploaderMockResolvePlayersParams struct {
	domain  string
	players []*stats.PickupPlayer
}

// LogUploaderMockResolvePlayersResults contains results of the LogUploader.ResolvePlayers
type LogUploaderMockResolvePlayersResults struct {
	err error
}

// Expect sets up expected params for LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Expect(domain string, players []*stats.PickupPlayer) *mLogUploaderMockResolvePlayers {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogUploaderMock.ResolvePlayers mock is already set by Set")
	}

	if mmResolvePlayers.defaultExpectation == nil {
		mmResolvePlayers.defaultExpectation = &LogUploaderMockResolvePlayersExpectation{}
	}

	mmResolvePlayers.defaultExpectation.params = &LogUploaderMockResolvePlayersParams{domain, players}
	for _, e := range mmResolvePlayers.expectations {
		if minimock.Equal(e.params, mmResolvePlayers.defaultExpectation.params) {
			mmResolvePlayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResolvePlayers.defaultExpectation.params)
		}
	}

	return mmResolvePlayers
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Inspect(f func(domain string, players []*stats.PickupPlayer)) *mLogUploaderMockResolvePlayers {
	if mmResolvePlayers.mock.inspectFuncResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("Inspect function is already set for LogUploaderMock.ResolvePlayers")
	}

	mmResolvePlayers.mock.inspectFuncResolvePlayers = f

	return mmResolvePlayers
}

// Return sets up results that will be returned by LogUploader.ResolvePlayers
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Return(err error) *LogUploaderMock {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogUploaderMock.ResolvePlayers mock is already set by Set")
	}

	if mmResolvePlayers.defaultExpectation == nil {
		mmResolvePlayers.defaultExpectation = &LogUploaderMockResolvePlayersExpectation{mock: mmResolvePlayers.mock}
	}
	mmResolvePlayers.defaultExpectation.results = &LogUploaderMockResolvePlayersResults{err}
	return mmResolvePlayers.mock
}

//Set uses given function f to mock the LogUploader.ResolvePlayers method
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Set(f func(domain string, players []*stats.PickupPlayer) (err error)) *LogUploaderMock {
	if mmResolvePlayers.defaultExpectation != nil {
		mmResolvePlayers.mock.t.Fatalf("Default expectation is already set for the LogUploader.ResolvePlayers method")
	}

	if len(mmResolvePlayers.expectations) > 0 {
		mmResolvePlayers.mock.t.Fatalf("Some expectations are already set for the LogUploader.ResolvePlayers method")
	}

	mmResolvePlayers.mock.funcResolvePlayers = f
	return mmResolvePlayers.mock
}

// When sets expectation for the LogUploader.ResolvePlayers which will trigger the result defined by the following
// Then helper
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) When(domain string, players []*stats.PickupPlayer) *LogUploaderMockResolvePlayersExpectation {
	if mmResolvePlayers.mock.funcResolvePlayers != nil {
		mmResolvePlayers.mock.t.Fatalf("LogUploaderMock.ResolvePlayers mock is already set by Set")
	}

	expectation := &LogUploaderMockResolvePlayersExpectation{
		mock:   mmResolvePlayers.mock,
		params: &LogUploaderMockResolvePlayersParams{domain, players},
	}
	mmResolvePlayers.expectations = append(mmResolvePlayers.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.ResolvePlayers return parameters for the expectation previously defined by the When method
func (e *LogUploaderMockResolvePlayersExpectation) Then(err error) *LogUploaderMock {
	e.results = &LogUploaderMockResolvePlayersResults{err}
	return e.mock
}

// ResolvePlayers implements requests.LogUploader
func (mmResolvePlayers *LogUploaderMock) ResolvePlayers(domain string, players []*stats.PickupPlayer) (err error) {
	mm_atomic.AddUint64(&mmResolvePlayers.beforeResolvePlayersCounter, 1)
	defer mm_atomic.AddUint64(&mmResolvePlayers.afterResolvePlayersCounter, 1)

	if mmResolvePlayers.inspectFuncResolvePlayers != nil {
		mmResolvePlayers.inspectFuncResolvePlayers(domain, players)
	}

	mm_params := &LogUploaderMockResolvePlayersParams{domain, players}

	// Record call args
	mmResolvePlayers.ResolvePlayersMock.mutex.Lock()
	mmResolvePlayers.ResolvePlayersMock.callArgs = append(mmResolvePlayers.ResolvePlayersMock.callArgs, mm_params)
	mmResolvePlayers.ResolvePlayersMock.mutex.Unlock()

	for _, e := range mmResolvePlayers.ResolvePlayersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmResolvePlayers.ResolvePlayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResolvePlayers.ResolvePlayersMock.defaultExpectation.Counter, 1)
		mm_want := mmResolvePlayers.ResolvePlayersMock.defaultExpectation.params
		mm_got := LogUploaderMockResolvePlayersParams{domain, players}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmResolvePlayers.t.Errorf("LogUploaderMock.ResolvePlayers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmResolvePlayers.ResolvePlayersMock.defaultExpectation.results
		if mm_results == nil {
			mmResolvePlayers.t.Fatal("No results are set for the LogUploaderMock.ResolvePlayers")
		}
		return (*mm_results).err
	}
	if mmResolvePlayers.funcResolvePlayers != nil {
		return mmResolvePlayers.funcResolvePlayers(domain, players)
	}
	mmResolvePlayers.t.Fatalf("Unexpected call to LogUploaderMock.ResolvePlayers. %v %v", domain, players)
	return
}

// ResolvePlayersAfterCounter returns a count of finished LogUploaderMock.ResolvePlayers invocations
func (mmResolvePlayers *LogUploaderMock) ResolvePlayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolvePlayers.afterResolvePlayersCounter)
}

// ResolvePlayersBeforeCounter returns a count of LogUploaderMock.ResolvePlayers invocations
func (mmResolvePlayers *LogUploaderMock) ResolvePlayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolvePlayers.beforeResolvePlayersCounter)
}

// Calls returns a list of arguments used in each call to LogUploaderMock.ResolvePlayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResolvePlayers *mLogUploaderMockResolvePlayers) Calls() []*LogUploaderMockResolvePlayersParams {
	mmResolvePlayers.mutex.RLock()

	argCopy := make([]*LogUploaderMockResolvePlayersParams, len(mmResolvePlayers.callArgs))
	copy(argCopy, mmResolvePlayers.callArgs)

	mmResolvePlayers.mutex.RUnlock()

	return argCopy
}

// MinimockResolvePlayersDone returns true if the count of the ResolvePlayers invocations corresponds
// the number of defined expectations
func (m *LogUploaderMock) MinimockResolvePlayersDone() bool {
	for _, e := range m.ResolvePlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolvePlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolvePlayers != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		return false
	}
	return true
}

// MinimockResolvePlayersInspect logs each unmet expectation
func (m *LogUploaderMock) MinimockResolvePlayersInspect() {
	for _, e := range m.ResolvePlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogUploaderMock.ResolvePlayers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolvePlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		if m.ResolvePlayersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogUploaderMock.ResolvePlayers")
		} else {
			m.t.Errorf("Expected call to LogUploaderMock.ResolvePlayers with params: %#v", *m.ResolvePlayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolvePlayers != nil && mm_atomic.LoadUint64(&m.afterResolvePlayersCounter) < 1 {
		m.t.Error("Expected call to LogUploaderMock.ResolvePlayers")
	}
}

type mLogUploaderMockUploadLogFile struct {
	mock               *LogUploaderMock
	defaultExpectation *LogUploaderMockUploadLogFileExpectation
	expectations       []*LogUploaderMockUploadLogFileExpectation

	callArgs []*LogUploaderMockUploadLogFileParams
	mutex    sync.RWMutex
}

// LogUploaderMockUploadLogFileExpectation specifies expectation struct of the LogUploader.UploadLogFile
type LogUploaderMockUploadLogFileExpectation struct {
	mock    *LogUploaderMock
	params  *LogUploaderMockUploadLogFileParams
	results *LogUploaderMockUploadLogFileResults
	Counter uint64
}

// LogUploaderMockUploadLogFileParams contains parameters of the LogUploader.UploadLogFile
type LogUploaderMockUploadLogFileParams struct {
	payload map[string]io.Reader
}

// LogUploaderMockUploadLogFileResults contains results of the LogUploader.UploadLogFile
type LogUploaderMockUploadLogFileResults struct {
	err error
}

// Expect sets up expected params for LogUploader.UploadLogFile
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Expect(payload map[string]io.Reader) *mLogUploaderMockUploadLogFile {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogUploaderMock.UploadLogFile mock is already set by Set")
	}

	if mmUploadLogFile.defaultExpectation == nil {
		mmUploadLogFile.defaultExpectation = &LogUploaderMockUploadLogFileExpectation{}
	}

	mmUploadLogFile.defaultExpectation.params = &LogUploaderMockUploadLogFileParams{payload}
	for _, e := range mmUploadLogFile.expectations {
		if minimock.Equal(e.params, mmUploadLogFile.defaultExpectation.params) {
			mmUploadLogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadLogFile.defaultExpectation.params)
		}
	}

	return mmUploadLogFile
}

// Inspect accepts an inspector function that has same arguments as the LogUploader.UploadLogFile
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Inspect(f func(payload map[string]io.Reader)) *mLogUploaderMockUploadLogFile {
	if mmUploadLogFile.mock.inspectFuncUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("Inspect function is already set for LogUploaderMock.UploadLogFile")
	}

	mmUploadLogFile.mock.inspectFuncUploadLogFile = f

	return mmUploadLogFile
}

// Return sets up results that will be returned by LogUploader.UploadLogFile
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Return(err error) *LogUploaderMock {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogUploaderMock.UploadLogFile mock is already set by Set")
	}

	if mmUploadLogFile.defaultExpectation == nil {
		mmUploadLogFile.defaultExpectation = &LogUploaderMockUploadLogFileExpectation{mock: mmUploadLogFile.mock}
	}
	mmUploadLogFile.defaultExpectation.results = &LogUploaderMockUploadLogFileResults{err}
	return mmUploadLogFile.mock
}

//Set uses given function f to mock the LogUploader.UploadLogFile method
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Set(f func(payload map[string]io.Reader) (err error)) *LogUploaderMock {
	if mmUploadLogFile.defaultExpectation != nil {
		mmUploadLogFile.mock.t.Fatalf("Default expectation is already set for the LogUploader.UploadLogFile method")
	}

	if len(mmUploadLogFile.expectations) > 0 {
		mmUploadLogFile.mock.t.Fatalf("Some expectations are already set for the LogUploader.UploadLogFile method")
	}

	mmUploadLogFile.mock.funcUploadLogFile = f
	return mmUploadLogFile.mock
}

// When sets expectation for the LogUploader.UploadLogFile which will trigger the result defined by the following
// Then helper
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) When(payload map[string]io.Reader) *LogUploaderMockUploadLogFileExpectation {
	if mmUploadLogFile.mock.funcUploadLogFile != nil {
		mmUploadLogFile.mock.t.Fatalf("LogUploaderMock.UploadLogFile mock is already set by Set")
	}

	expectation := &LogUploaderMockUploadLogFileExpectation{
		mock:   mmUploadLogFile.mock,
		params: &LogUploaderMockUploadLogFileParams{payload},
	}
	mmUploadLogFile.expectations = append(mmUploadLogFile.expectations, expectation)
	return expectation
}

// Then sets up LogUploader.UploadLogFile return parameters for the expectation previously defined by the When method
func (e *LogUploaderMockUploadLogFileExpectation) Then(err error) *LogUploaderMock {
	e.results = &LogUploaderMockUploadLogFileResults{err}
	return e.mock
}

// UploadLogFile implements requests.LogUploader
func (mmUploadLogFile *LogUploaderMock) UploadLogFile(payload map[string]io.Reader) (err error) {
	mm_atomic.AddUint64(&mmUploadLogFile.beforeUploadLogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadLogFile.afterUploadLogFileCounter, 1)

	if mmUploadLogFile.inspectFuncUploadLogFile != nil {
		mmUploadLogFile.inspectFuncUploadLogFile(payload)
	}

	mm_params := &LogUploaderMockUploadLogFileParams{payload}

	// Record call args
	mmUploadLogFile.UploadLogFileMock.mutex.Lock()
	mmUploadLogFile.UploadLogFileMock.callArgs = append(mmUploadLogFile.UploadLogFileMock.callArgs, mm_params)
	mmUploadLogFile.UploadLogFileMock.mutex.Unlock()

	for _, e := range mmUploadLogFile.UploadLogFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadLogFile.UploadLogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadLogFile.UploadLogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadLogFile.UploadLogFileMock.defaultExpectation.params
		mm_got := LogUploaderMockUploadLogFileParams{payload}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadLogFile.t.Errorf("LogUploaderMock.UploadLogFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadLogFile.UploadLogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadLogFile.t.Fatal("No results are set for the LogUploaderMock.UploadLogFile")
		}
		return (*mm_results).err
	}
	if mmUploadLogFile.funcUploadLogFile != nil {
		return mmUploadLogFile.funcUploadLogFile(payload)
	}
	mmUploadLogFile.t.Fatalf("Unexpected call to LogUploaderMock.UploadLogFile. %v", payload)
	return
}

// UploadLogFileAfterCounter returns a count of finished LogUploaderMock.UploadLogFile invocations
func (mmUploadLogFile *LogUploaderMock) UploadLogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadLogFile.afterUploadLogFileCounter)
}

// UploadLogFileBeforeCounter returns a count of LogUploaderMock.UploadLogFile invocations
func (mmUploadLogFile *LogUploaderMock) UploadLogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadLogFile.beforeUploadLogFileCounter)
}

// Calls returns a list of arguments used in each call to LogUploaderMock.UploadLogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadLogFile *mLogUploaderMockUploadLogFile) Calls() []*LogUploaderMockUploadLogFileParams {
	mmUploadLogFile.mutex.RLock()

	argCopy := make([]*LogUploaderMockUploadLogFileParams, len(mmUploadLogFile.callArgs))
	copy(argCopy, mmUploadLogFile.callArgs)

	mmUploadLogFile.mutex.RUnlock()

	return argCopy
}

// MinimockUploadLogFileDone returns true if the count of the UploadLogFile invocations corresponds
// the number of defined expectations
func (m *LogUploaderMock) MinimockUploadLogFileDone() bool {
	for _, e := range m.UploadLogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UploadLogFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadLogFile != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockUploadLogFileInspect logs each unmet expectation
func (m *LogUploaderMock) MinimockUploadLogFileInspect() {
	for _, e := range m.UploadLogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogUploaderMock.UploadLogFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UploadLogFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		if m.UploadLogFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogUploaderMock.UploadLogFile")
		} else {
			m.t.Errorf("Expected call to LogUploaderMock.UploadLogFile with params: %#v", *m.UploadLogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadLogFile != nil && mm_atomic.LoadUint64(&m.afterUploadLogFileCounter) < 1 {
		m.t.Error("Expected call to LogUploaderMock.UploadLogFile")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LogUploaderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockFindMatchingPickupInspect()

		m.MinimockMakeMultipartMapInspect()

		m.MinimockResolvePlayersInspect()

		m.MinimockUploadLogFileInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LogUploaderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LogUploaderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFindMatchingPickupDone() &&
		m.MinimockMakeMultipartMapDone() &&
		m.MinimockResolvePlayersDone() &&
		m.MinimockUploadLogFileDone()
}
