package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/server.LogFiler -o LogWatcher/pkg/mocks/log_manager_mock.go

import (
	mm_server "LogWatcher/pkg/server"
	"bytes"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"go.mongodb.org/mongo-driver/mongo"
)

// LogManagerMock implements server.LogFiler
type LogManagerMock struct {
	t minimock.Tester

	funcBuffer          func() (b1 bytes.Buffer)
	inspectFuncBuffer   func()
	afterBufferCounter  uint64
	beforeBufferCounter uint64
	BufferMock          mLogManagerMockBuffer

	funcChannel          func() (ch1 chan string)
	inspectFuncChannel   func()
	afterChannelCounter  uint64
	beforeChannelCounter uint64
	ChannelMock          mLogManagerMockChannel

	funcFlushBuffer          func()
	inspectFuncFlushBuffer   func()
	afterFlushBufferCounter  uint64
	beforeFlushBufferCounter uint64
	FlushBufferMock          mLogManagerMockFlushBuffer

	funcGetConn          func() (cp1 *mongo.Client)
	inspectFuncGetConn   func()
	afterGetConnCounter  uint64
	beforeGetConnCounter uint64
	GetConnMock          mLogManagerMockGetConn

	funcLock          func()
	inspectFuncLock   func()
	afterLockCounter  uint64
	beforeLockCounter uint64
	LockMock          mLogManagerMockLock

	funcSetState          func(state mm_server.StateType)
	inspectFuncSetState   func(state mm_server.StateType)
	afterSetStateCounter  uint64
	beforeSetStateCounter uint64
	SetStateMock          mLogManagerMockSetState

	funcState          func() (s1 mm_server.StateType)
	inspectFuncState   func()
	afterStateCounter  uint64
	beforeStateCounter uint64
	StateMock          mLogManagerMockState

	funcUnlock          func()
	inspectFuncUnlock   func()
	afterUnlockCounter  uint64
	beforeUnlockCounter uint64
	UnlockMock          mLogManagerMockUnlock

	funcWriteLine          func(msg string)
	inspectFuncWriteLine   func(msg string)
	afterWriteLineCounter  uint64
	beforeWriteLineCounter uint64
	WriteLineMock          mLogManagerMockWriteLine
}

// NewLogManagerMock returns a mock for server.LogFiler
func NewLogManagerMock(t minimock.Tester) *LogManagerMock {
	m := &LogManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BufferMock = mLogManagerMockBuffer{mock: m}

	m.ChannelMock = mLogManagerMockChannel{mock: m}

	m.FlushBufferMock = mLogManagerMockFlushBuffer{mock: m}

	m.GetConnMock = mLogManagerMockGetConn{mock: m}

	m.LockMock = mLogManagerMockLock{mock: m}

	m.SetStateMock = mLogManagerMockSetState{mock: m}
	m.SetStateMock.callArgs = []*LogManagerMockSetStateParams{}

	m.StateMock = mLogManagerMockState{mock: m}

	m.UnlockMock = mLogManagerMockUnlock{mock: m}

	m.WriteLineMock = mLogManagerMockWriteLine{mock: m}
	m.WriteLineMock.callArgs = []*LogManagerMockWriteLineParams{}

	return m
}

type mLogManagerMockBuffer struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockBufferExpectation
	expectations       []*LogManagerMockBufferExpectation
}

// LogManagerMockBufferExpectation specifies expectation struct of the LogFiler.Buffer
type LogManagerMockBufferExpectation struct {
	mock *LogManagerMock

	results *LogManagerMockBufferResults
	Counter uint64
}

// LogManagerMockBufferResults contains results of the LogFiler.Buffer
type LogManagerMockBufferResults struct {
	b1 bytes.Buffer
}

// Expect sets up expected params for LogFiler.Buffer
func (mmBuffer *mLogManagerMockBuffer) Expect() *mLogManagerMockBuffer {
	if mmBuffer.mock.funcBuffer != nil {
		mmBuffer.mock.t.Fatalf("LogManagerMock.Buffer mock is already set by Set")
	}

	if mmBuffer.defaultExpectation == nil {
		mmBuffer.defaultExpectation = &LogManagerMockBufferExpectation{}
	}

	return mmBuffer
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Buffer
func (mmBuffer *mLogManagerMockBuffer) Inspect(f func()) *mLogManagerMockBuffer {
	if mmBuffer.mock.inspectFuncBuffer != nil {
		mmBuffer.mock.t.Fatalf("Inspect function is already set for LogManagerMock.Buffer")
	}

	mmBuffer.mock.inspectFuncBuffer = f

	return mmBuffer
}

// Return sets up results that will be returned by LogFiler.Buffer
func (mmBuffer *mLogManagerMockBuffer) Return(b1 bytes.Buffer) *LogManagerMock {
	if mmBuffer.mock.funcBuffer != nil {
		mmBuffer.mock.t.Fatalf("LogManagerMock.Buffer mock is already set by Set")
	}

	if mmBuffer.defaultExpectation == nil {
		mmBuffer.defaultExpectation = &LogManagerMockBufferExpectation{mock: mmBuffer.mock}
	}
	mmBuffer.defaultExpectation.results = &LogManagerMockBufferResults{b1}
	return mmBuffer.mock
}

//Set uses given function f to mock the LogFiler.Buffer method
func (mmBuffer *mLogManagerMockBuffer) Set(f func() (b1 bytes.Buffer)) *LogManagerMock {
	if mmBuffer.defaultExpectation != nil {
		mmBuffer.mock.t.Fatalf("Default expectation is already set for the LogFiler.Buffer method")
	}

	if len(mmBuffer.expectations) > 0 {
		mmBuffer.mock.t.Fatalf("Some expectations are already set for the LogFiler.Buffer method")
	}

	mmBuffer.mock.funcBuffer = f
	return mmBuffer.mock
}

// Buffer implements server.LogFiler
func (mmBuffer *LogManagerMock) Buffer() (b1 bytes.Buffer) {
	mm_atomic.AddUint64(&mmBuffer.beforeBufferCounter, 1)
	defer mm_atomic.AddUint64(&mmBuffer.afterBufferCounter, 1)

	if mmBuffer.inspectFuncBuffer != nil {
		mmBuffer.inspectFuncBuffer()
	}

	if mmBuffer.BufferMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuffer.BufferMock.defaultExpectation.Counter, 1)

		mm_results := mmBuffer.BufferMock.defaultExpectation.results
		if mm_results == nil {
			mmBuffer.t.Fatal("No results are set for the LogManagerMock.Buffer")
		}
		return (*mm_results).b1
	}
	if mmBuffer.funcBuffer != nil {
		return mmBuffer.funcBuffer()
	}
	mmBuffer.t.Fatalf("Unexpected call to LogManagerMock.Buffer.")
	return
}

// BufferAfterCounter returns a count of finished LogManagerMock.Buffer invocations
func (mmBuffer *LogManagerMock) BufferAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuffer.afterBufferCounter)
}

// BufferBeforeCounter returns a count of LogManagerMock.Buffer invocations
func (mmBuffer *LogManagerMock) BufferBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuffer.beforeBufferCounter)
}

// MinimockBufferDone returns true if the count of the Buffer invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockBufferDone() bool {
	for _, e := range m.BufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuffer != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		return false
	}
	return true
}

// MinimockBufferInspect logs each unmet expectation
func (m *LogManagerMock) MinimockBufferInspect() {
	for _, e := range m.BufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogManagerMock.Buffer")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.Buffer")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuffer != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.Buffer")
	}
}

type mLogManagerMockChannel struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockChannelExpectation
	expectations       []*LogManagerMockChannelExpectation
}

// LogManagerMockChannelExpectation specifies expectation struct of the LogFiler.Channel
type LogManagerMockChannelExpectation struct {
	mock *LogManagerMock

	results *LogManagerMockChannelResults
	Counter uint64
}

// LogManagerMockChannelResults contains results of the LogFiler.Channel
type LogManagerMockChannelResults struct {
	ch1 chan string
}

// Expect sets up expected params for LogFiler.Channel
func (mmChannel *mLogManagerMockChannel) Expect() *mLogManagerMockChannel {
	if mmChannel.mock.funcChannel != nil {
		mmChannel.mock.t.Fatalf("LogManagerMock.Channel mock is already set by Set")
	}

	if mmChannel.defaultExpectation == nil {
		mmChannel.defaultExpectation = &LogManagerMockChannelExpectation{}
	}

	return mmChannel
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Channel
func (mmChannel *mLogManagerMockChannel) Inspect(f func()) *mLogManagerMockChannel {
	if mmChannel.mock.inspectFuncChannel != nil {
		mmChannel.mock.t.Fatalf("Inspect function is already set for LogManagerMock.Channel")
	}

	mmChannel.mock.inspectFuncChannel = f

	return mmChannel
}

// Return sets up results that will be returned by LogFiler.Channel
func (mmChannel *mLogManagerMockChannel) Return(ch1 chan string) *LogManagerMock {
	if mmChannel.mock.funcChannel != nil {
		mmChannel.mock.t.Fatalf("LogManagerMock.Channel mock is already set by Set")
	}

	if mmChannel.defaultExpectation == nil {
		mmChannel.defaultExpectation = &LogManagerMockChannelExpectation{mock: mmChannel.mock}
	}
	mmChannel.defaultExpectation.results = &LogManagerMockChannelResults{ch1}
	return mmChannel.mock
}

//Set uses given function f to mock the LogFiler.Channel method
func (mmChannel *mLogManagerMockChannel) Set(f func() (ch1 chan string)) *LogManagerMock {
	if mmChannel.defaultExpectation != nil {
		mmChannel.mock.t.Fatalf("Default expectation is already set for the LogFiler.Channel method")
	}

	if len(mmChannel.expectations) > 0 {
		mmChannel.mock.t.Fatalf("Some expectations are already set for the LogFiler.Channel method")
	}

	mmChannel.mock.funcChannel = f
	return mmChannel.mock
}

// Channel implements server.LogFiler
func (mmChannel *LogManagerMock) Channel() (ch1 chan string) {
	mm_atomic.AddUint64(&mmChannel.beforeChannelCounter, 1)
	defer mm_atomic.AddUint64(&mmChannel.afterChannelCounter, 1)

	if mmChannel.inspectFuncChannel != nil {
		mmChannel.inspectFuncChannel()
	}

	if mmChannel.ChannelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChannel.ChannelMock.defaultExpectation.Counter, 1)

		mm_results := mmChannel.ChannelMock.defaultExpectation.results
		if mm_results == nil {
			mmChannel.t.Fatal("No results are set for the LogManagerMock.Channel")
		}
		return (*mm_results).ch1
	}
	if mmChannel.funcChannel != nil {
		return mmChannel.funcChannel()
	}
	mmChannel.t.Fatalf("Unexpected call to LogManagerMock.Channel.")
	return
}

// ChannelAfterCounter returns a count of finished LogManagerMock.Channel invocations
func (mmChannel *LogManagerMock) ChannelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChannel.afterChannelCounter)
}

// ChannelBeforeCounter returns a count of LogManagerMock.Channel invocations
func (mmChannel *LogManagerMock) ChannelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChannel.beforeChannelCounter)
}

// MinimockChannelDone returns true if the count of the Channel invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockChannelDone() bool {
	for _, e := range m.ChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChannelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChannel != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		return false
	}
	return true
}

// MinimockChannelInspect logs each unmet expectation
func (m *LogManagerMock) MinimockChannelInspect() {
	for _, e := range m.ChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogManagerMock.Channel")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChannelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.Channel")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChannel != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.Channel")
	}
}

type mLogManagerMockFlushBuffer struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockFlushBufferExpectation
	expectations       []*LogManagerMockFlushBufferExpectation
}

// LogManagerMockFlushBufferExpectation specifies expectation struct of the LogFiler.FlushBuffer
type LogManagerMockFlushBufferExpectation struct {
	mock *LogManagerMock

	Counter uint64
}

// Expect sets up expected params for LogFiler.FlushBuffer
func (mmFlushBuffer *mLogManagerMockFlushBuffer) Expect() *mLogManagerMockFlushBuffer {
	if mmFlushBuffer.mock.funcFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("LogManagerMock.FlushBuffer mock is already set by Set")
	}

	if mmFlushBuffer.defaultExpectation == nil {
		mmFlushBuffer.defaultExpectation = &LogManagerMockFlushBufferExpectation{}
	}

	return mmFlushBuffer
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.FlushBuffer
func (mmFlushBuffer *mLogManagerMockFlushBuffer) Inspect(f func()) *mLogManagerMockFlushBuffer {
	if mmFlushBuffer.mock.inspectFuncFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("Inspect function is already set for LogManagerMock.FlushBuffer")
	}

	mmFlushBuffer.mock.inspectFuncFlushBuffer = f

	return mmFlushBuffer
}

// Return sets up results that will be returned by LogFiler.FlushBuffer
func (mmFlushBuffer *mLogManagerMockFlushBuffer) Return() *LogManagerMock {
	if mmFlushBuffer.mock.funcFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("LogManagerMock.FlushBuffer mock is already set by Set")
	}

	if mmFlushBuffer.defaultExpectation == nil {
		mmFlushBuffer.defaultExpectation = &LogManagerMockFlushBufferExpectation{mock: mmFlushBuffer.mock}
	}

	return mmFlushBuffer.mock
}

//Set uses given function f to mock the LogFiler.FlushBuffer method
func (mmFlushBuffer *mLogManagerMockFlushBuffer) Set(f func()) *LogManagerMock {
	if mmFlushBuffer.defaultExpectation != nil {
		mmFlushBuffer.mock.t.Fatalf("Default expectation is already set for the LogFiler.FlushBuffer method")
	}

	if len(mmFlushBuffer.expectations) > 0 {
		mmFlushBuffer.mock.t.Fatalf("Some expectations are already set for the LogFiler.FlushBuffer method")
	}

	mmFlushBuffer.mock.funcFlushBuffer = f
	return mmFlushBuffer.mock
}

// FlushBuffer implements server.LogFiler
func (mmFlushBuffer *LogManagerMock) FlushBuffer() {
	mm_atomic.AddUint64(&mmFlushBuffer.beforeFlushBufferCounter, 1)
	defer mm_atomic.AddUint64(&mmFlushBuffer.afterFlushBufferCounter, 1)

	if mmFlushBuffer.inspectFuncFlushBuffer != nil {
		mmFlushBuffer.inspectFuncFlushBuffer()
	}

	if mmFlushBuffer.FlushBufferMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlushBuffer.FlushBufferMock.defaultExpectation.Counter, 1)

		return

	}
	if mmFlushBuffer.funcFlushBuffer != nil {
		mmFlushBuffer.funcFlushBuffer()
		return
	}
	mmFlushBuffer.t.Fatalf("Unexpected call to LogManagerMock.FlushBuffer.")

}

// FlushBufferAfterCounter returns a count of finished LogManagerMock.FlushBuffer invocations
func (mmFlushBuffer *LogManagerMock) FlushBufferAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushBuffer.afterFlushBufferCounter)
}

// FlushBufferBeforeCounter returns a count of LogManagerMock.FlushBuffer invocations
func (mmFlushBuffer *LogManagerMock) FlushBufferBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushBuffer.beforeFlushBufferCounter)
}

// MinimockFlushBufferDone returns true if the count of the FlushBuffer invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockFlushBufferDone() bool {
	for _, e := range m.FlushBufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushBufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushBuffer != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		return false
	}
	return true
}

// MinimockFlushBufferInspect logs each unmet expectation
func (m *LogManagerMock) MinimockFlushBufferInspect() {
	for _, e := range m.FlushBufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogManagerMock.FlushBuffer")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushBufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.FlushBuffer")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushBuffer != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.FlushBuffer")
	}
}

type mLogManagerMockGetConn struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockGetConnExpectation
	expectations       []*LogManagerMockGetConnExpectation
}

// LogManagerMockGetConnExpectation specifies expectation struct of the LogFiler.GetConn
type LogManagerMockGetConnExpectation struct {
	mock *LogManagerMock

	results *LogManagerMockGetConnResults
	Counter uint64
}

// LogManagerMockGetConnResults contains results of the LogFiler.GetConn
type LogManagerMockGetConnResults struct {
	cp1 *mongo.Client
}

// Expect sets up expected params for LogFiler.GetConn
func (mmGetConn *mLogManagerMockGetConn) Expect() *mLogManagerMockGetConn {
	if mmGetConn.mock.funcGetConn != nil {
		mmGetConn.mock.t.Fatalf("LogManagerMock.GetConn mock is already set by Set")
	}

	if mmGetConn.defaultExpectation == nil {
		mmGetConn.defaultExpectation = &LogManagerMockGetConnExpectation{}
	}

	return mmGetConn
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.GetConn
func (mmGetConn *mLogManagerMockGetConn) Inspect(f func()) *mLogManagerMockGetConn {
	if mmGetConn.mock.inspectFuncGetConn != nil {
		mmGetConn.mock.t.Fatalf("Inspect function is already set for LogManagerMock.GetConn")
	}

	mmGetConn.mock.inspectFuncGetConn = f

	return mmGetConn
}

// Return sets up results that will be returned by LogFiler.GetConn
func (mmGetConn *mLogManagerMockGetConn) Return(cp1 *mongo.Client) *LogManagerMock {
	if mmGetConn.mock.funcGetConn != nil {
		mmGetConn.mock.t.Fatalf("LogManagerMock.GetConn mock is already set by Set")
	}

	if mmGetConn.defaultExpectation == nil {
		mmGetConn.defaultExpectation = &LogManagerMockGetConnExpectation{mock: mmGetConn.mock}
	}
	mmGetConn.defaultExpectation.results = &LogManagerMockGetConnResults{cp1}
	return mmGetConn.mock
}

//Set uses given function f to mock the LogFiler.GetConn method
func (mmGetConn *mLogManagerMockGetConn) Set(f func() (cp1 *mongo.Client)) *LogManagerMock {
	if mmGetConn.defaultExpectation != nil {
		mmGetConn.mock.t.Fatalf("Default expectation is already set for the LogFiler.GetConn method")
	}

	if len(mmGetConn.expectations) > 0 {
		mmGetConn.mock.t.Fatalf("Some expectations are already set for the LogFiler.GetConn method")
	}

	mmGetConn.mock.funcGetConn = f
	return mmGetConn.mock
}

// GetConn implements server.LogFiler
func (mmGetConn *LogManagerMock) GetConn() (cp1 *mongo.Client) {
	mm_atomic.AddUint64(&mmGetConn.beforeGetConnCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConn.afterGetConnCounter, 1)

	if mmGetConn.inspectFuncGetConn != nil {
		mmGetConn.inspectFuncGetConn()
	}

	if mmGetConn.GetConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConn.GetConnMock.defaultExpectation.Counter, 1)

		mm_results := mmGetConn.GetConnMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConn.t.Fatal("No results are set for the LogManagerMock.GetConn")
		}
		return (*mm_results).cp1
	}
	if mmGetConn.funcGetConn != nil {
		return mmGetConn.funcGetConn()
	}
	mmGetConn.t.Fatalf("Unexpected call to LogManagerMock.GetConn.")
	return
}

// GetConnAfterCounter returns a count of finished LogManagerMock.GetConn invocations
func (mmGetConn *LogManagerMock) GetConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConn.afterGetConnCounter)
}

// GetConnBeforeCounter returns a count of LogManagerMock.GetConn invocations
func (mmGetConn *LogManagerMock) GetConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConn.beforeGetConnCounter)
}

// MinimockGetConnDone returns true if the count of the GetConn invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockGetConnDone() bool {
	for _, e := range m.GetConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConn != nil && mm_atomic.LoadUint64(&m.afterGetConnCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetConnInspect logs each unmet expectation
func (m *LogManagerMock) MinimockGetConnInspect() {
	for _, e := range m.GetConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogManagerMock.GetConn")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConnCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.GetConn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConn != nil && mm_atomic.LoadUint64(&m.afterGetConnCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.GetConn")
	}
}

type mLogManagerMockLock struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockLockExpectation
	expectations       []*LogManagerMockLockExpectation
}

// LogManagerMockLockExpectation specifies expectation struct of the LogFiler.Lock
type LogManagerMockLockExpectation struct {
	mock *LogManagerMock

	Counter uint64
}

// Expect sets up expected params for LogFiler.Lock
func (mmLock *mLogManagerMockLock) Expect() *mLogManagerMockLock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("LogManagerMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &LogManagerMockLockExpectation{}
	}

	return mmLock
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Lock
func (mmLock *mLogManagerMockLock) Inspect(f func()) *mLogManagerMockLock {
	if mmLock.mock.inspectFuncLock != nil {
		mmLock.mock.t.Fatalf("Inspect function is already set for LogManagerMock.Lock")
	}

	mmLock.mock.inspectFuncLock = f

	return mmLock
}

// Return sets up results that will be returned by LogFiler.Lock
func (mmLock *mLogManagerMockLock) Return() *LogManagerMock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("LogManagerMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &LogManagerMockLockExpectation{mock: mmLock.mock}
	}

	return mmLock.mock
}

//Set uses given function f to mock the LogFiler.Lock method
func (mmLock *mLogManagerMockLock) Set(f func()) *LogManagerMock {
	if mmLock.defaultExpectation != nil {
		mmLock.mock.t.Fatalf("Default expectation is already set for the LogFiler.Lock method")
	}

	if len(mmLock.expectations) > 0 {
		mmLock.mock.t.Fatalf("Some expectations are already set for the LogFiler.Lock method")
	}

	mmLock.mock.funcLock = f
	return mmLock.mock
}

// Lock implements server.LogFiler
func (mmLock *LogManagerMock) Lock() {
	mm_atomic.AddUint64(&mmLock.beforeLockCounter, 1)
	defer mm_atomic.AddUint64(&mmLock.afterLockCounter, 1)

	if mmLock.inspectFuncLock != nil {
		mmLock.inspectFuncLock()
	}

	if mmLock.LockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLock.LockMock.defaultExpectation.Counter, 1)

		return

	}
	if mmLock.funcLock != nil {
		mmLock.funcLock()
		return
	}
	mmLock.t.Fatalf("Unexpected call to LogManagerMock.Lock.")

}

// LockAfterCounter returns a count of finished LogManagerMock.Lock invocations
func (mmLock *LogManagerMock) LockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.afterLockCounter)
}

// LockBeforeCounter returns a count of LogManagerMock.Lock invocations
func (mmLock *LogManagerMock) LockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.beforeLockCounter)
}

// MinimockLockDone returns true if the count of the Lock invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockLockDone() bool {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	return true
}

// MinimockLockInspect logs each unmet expectation
func (m *LogManagerMock) MinimockLockInspect() {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogManagerMock.Lock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.Lock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.Lock")
	}
}

type mLogManagerMockSetState struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockSetStateExpectation
	expectations       []*LogManagerMockSetStateExpectation

	callArgs []*LogManagerMockSetStateParams
	mutex    sync.RWMutex
}

// LogManagerMockSetStateExpectation specifies expectation struct of the LogFiler.SetState
type LogManagerMockSetStateExpectation struct {
	mock   *LogManagerMock
	params *LogManagerMockSetStateParams

	Counter uint64
}

// LogManagerMockSetStateParams contains parameters of the LogFiler.SetState
type LogManagerMockSetStateParams struct {
	state mm_server.StateType
}

// Expect sets up expected params for LogFiler.SetState
func (mmSetState *mLogManagerMockSetState) Expect(state mm_server.StateType) *mLogManagerMockSetState {
	if mmSetState.mock.funcSetState != nil {
		mmSetState.mock.t.Fatalf("LogManagerMock.SetState mock is already set by Set")
	}

	if mmSetState.defaultExpectation == nil {
		mmSetState.defaultExpectation = &LogManagerMockSetStateExpectation{}
	}

	mmSetState.defaultExpectation.params = &LogManagerMockSetStateParams{state}
	for _, e := range mmSetState.expectations {
		if minimock.Equal(e.params, mmSetState.defaultExpectation.params) {
			mmSetState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetState.defaultExpectation.params)
		}
	}

	return mmSetState
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.SetState
func (mmSetState *mLogManagerMockSetState) Inspect(f func(state mm_server.StateType)) *mLogManagerMockSetState {
	if mmSetState.mock.inspectFuncSetState != nil {
		mmSetState.mock.t.Fatalf("Inspect function is already set for LogManagerMock.SetState")
	}

	mmSetState.mock.inspectFuncSetState = f

	return mmSetState
}

// Return sets up results that will be returned by LogFiler.SetState
func (mmSetState *mLogManagerMockSetState) Return() *LogManagerMock {
	if mmSetState.mock.funcSetState != nil {
		mmSetState.mock.t.Fatalf("LogManagerMock.SetState mock is already set by Set")
	}

	if mmSetState.defaultExpectation == nil {
		mmSetState.defaultExpectation = &LogManagerMockSetStateExpectation{mock: mmSetState.mock}
	}

	return mmSetState.mock
}

//Set uses given function f to mock the LogFiler.SetState method
func (mmSetState *mLogManagerMockSetState) Set(f func(state mm_server.StateType)) *LogManagerMock {
	if mmSetState.defaultExpectation != nil {
		mmSetState.mock.t.Fatalf("Default expectation is already set for the LogFiler.SetState method")
	}

	if len(mmSetState.expectations) > 0 {
		mmSetState.mock.t.Fatalf("Some expectations are already set for the LogFiler.SetState method")
	}

	mmSetState.mock.funcSetState = f
	return mmSetState.mock
}

// SetState implements server.LogFiler
func (mmSetState *LogManagerMock) SetState(state mm_server.StateType) {
	mm_atomic.AddUint64(&mmSetState.beforeSetStateCounter, 1)
	defer mm_atomic.AddUint64(&mmSetState.afterSetStateCounter, 1)

	if mmSetState.inspectFuncSetState != nil {
		mmSetState.inspectFuncSetState(state)
	}

	mm_params := &LogManagerMockSetStateParams{state}

	// Record call args
	mmSetState.SetStateMock.mutex.Lock()
	mmSetState.SetStateMock.callArgs = append(mmSetState.SetStateMock.callArgs, mm_params)
	mmSetState.SetStateMock.mutex.Unlock()

	for _, e := range mmSetState.SetStateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetState.SetStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetState.SetStateMock.defaultExpectation.Counter, 1)
		mm_want := mmSetState.SetStateMock.defaultExpectation.params
		mm_got := LogManagerMockSetStateParams{state}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetState.t.Errorf("LogManagerMock.SetState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetState.funcSetState != nil {
		mmSetState.funcSetState(state)
		return
	}
	mmSetState.t.Fatalf("Unexpected call to LogManagerMock.SetState. %v", state)

}

// SetStateAfterCounter returns a count of finished LogManagerMock.SetState invocations
func (mmSetState *LogManagerMock) SetStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetState.afterSetStateCounter)
}

// SetStateBeforeCounter returns a count of LogManagerMock.SetState invocations
func (mmSetState *LogManagerMock) SetStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetState.beforeSetStateCounter)
}

// Calls returns a list of arguments used in each call to LogManagerMock.SetState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetState *mLogManagerMockSetState) Calls() []*LogManagerMockSetStateParams {
	mmSetState.mutex.RLock()

	argCopy := make([]*LogManagerMockSetStateParams, len(mmSetState.callArgs))
	copy(argCopy, mmSetState.callArgs)

	mmSetState.mutex.RUnlock()

	return argCopy
}

// MinimockSetStateDone returns true if the count of the SetState invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockSetStateDone() bool {
	for _, e := range m.SetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetState != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStateInspect logs each unmet expectation
func (m *LogManagerMock) MinimockSetStateInspect() {
	for _, e := range m.SetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogManagerMock.SetState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		if m.SetStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogManagerMock.SetState")
		} else {
			m.t.Errorf("Expected call to LogManagerMock.SetState with params: %#v", *m.SetStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetState != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.SetState")
	}
}

type mLogManagerMockState struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockStateExpectation
	expectations       []*LogManagerMockStateExpectation
}

// LogManagerMockStateExpectation specifies expectation struct of the LogFiler.State
type LogManagerMockStateExpectation struct {
	mock *LogManagerMock

	results *LogManagerMockStateResults
	Counter uint64
}

// LogManagerMockStateResults contains results of the LogFiler.State
type LogManagerMockStateResults struct {
	s1 mm_server.StateType
}

// Expect sets up expected params for LogFiler.State
func (mmState *mLogManagerMockState) Expect() *mLogManagerMockState {
	if mmState.mock.funcState != nil {
		mmState.mock.t.Fatalf("LogManagerMock.State mock is already set by Set")
	}

	if mmState.defaultExpectation == nil {
		mmState.defaultExpectation = &LogManagerMockStateExpectation{}
	}

	return mmState
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.State
func (mmState *mLogManagerMockState) Inspect(f func()) *mLogManagerMockState {
	if mmState.mock.inspectFuncState != nil {
		mmState.mock.t.Fatalf("Inspect function is already set for LogManagerMock.State")
	}

	mmState.mock.inspectFuncState = f

	return mmState
}

// Return sets up results that will be returned by LogFiler.State
func (mmState *mLogManagerMockState) Return(s1 mm_server.StateType) *LogManagerMock {
	if mmState.mock.funcState != nil {
		mmState.mock.t.Fatalf("LogManagerMock.State mock is already set by Set")
	}

	if mmState.defaultExpectation == nil {
		mmState.defaultExpectation = &LogManagerMockStateExpectation{mock: mmState.mock}
	}
	mmState.defaultExpectation.results = &LogManagerMockStateResults{s1}
	return mmState.mock
}

//Set uses given function f to mock the LogFiler.State method
func (mmState *mLogManagerMockState) Set(f func() (s1 mm_server.StateType)) *LogManagerMock {
	if mmState.defaultExpectation != nil {
		mmState.mock.t.Fatalf("Default expectation is already set for the LogFiler.State method")
	}

	if len(mmState.expectations) > 0 {
		mmState.mock.t.Fatalf("Some expectations are already set for the LogFiler.State method")
	}

	mmState.mock.funcState = f
	return mmState.mock
}

// State implements server.LogFiler
func (mmState *LogManagerMock) State() (s1 mm_server.StateType) {
	mm_atomic.AddUint64(&mmState.beforeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmState.afterStateCounter, 1)

	if mmState.inspectFuncState != nil {
		mmState.inspectFuncState()
	}

	if mmState.StateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmState.StateMock.defaultExpectation.Counter, 1)

		mm_results := mmState.StateMock.defaultExpectation.results
		if mm_results == nil {
			mmState.t.Fatal("No results are set for the LogManagerMock.State")
		}
		return (*mm_results).s1
	}
	if mmState.funcState != nil {
		return mmState.funcState()
	}
	mmState.t.Fatalf("Unexpected call to LogManagerMock.State.")
	return
}

// StateAfterCounter returns a count of finished LogManagerMock.State invocations
func (mmState *LogManagerMock) StateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmState.afterStateCounter)
}

// StateBeforeCounter returns a count of LogManagerMock.State invocations
func (mmState *LogManagerMock) StateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmState.beforeStateCounter)
}

// MinimockStateDone returns true if the count of the State invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockStateDone() bool {
	for _, e := range m.StateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcState != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockStateInspect logs each unmet expectation
func (m *LogManagerMock) MinimockStateInspect() {
	for _, e := range m.StateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogManagerMock.State")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.State")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcState != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.State")
	}
}

type mLogManagerMockUnlock struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockUnlockExpectation
	expectations       []*LogManagerMockUnlockExpectation
}

// LogManagerMockUnlockExpectation specifies expectation struct of the LogFiler.Unlock
type LogManagerMockUnlockExpectation struct {
	mock *LogManagerMock

	Counter uint64
}

// Expect sets up expected params for LogFiler.Unlock
func (mmUnlock *mLogManagerMockUnlock) Expect() *mLogManagerMockUnlock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("LogManagerMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &LogManagerMockUnlockExpectation{}
	}

	return mmUnlock
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Unlock
func (mmUnlock *mLogManagerMockUnlock) Inspect(f func()) *mLogManagerMockUnlock {
	if mmUnlock.mock.inspectFuncUnlock != nil {
		mmUnlock.mock.t.Fatalf("Inspect function is already set for LogManagerMock.Unlock")
	}

	mmUnlock.mock.inspectFuncUnlock = f

	return mmUnlock
}

// Return sets up results that will be returned by LogFiler.Unlock
func (mmUnlock *mLogManagerMockUnlock) Return() *LogManagerMock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("LogManagerMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &LogManagerMockUnlockExpectation{mock: mmUnlock.mock}
	}

	return mmUnlock.mock
}

//Set uses given function f to mock the LogFiler.Unlock method
func (mmUnlock *mLogManagerMockUnlock) Set(f func()) *LogManagerMock {
	if mmUnlock.defaultExpectation != nil {
		mmUnlock.mock.t.Fatalf("Default expectation is already set for the LogFiler.Unlock method")
	}

	if len(mmUnlock.expectations) > 0 {
		mmUnlock.mock.t.Fatalf("Some expectations are already set for the LogFiler.Unlock method")
	}

	mmUnlock.mock.funcUnlock = f
	return mmUnlock.mock
}

// Unlock implements server.LogFiler
func (mmUnlock *LogManagerMock) Unlock() {
	mm_atomic.AddUint64(&mmUnlock.beforeUnlockCounter, 1)
	defer mm_atomic.AddUint64(&mmUnlock.afterUnlockCounter, 1)

	if mmUnlock.inspectFuncUnlock != nil {
		mmUnlock.inspectFuncUnlock()
	}

	if mmUnlock.UnlockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnlock.UnlockMock.defaultExpectation.Counter, 1)

		return

	}
	if mmUnlock.funcUnlock != nil {
		mmUnlock.funcUnlock()
		return
	}
	mmUnlock.t.Fatalf("Unexpected call to LogManagerMock.Unlock.")

}

// UnlockAfterCounter returns a count of finished LogManagerMock.Unlock invocations
func (mmUnlock *LogManagerMock) UnlockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.afterUnlockCounter)
}

// UnlockBeforeCounter returns a count of LogManagerMock.Unlock invocations
func (mmUnlock *LogManagerMock) UnlockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.beforeUnlockCounter)
}

// MinimockUnlockDone returns true if the count of the Unlock invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockUnlockDone() bool {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnlockInspect logs each unmet expectation
func (m *LogManagerMock) MinimockUnlockInspect() {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogManagerMock.Unlock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.Unlock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.Unlock")
	}
}

type mLogManagerMockWriteLine struct {
	mock               *LogManagerMock
	defaultExpectation *LogManagerMockWriteLineExpectation
	expectations       []*LogManagerMockWriteLineExpectation

	callArgs []*LogManagerMockWriteLineParams
	mutex    sync.RWMutex
}

// LogManagerMockWriteLineExpectation specifies expectation struct of the LogFiler.WriteLine
type LogManagerMockWriteLineExpectation struct {
	mock   *LogManagerMock
	params *LogManagerMockWriteLineParams

	Counter uint64
}

// LogManagerMockWriteLineParams contains parameters of the LogFiler.WriteLine
type LogManagerMockWriteLineParams struct {
	msg string
}

// Expect sets up expected params for LogFiler.WriteLine
func (mmWriteLine *mLogManagerMockWriteLine) Expect(msg string) *mLogManagerMockWriteLine {
	if mmWriteLine.mock.funcWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("LogManagerMock.WriteLine mock is already set by Set")
	}

	if mmWriteLine.defaultExpectation == nil {
		mmWriteLine.defaultExpectation = &LogManagerMockWriteLineExpectation{}
	}

	mmWriteLine.defaultExpectation.params = &LogManagerMockWriteLineParams{msg}
	for _, e := range mmWriteLine.expectations {
		if minimock.Equal(e.params, mmWriteLine.defaultExpectation.params) {
			mmWriteLine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteLine.defaultExpectation.params)
		}
	}

	return mmWriteLine
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.WriteLine
func (mmWriteLine *mLogManagerMockWriteLine) Inspect(f func(msg string)) *mLogManagerMockWriteLine {
	if mmWriteLine.mock.inspectFuncWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("Inspect function is already set for LogManagerMock.WriteLine")
	}

	mmWriteLine.mock.inspectFuncWriteLine = f

	return mmWriteLine
}

// Return sets up results that will be returned by LogFiler.WriteLine
func (mmWriteLine *mLogManagerMockWriteLine) Return() *LogManagerMock {
	if mmWriteLine.mock.funcWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("LogManagerMock.WriteLine mock is already set by Set")
	}

	if mmWriteLine.defaultExpectation == nil {
		mmWriteLine.defaultExpectation = &LogManagerMockWriteLineExpectation{mock: mmWriteLine.mock}
	}

	return mmWriteLine.mock
}

//Set uses given function f to mock the LogFiler.WriteLine method
func (mmWriteLine *mLogManagerMockWriteLine) Set(f func(msg string)) *LogManagerMock {
	if mmWriteLine.defaultExpectation != nil {
		mmWriteLine.mock.t.Fatalf("Default expectation is already set for the LogFiler.WriteLine method")
	}

	if len(mmWriteLine.expectations) > 0 {
		mmWriteLine.mock.t.Fatalf("Some expectations are already set for the LogFiler.WriteLine method")
	}

	mmWriteLine.mock.funcWriteLine = f
	return mmWriteLine.mock
}

// WriteLine implements server.LogFiler
func (mmWriteLine *LogManagerMock) WriteLine(msg string) {
	mm_atomic.AddUint64(&mmWriteLine.beforeWriteLineCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteLine.afterWriteLineCounter, 1)

	if mmWriteLine.inspectFuncWriteLine != nil {
		mmWriteLine.inspectFuncWriteLine(msg)
	}

	mm_params := &LogManagerMockWriteLineParams{msg}

	// Record call args
	mmWriteLine.WriteLineMock.mutex.Lock()
	mmWriteLine.WriteLineMock.callArgs = append(mmWriteLine.WriteLineMock.callArgs, mm_params)
	mmWriteLine.WriteLineMock.mutex.Unlock()

	for _, e := range mmWriteLine.WriteLineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWriteLine.WriteLineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteLine.WriteLineMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteLine.WriteLineMock.defaultExpectation.params
		mm_got := LogManagerMockWriteLineParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteLine.t.Errorf("LogManagerMock.WriteLine got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWriteLine.funcWriteLine != nil {
		mmWriteLine.funcWriteLine(msg)
		return
	}
	mmWriteLine.t.Fatalf("Unexpected call to LogManagerMock.WriteLine. %v", msg)

}

// WriteLineAfterCounter returns a count of finished LogManagerMock.WriteLine invocations
func (mmWriteLine *LogManagerMock) WriteLineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteLine.afterWriteLineCounter)
}

// WriteLineBeforeCounter returns a count of LogManagerMock.WriteLine invocations
func (mmWriteLine *LogManagerMock) WriteLineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteLine.beforeWriteLineCounter)
}

// Calls returns a list of arguments used in each call to LogManagerMock.WriteLine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteLine *mLogManagerMockWriteLine) Calls() []*LogManagerMockWriteLineParams {
	mmWriteLine.mutex.RLock()

	argCopy := make([]*LogManagerMockWriteLineParams, len(mmWriteLine.callArgs))
	copy(argCopy, mmWriteLine.callArgs)

	mmWriteLine.mutex.RUnlock()

	return argCopy
}

// MinimockWriteLineDone returns true if the count of the WriteLine invocations corresponds
// the number of defined expectations
func (m *LogManagerMock) MinimockWriteLineDone() bool {
	for _, e := range m.WriteLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteLine != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteLineInspect logs each unmet expectation
func (m *LogManagerMock) MinimockWriteLineInspect() {
	for _, e := range m.WriteLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogManagerMock.WriteLine with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		if m.WriteLineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogManagerMock.WriteLine")
		} else {
			m.t.Errorf("Expected call to LogManagerMock.WriteLine with params: %#v", *m.WriteLineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteLine != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		m.t.Error("Expected call to LogManagerMock.WriteLine")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LogManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBufferInspect()

		m.MinimockChannelInspect()

		m.MinimockFlushBufferInspect()

		m.MinimockGetConnInspect()

		m.MinimockLockInspect()

		m.MinimockSetStateInspect()

		m.MinimockStateInspect()

		m.MinimockUnlockInspect()

		m.MinimockWriteLineInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LogManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LogManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBufferDone() &&
		m.MinimockChannelDone() &&
		m.MinimockFlushBufferDone() &&
		m.MinimockGetConnDone() &&
		m.MinimockLockDone() &&
		m.MinimockSetStateDone() &&
		m.MinimockStateDone() &&
		m.MinimockUnlockDone() &&
		m.MinimockWriteLineDone()
}
