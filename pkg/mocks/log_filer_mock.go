package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/server.LogFiler -o ./pkg/mocks/log_filer_mock.go

import (
	"bytes"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LogFilerMock implements server.LogFiler
type LogFilerMock struct {
	t minimock.Tester

	funcBuffer          func() (b1 bytes.Buffer)
	inspectFuncBuffer   func()
	afterBufferCounter  uint64
	beforeBufferCounter uint64
	BufferMock          mLogFilerMockBuffer

	funcFlushBuffer          func()
	inspectFuncFlushBuffer   func()
	afterFlushBufferCounter  uint64
	beforeFlushBufferCounter uint64
	FlushBufferMock          mLogFilerMockFlushBuffer

	funcName          func() (s1 string)
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mLogFilerMockName

	funcWriteLine          func(msg string)
	inspectFuncWriteLine   func(msg string)
	afterWriteLineCounter  uint64
	beforeWriteLineCounter uint64
	WriteLineMock          mLogFilerMockWriteLine
}

// NewLogFilerMock returns a mock for server.LogFiler
func NewLogFilerMock(t minimock.Tester) *LogFilerMock {
	m := &LogFilerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BufferMock = mLogFilerMockBuffer{mock: m}

	m.FlushBufferMock = mLogFilerMockFlushBuffer{mock: m}

	m.NameMock = mLogFilerMockName{mock: m}

	m.WriteLineMock = mLogFilerMockWriteLine{mock: m}
	m.WriteLineMock.callArgs = []*LogFilerMockWriteLineParams{}

	return m
}

type mLogFilerMockBuffer struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockBufferExpectation
	expectations       []*LogFilerMockBufferExpectation
}

// LogFilerMockBufferExpectation specifies expectation struct of the LogFiler.Buffer
type LogFilerMockBufferExpectation struct {
	mock *LogFilerMock

	results *LogFilerMockBufferResults
	Counter uint64
}

// LogFilerMockBufferResults contains results of the LogFiler.Buffer
type LogFilerMockBufferResults struct {
	b1 bytes.Buffer
}

// Expect sets up expected params for LogFiler.Buffer
func (mmBuffer *mLogFilerMockBuffer) Expect() *mLogFilerMockBuffer {
	if mmBuffer.mock.funcBuffer != nil {
		mmBuffer.mock.t.Fatalf("LogFilerMock.Buffer mock is already set by Set")
	}

	if mmBuffer.defaultExpectation == nil {
		mmBuffer.defaultExpectation = &LogFilerMockBufferExpectation{}
	}

	return mmBuffer
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Buffer
func (mmBuffer *mLogFilerMockBuffer) Inspect(f func()) *mLogFilerMockBuffer {
	if mmBuffer.mock.inspectFuncBuffer != nil {
		mmBuffer.mock.t.Fatalf("Inspect function is already set for LogFilerMock.Buffer")
	}

	mmBuffer.mock.inspectFuncBuffer = f

	return mmBuffer
}

// Return sets up results that will be returned by LogFiler.Buffer
func (mmBuffer *mLogFilerMockBuffer) Return(b1 bytes.Buffer) *LogFilerMock {
	if mmBuffer.mock.funcBuffer != nil {
		mmBuffer.mock.t.Fatalf("LogFilerMock.Buffer mock is already set by Set")
	}

	if mmBuffer.defaultExpectation == nil {
		mmBuffer.defaultExpectation = &LogFilerMockBufferExpectation{mock: mmBuffer.mock}
	}
	mmBuffer.defaultExpectation.results = &LogFilerMockBufferResults{b1}
	return mmBuffer.mock
}

//Set uses given function f to mock the LogFiler.Buffer method
func (mmBuffer *mLogFilerMockBuffer) Set(f func() (b1 bytes.Buffer)) *LogFilerMock {
	if mmBuffer.defaultExpectation != nil {
		mmBuffer.mock.t.Fatalf("Default expectation is already set for the LogFiler.Buffer method")
	}

	if len(mmBuffer.expectations) > 0 {
		mmBuffer.mock.t.Fatalf("Some expectations are already set for the LogFiler.Buffer method")
	}

	mmBuffer.mock.funcBuffer = f
	return mmBuffer.mock
}

// Buffer implements server.LogFiler
func (mmBuffer *LogFilerMock) Buffer() (b1 bytes.Buffer) {
	mm_atomic.AddUint64(&mmBuffer.beforeBufferCounter, 1)
	defer mm_atomic.AddUint64(&mmBuffer.afterBufferCounter, 1)

	if mmBuffer.inspectFuncBuffer != nil {
		mmBuffer.inspectFuncBuffer()
	}

	if mmBuffer.BufferMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuffer.BufferMock.defaultExpectation.Counter, 1)

		mm_results := mmBuffer.BufferMock.defaultExpectation.results
		if mm_results == nil {
			mmBuffer.t.Fatal("No results are set for the LogFilerMock.Buffer")
		}
		return (*mm_results).b1
	}
	if mmBuffer.funcBuffer != nil {
		return mmBuffer.funcBuffer()
	}
	mmBuffer.t.Fatalf("Unexpected call to LogFilerMock.Buffer.")
	return
}

// BufferAfterCounter returns a count of finished LogFilerMock.Buffer invocations
func (mmBuffer *LogFilerMock) BufferAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuffer.afterBufferCounter)
}

// BufferBeforeCounter returns a count of LogFilerMock.Buffer invocations
func (mmBuffer *LogFilerMock) BufferBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuffer.beforeBufferCounter)
}

// MinimockBufferDone returns true if the count of the Buffer invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockBufferDone() bool {
	for _, e := range m.BufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuffer != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		return false
	}
	return true
}

// MinimockBufferInspect logs each unmet expectation
func (m *LogFilerMock) MinimockBufferInspect() {
	for _, e := range m.BufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.Buffer")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Buffer")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuffer != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Buffer")
	}
}

type mLogFilerMockFlushBuffer struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockFlushBufferExpectation
	expectations       []*LogFilerMockFlushBufferExpectation
}

// LogFilerMockFlushBufferExpectation specifies expectation struct of the LogFiler.FlushBuffer
type LogFilerMockFlushBufferExpectation struct {
	mock *LogFilerMock

	Counter uint64
}

// Expect sets up expected params for LogFiler.FlushBuffer
func (mmFlushBuffer *mLogFilerMockFlushBuffer) Expect() *mLogFilerMockFlushBuffer {
	if mmFlushBuffer.mock.funcFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("LogFilerMock.FlushBuffer mock is already set by Set")
	}

	if mmFlushBuffer.defaultExpectation == nil {
		mmFlushBuffer.defaultExpectation = &LogFilerMockFlushBufferExpectation{}
	}

	return mmFlushBuffer
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.FlushBuffer
func (mmFlushBuffer *mLogFilerMockFlushBuffer) Inspect(f func()) *mLogFilerMockFlushBuffer {
	if mmFlushBuffer.mock.inspectFuncFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("Inspect function is already set for LogFilerMock.FlushBuffer")
	}

	mmFlushBuffer.mock.inspectFuncFlushBuffer = f

	return mmFlushBuffer
}

// Return sets up results that will be returned by LogFiler.FlushBuffer
func (mmFlushBuffer *mLogFilerMockFlushBuffer) Return() *LogFilerMock {
	if mmFlushBuffer.mock.funcFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("LogFilerMock.FlushBuffer mock is already set by Set")
	}

	if mmFlushBuffer.defaultExpectation == nil {
		mmFlushBuffer.defaultExpectation = &LogFilerMockFlushBufferExpectation{mock: mmFlushBuffer.mock}
	}

	return mmFlushBuffer.mock
}

//Set uses given function f to mock the LogFiler.FlushBuffer method
func (mmFlushBuffer *mLogFilerMockFlushBuffer) Set(f func()) *LogFilerMock {
	if mmFlushBuffer.defaultExpectation != nil {
		mmFlushBuffer.mock.t.Fatalf("Default expectation is already set for the LogFiler.FlushBuffer method")
	}

	if len(mmFlushBuffer.expectations) > 0 {
		mmFlushBuffer.mock.t.Fatalf("Some expectations are already set for the LogFiler.FlushBuffer method")
	}

	mmFlushBuffer.mock.funcFlushBuffer = f
	return mmFlushBuffer.mock
}

// FlushBuffer implements server.LogFiler
func (mmFlushBuffer *LogFilerMock) FlushBuffer() {
	mm_atomic.AddUint64(&mmFlushBuffer.beforeFlushBufferCounter, 1)
	defer mm_atomic.AddUint64(&mmFlushBuffer.afterFlushBufferCounter, 1)

	if mmFlushBuffer.inspectFuncFlushBuffer != nil {
		mmFlushBuffer.inspectFuncFlushBuffer()
	}

	if mmFlushBuffer.FlushBufferMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlushBuffer.FlushBufferMock.defaultExpectation.Counter, 1)

		return

	}
	if mmFlushBuffer.funcFlushBuffer != nil {
		mmFlushBuffer.funcFlushBuffer()
		return
	}
	mmFlushBuffer.t.Fatalf("Unexpected call to LogFilerMock.FlushBuffer.")

}

// FlushBufferAfterCounter returns a count of finished LogFilerMock.FlushBuffer invocations
func (mmFlushBuffer *LogFilerMock) FlushBufferAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushBuffer.afterFlushBufferCounter)
}

// FlushBufferBeforeCounter returns a count of LogFilerMock.FlushBuffer invocations
func (mmFlushBuffer *LogFilerMock) FlushBufferBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushBuffer.beforeFlushBufferCounter)
}

// MinimockFlushBufferDone returns true if the count of the FlushBuffer invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockFlushBufferDone() bool {
	for _, e := range m.FlushBufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushBufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushBuffer != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		return false
	}
	return true
}

// MinimockFlushBufferInspect logs each unmet expectation
func (m *LogFilerMock) MinimockFlushBufferInspect() {
	for _, e := range m.FlushBufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.FlushBuffer")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushBufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.FlushBuffer")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushBuffer != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.FlushBuffer")
	}
}

type mLogFilerMockName struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockNameExpectation
	expectations       []*LogFilerMockNameExpectation
}

// LogFilerMockNameExpectation specifies expectation struct of the LogFiler.Name
type LogFilerMockNameExpectation struct {
	mock *LogFilerMock

	results *LogFilerMockNameResults
	Counter uint64
}

// LogFilerMockNameResults contains results of the LogFiler.Name
type LogFilerMockNameResults struct {
	s1 string
}

// Expect sets up expected params for LogFiler.Name
func (mmName *mLogFilerMockName) Expect() *mLogFilerMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("LogFilerMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &LogFilerMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Name
func (mmName *mLogFilerMockName) Inspect(f func()) *mLogFilerMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for LogFilerMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by LogFiler.Name
func (mmName *mLogFilerMockName) Return(s1 string) *LogFilerMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("LogFilerMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &LogFilerMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &LogFilerMockNameResults{s1}
	return mmName.mock
}

//Set uses given function f to mock the LogFiler.Name method
func (mmName *mLogFilerMockName) Set(f func() (s1 string)) *LogFilerMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the LogFiler.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the LogFiler.Name method")
	}

	mmName.mock.funcName = f
	return mmName.mock
}

// Name implements server.LogFiler
func (mmName *LogFilerMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the LogFilerMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to LogFilerMock.Name.")
	return
}

// NameAfterCounter returns a count of finished LogFilerMock.Name invocations
func (mmName *LogFilerMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of LogFilerMock.Name invocations
func (mmName *LogFilerMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockNameDone() bool {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockNameInspect logs each unmet expectation
func (m *LogFilerMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.Name")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Name")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Name")
	}
}

type mLogFilerMockWriteLine struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockWriteLineExpectation
	expectations       []*LogFilerMockWriteLineExpectation

	callArgs []*LogFilerMockWriteLineParams
	mutex    sync.RWMutex
}

// LogFilerMockWriteLineExpectation specifies expectation struct of the LogFiler.WriteLine
type LogFilerMockWriteLineExpectation struct {
	mock   *LogFilerMock
	params *LogFilerMockWriteLineParams

	Counter uint64
}

// LogFilerMockWriteLineParams contains parameters of the LogFiler.WriteLine
type LogFilerMockWriteLineParams struct {
	msg string
}

// Expect sets up expected params for LogFiler.WriteLine
func (mmWriteLine *mLogFilerMockWriteLine) Expect(msg string) *mLogFilerMockWriteLine {
	if mmWriteLine.mock.funcWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("LogFilerMock.WriteLine mock is already set by Set")
	}

	if mmWriteLine.defaultExpectation == nil {
		mmWriteLine.defaultExpectation = &LogFilerMockWriteLineExpectation{}
	}

	mmWriteLine.defaultExpectation.params = &LogFilerMockWriteLineParams{msg}
	for _, e := range mmWriteLine.expectations {
		if minimock.Equal(e.params, mmWriteLine.defaultExpectation.params) {
			mmWriteLine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteLine.defaultExpectation.params)
		}
	}

	return mmWriteLine
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.WriteLine
func (mmWriteLine *mLogFilerMockWriteLine) Inspect(f func(msg string)) *mLogFilerMockWriteLine {
	if mmWriteLine.mock.inspectFuncWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("Inspect function is already set for LogFilerMock.WriteLine")
	}

	mmWriteLine.mock.inspectFuncWriteLine = f

	return mmWriteLine
}

// Return sets up results that will be returned by LogFiler.WriteLine
func (mmWriteLine *mLogFilerMockWriteLine) Return() *LogFilerMock {
	if mmWriteLine.mock.funcWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("LogFilerMock.WriteLine mock is already set by Set")
	}

	if mmWriteLine.defaultExpectation == nil {
		mmWriteLine.defaultExpectation = &LogFilerMockWriteLineExpectation{mock: mmWriteLine.mock}
	}

	return mmWriteLine.mock
}

//Set uses given function f to mock the LogFiler.WriteLine method
func (mmWriteLine *mLogFilerMockWriteLine) Set(f func(msg string)) *LogFilerMock {
	if mmWriteLine.defaultExpectation != nil {
		mmWriteLine.mock.t.Fatalf("Default expectation is already set for the LogFiler.WriteLine method")
	}

	if len(mmWriteLine.expectations) > 0 {
		mmWriteLine.mock.t.Fatalf("Some expectations are already set for the LogFiler.WriteLine method")
	}

	mmWriteLine.mock.funcWriteLine = f
	return mmWriteLine.mock
}

// WriteLine implements server.LogFiler
func (mmWriteLine *LogFilerMock) WriteLine(msg string) {
	mm_atomic.AddUint64(&mmWriteLine.beforeWriteLineCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteLine.afterWriteLineCounter, 1)

	if mmWriteLine.inspectFuncWriteLine != nil {
		mmWriteLine.inspectFuncWriteLine(msg)
	}

	mm_params := &LogFilerMockWriteLineParams{msg}

	// Record call args
	mmWriteLine.WriteLineMock.mutex.Lock()
	mmWriteLine.WriteLineMock.callArgs = append(mmWriteLine.WriteLineMock.callArgs, mm_params)
	mmWriteLine.WriteLineMock.mutex.Unlock()

	for _, e := range mmWriteLine.WriteLineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWriteLine.WriteLineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteLine.WriteLineMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteLine.WriteLineMock.defaultExpectation.params
		mm_got := LogFilerMockWriteLineParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteLine.t.Errorf("LogFilerMock.WriteLine got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWriteLine.funcWriteLine != nil {
		mmWriteLine.funcWriteLine(msg)
		return
	}
	mmWriteLine.t.Fatalf("Unexpected call to LogFilerMock.WriteLine. %v", msg)

}

// WriteLineAfterCounter returns a count of finished LogFilerMock.WriteLine invocations
func (mmWriteLine *LogFilerMock) WriteLineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteLine.afterWriteLineCounter)
}

// WriteLineBeforeCounter returns a count of LogFilerMock.WriteLine invocations
func (mmWriteLine *LogFilerMock) WriteLineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteLine.beforeWriteLineCounter)
}

// Calls returns a list of arguments used in each call to LogFilerMock.WriteLine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteLine *mLogFilerMockWriteLine) Calls() []*LogFilerMockWriteLineParams {
	mmWriteLine.mutex.RLock()

	argCopy := make([]*LogFilerMockWriteLineParams, len(mmWriteLine.callArgs))
	copy(argCopy, mmWriteLine.callArgs)

	mmWriteLine.mutex.RUnlock()

	return argCopy
}

// MinimockWriteLineDone returns true if the count of the WriteLine invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockWriteLineDone() bool {
	for _, e := range m.WriteLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteLine != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteLineInspect logs each unmet expectation
func (m *LogFilerMock) MinimockWriteLineInspect() {
	for _, e := range m.WriteLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogFilerMock.WriteLine with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		if m.WriteLineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogFilerMock.WriteLine")
		} else {
			m.t.Errorf("Expected call to LogFilerMock.WriteLine with params: %#v", *m.WriteLineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteLine != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.WriteLine")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LogFilerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBufferInspect()

		m.MinimockFlushBufferInspect()

		m.MinimockNameInspect()

		m.MinimockWriteLineInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LogFilerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LogFilerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBufferDone() &&
		m.MinimockFlushBufferDone() &&
		m.MinimockNameDone() &&
		m.MinimockWriteLineDone()
}
