package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/server.LogFiler -o ./pkg/mocks/log_filer_mock.go

import (
	mm_server "LogWatcher/pkg/server"
	"bytes"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"go.mongodb.org/mongo-driver/mongo"
)

// LogFilerMock implements server.LogFiler
type LogFilerMock struct {
	t minimock.Tester

	funcBuffer          func() (b1 bytes.Buffer)
	inspectFuncBuffer   func()
	afterBufferCounter  uint64
	beforeBufferCounter uint64
	BufferMock          mLogFilerMockBuffer

	funcChannel          func() (ch1 chan string)
	inspectFuncChannel   func()
	afterChannelCounter  uint64
	beforeChannelCounter uint64
	ChannelMock          mLogFilerMockChannel

	funcFlushBuffer          func()
	inspectFuncFlushBuffer   func()
	afterFlushBufferCounter  uint64
	beforeFlushBufferCounter uint64
	FlushBufferMock          mLogFilerMockFlushBuffer

	funcGetConn          func() (cp1 *mongo.Client)
	inspectFuncGetConn   func()
	afterGetConnCounter  uint64
	beforeGetConnCounter uint64
	GetConnMock          mLogFilerMockGetConn

	funcLock          func()
	inspectFuncLock   func()
	afterLockCounter  uint64
	beforeLockCounter uint64
	LockMock          mLogFilerMockLock

	funcName          func() (s1 string)
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mLogFilerMockName

	funcSetState          func(state mm_server.StateType)
	inspectFuncSetState   func(state mm_server.StateType)
	afterSetStateCounter  uint64
	beforeSetStateCounter uint64
	SetStateMock          mLogFilerMockSetState

	funcState          func() (s1 mm_server.StateType)
	inspectFuncState   func()
	afterStateCounter  uint64
	beforeStateCounter uint64
	StateMock          mLogFilerMockState

	funcUnlock          func()
	inspectFuncUnlock   func()
	afterUnlockCounter  uint64
	beforeUnlockCounter uint64
	UnlockMock          mLogFilerMockUnlock

	funcWriteLine          func(msg string)
	inspectFuncWriteLine   func(msg string)
	afterWriteLineCounter  uint64
	beforeWriteLineCounter uint64
	WriteLineMock          mLogFilerMockWriteLine
}

// NewLogFilerMock returns a mock for server.LogFiler
func NewLogFilerMock(t minimock.Tester) *LogFilerMock {
	m := &LogFilerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BufferMock = mLogFilerMockBuffer{mock: m}

	m.ChannelMock = mLogFilerMockChannel{mock: m}

	m.FlushBufferMock = mLogFilerMockFlushBuffer{mock: m}

	m.GetConnMock = mLogFilerMockGetConn{mock: m}

	m.LockMock = mLogFilerMockLock{mock: m}

	m.NameMock = mLogFilerMockName{mock: m}

	m.SetStateMock = mLogFilerMockSetState{mock: m}
	m.SetStateMock.callArgs = []*LogFilerMockSetStateParams{}

	m.StateMock = mLogFilerMockState{mock: m}

	m.UnlockMock = mLogFilerMockUnlock{mock: m}

	m.WriteLineMock = mLogFilerMockWriteLine{mock: m}
	m.WriteLineMock.callArgs = []*LogFilerMockWriteLineParams{}

	return m
}

type mLogFilerMockBuffer struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockBufferExpectation
	expectations       []*LogFilerMockBufferExpectation
}

// LogFilerMockBufferExpectation specifies expectation struct of the LogFiler.Buffer
type LogFilerMockBufferExpectation struct {
	mock *LogFilerMock

	results *LogFilerMockBufferResults
	Counter uint64
}

// LogFilerMockBufferResults contains results of the LogFiler.Buffer
type LogFilerMockBufferResults struct {
	b1 bytes.Buffer
}

// Expect sets up expected params for LogFiler.Buffer
func (mmBuffer *mLogFilerMockBuffer) Expect() *mLogFilerMockBuffer {
	if mmBuffer.mock.funcBuffer != nil {
		mmBuffer.mock.t.Fatalf("LogFilerMock.Buffer mock is already set by Set")
	}

	if mmBuffer.defaultExpectation == nil {
		mmBuffer.defaultExpectation = &LogFilerMockBufferExpectation{}
	}

	return mmBuffer
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Buffer
func (mmBuffer *mLogFilerMockBuffer) Inspect(f func()) *mLogFilerMockBuffer {
	if mmBuffer.mock.inspectFuncBuffer != nil {
		mmBuffer.mock.t.Fatalf("Inspect function is already set for LogFilerMock.Buffer")
	}

	mmBuffer.mock.inspectFuncBuffer = f

	return mmBuffer
}

// Return sets up results that will be returned by LogFiler.Buffer
func (mmBuffer *mLogFilerMockBuffer) Return(b1 bytes.Buffer) *LogFilerMock {
	if mmBuffer.mock.funcBuffer != nil {
		mmBuffer.mock.t.Fatalf("LogFilerMock.Buffer mock is already set by Set")
	}

	if mmBuffer.defaultExpectation == nil {
		mmBuffer.defaultExpectation = &LogFilerMockBufferExpectation{mock: mmBuffer.mock}
	}
	mmBuffer.defaultExpectation.results = &LogFilerMockBufferResults{b1}
	return mmBuffer.mock
}

//Set uses given function f to mock the LogFiler.Buffer method
func (mmBuffer *mLogFilerMockBuffer) Set(f func() (b1 bytes.Buffer)) *LogFilerMock {
	if mmBuffer.defaultExpectation != nil {
		mmBuffer.mock.t.Fatalf("Default expectation is already set for the LogFiler.Buffer method")
	}

	if len(mmBuffer.expectations) > 0 {
		mmBuffer.mock.t.Fatalf("Some expectations are already set for the LogFiler.Buffer method")
	}

	mmBuffer.mock.funcBuffer = f
	return mmBuffer.mock
}

// Buffer implements server.LogFiler
func (mmBuffer *LogFilerMock) Buffer() (b1 bytes.Buffer) {
	mm_atomic.AddUint64(&mmBuffer.beforeBufferCounter, 1)
	defer mm_atomic.AddUint64(&mmBuffer.afterBufferCounter, 1)

	if mmBuffer.inspectFuncBuffer != nil {
		mmBuffer.inspectFuncBuffer()
	}

	if mmBuffer.BufferMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuffer.BufferMock.defaultExpectation.Counter, 1)

		mm_results := mmBuffer.BufferMock.defaultExpectation.results
		if mm_results == nil {
			mmBuffer.t.Fatal("No results are set for the LogFilerMock.Buffer")
		}
		return (*mm_results).b1
	}
	if mmBuffer.funcBuffer != nil {
		return mmBuffer.funcBuffer()
	}
	mmBuffer.t.Fatalf("Unexpected call to LogFilerMock.Buffer.")
	return
}

// BufferAfterCounter returns a count of finished LogFilerMock.Buffer invocations
func (mmBuffer *LogFilerMock) BufferAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuffer.afterBufferCounter)
}

// BufferBeforeCounter returns a count of LogFilerMock.Buffer invocations
func (mmBuffer *LogFilerMock) BufferBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuffer.beforeBufferCounter)
}

// MinimockBufferDone returns true if the count of the Buffer invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockBufferDone() bool {
	for _, e := range m.BufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuffer != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		return false
	}
	return true
}

// MinimockBufferInspect logs each unmet expectation
func (m *LogFilerMock) MinimockBufferInspect() {
	for _, e := range m.BufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.Buffer")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Buffer")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuffer != nil && mm_atomic.LoadUint64(&m.afterBufferCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Buffer")
	}
}

type mLogFilerMockChannel struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockChannelExpectation
	expectations       []*LogFilerMockChannelExpectation
}

// LogFilerMockChannelExpectation specifies expectation struct of the LogFiler.Channel
type LogFilerMockChannelExpectation struct {
	mock *LogFilerMock

	results *LogFilerMockChannelResults
	Counter uint64
}

// LogFilerMockChannelResults contains results of the LogFiler.Channel
type LogFilerMockChannelResults struct {
	ch1 chan string
}

// Expect sets up expected params for LogFiler.Channel
func (mmChannel *mLogFilerMockChannel) Expect() *mLogFilerMockChannel {
	if mmChannel.mock.funcChannel != nil {
		mmChannel.mock.t.Fatalf("LogFilerMock.Channel mock is already set by Set")
	}

	if mmChannel.defaultExpectation == nil {
		mmChannel.defaultExpectation = &LogFilerMockChannelExpectation{}
	}

	return mmChannel
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Channel
func (mmChannel *mLogFilerMockChannel) Inspect(f func()) *mLogFilerMockChannel {
	if mmChannel.mock.inspectFuncChannel != nil {
		mmChannel.mock.t.Fatalf("Inspect function is already set for LogFilerMock.Channel")
	}

	mmChannel.mock.inspectFuncChannel = f

	return mmChannel
}

// Return sets up results that will be returned by LogFiler.Channel
func (mmChannel *mLogFilerMockChannel) Return(ch1 chan string) *LogFilerMock {
	if mmChannel.mock.funcChannel != nil {
		mmChannel.mock.t.Fatalf("LogFilerMock.Channel mock is already set by Set")
	}

	if mmChannel.defaultExpectation == nil {
		mmChannel.defaultExpectation = &LogFilerMockChannelExpectation{mock: mmChannel.mock}
	}
	mmChannel.defaultExpectation.results = &LogFilerMockChannelResults{ch1}
	return mmChannel.mock
}

//Set uses given function f to mock the LogFiler.Channel method
func (mmChannel *mLogFilerMockChannel) Set(f func() (ch1 chan string)) *LogFilerMock {
	if mmChannel.defaultExpectation != nil {
		mmChannel.mock.t.Fatalf("Default expectation is already set for the LogFiler.Channel method")
	}

	if len(mmChannel.expectations) > 0 {
		mmChannel.mock.t.Fatalf("Some expectations are already set for the LogFiler.Channel method")
	}

	mmChannel.mock.funcChannel = f
	return mmChannel.mock
}

// Channel implements server.LogFiler
func (mmChannel *LogFilerMock) Channel() (ch1 chan string) {
	mm_atomic.AddUint64(&mmChannel.beforeChannelCounter, 1)
	defer mm_atomic.AddUint64(&mmChannel.afterChannelCounter, 1)

	if mmChannel.inspectFuncChannel != nil {
		mmChannel.inspectFuncChannel()
	}

	if mmChannel.ChannelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChannel.ChannelMock.defaultExpectation.Counter, 1)

		mm_results := mmChannel.ChannelMock.defaultExpectation.results
		if mm_results == nil {
			mmChannel.t.Fatal("No results are set for the LogFilerMock.Channel")
		}
		return (*mm_results).ch1
	}
	if mmChannel.funcChannel != nil {
		return mmChannel.funcChannel()
	}
	mmChannel.t.Fatalf("Unexpected call to LogFilerMock.Channel.")
	return
}

// ChannelAfterCounter returns a count of finished LogFilerMock.Channel invocations
func (mmChannel *LogFilerMock) ChannelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChannel.afterChannelCounter)
}

// ChannelBeforeCounter returns a count of LogFilerMock.Channel invocations
func (mmChannel *LogFilerMock) ChannelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChannel.beforeChannelCounter)
}

// MinimockChannelDone returns true if the count of the Channel invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockChannelDone() bool {
	for _, e := range m.ChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChannelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChannel != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		return false
	}
	return true
}

// MinimockChannelInspect logs each unmet expectation
func (m *LogFilerMock) MinimockChannelInspect() {
	for _, e := range m.ChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.Channel")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChannelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Channel")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChannel != nil && mm_atomic.LoadUint64(&m.afterChannelCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Channel")
	}
}

type mLogFilerMockFlushBuffer struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockFlushBufferExpectation
	expectations       []*LogFilerMockFlushBufferExpectation
}

// LogFilerMockFlushBufferExpectation specifies expectation struct of the LogFiler.FlushBuffer
type LogFilerMockFlushBufferExpectation struct {
	mock *LogFilerMock

	Counter uint64
}

// Expect sets up expected params for LogFiler.FlushBuffer
func (mmFlushBuffer *mLogFilerMockFlushBuffer) Expect() *mLogFilerMockFlushBuffer {
	if mmFlushBuffer.mock.funcFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("LogFilerMock.FlushBuffer mock is already set by Set")
	}

	if mmFlushBuffer.defaultExpectation == nil {
		mmFlushBuffer.defaultExpectation = &LogFilerMockFlushBufferExpectation{}
	}

	return mmFlushBuffer
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.FlushBuffer
func (mmFlushBuffer *mLogFilerMockFlushBuffer) Inspect(f func()) *mLogFilerMockFlushBuffer {
	if mmFlushBuffer.mock.inspectFuncFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("Inspect function is already set for LogFilerMock.FlushBuffer")
	}

	mmFlushBuffer.mock.inspectFuncFlushBuffer = f

	return mmFlushBuffer
}

// Return sets up results that will be returned by LogFiler.FlushBuffer
func (mmFlushBuffer *mLogFilerMockFlushBuffer) Return() *LogFilerMock {
	if mmFlushBuffer.mock.funcFlushBuffer != nil {
		mmFlushBuffer.mock.t.Fatalf("LogFilerMock.FlushBuffer mock is already set by Set")
	}

	if mmFlushBuffer.defaultExpectation == nil {
		mmFlushBuffer.defaultExpectation = &LogFilerMockFlushBufferExpectation{mock: mmFlushBuffer.mock}
	}

	return mmFlushBuffer.mock
}

//Set uses given function f to mock the LogFiler.FlushBuffer method
func (mmFlushBuffer *mLogFilerMockFlushBuffer) Set(f func()) *LogFilerMock {
	if mmFlushBuffer.defaultExpectation != nil {
		mmFlushBuffer.mock.t.Fatalf("Default expectation is already set for the LogFiler.FlushBuffer method")
	}

	if len(mmFlushBuffer.expectations) > 0 {
		mmFlushBuffer.mock.t.Fatalf("Some expectations are already set for the LogFiler.FlushBuffer method")
	}

	mmFlushBuffer.mock.funcFlushBuffer = f
	return mmFlushBuffer.mock
}

// FlushBuffer implements server.LogFiler
func (mmFlushBuffer *LogFilerMock) FlushBuffer() {
	mm_atomic.AddUint64(&mmFlushBuffer.beforeFlushBufferCounter, 1)
	defer mm_atomic.AddUint64(&mmFlushBuffer.afterFlushBufferCounter, 1)

	if mmFlushBuffer.inspectFuncFlushBuffer != nil {
		mmFlushBuffer.inspectFuncFlushBuffer()
	}

	if mmFlushBuffer.FlushBufferMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlushBuffer.FlushBufferMock.defaultExpectation.Counter, 1)

		return

	}
	if mmFlushBuffer.funcFlushBuffer != nil {
		mmFlushBuffer.funcFlushBuffer()
		return
	}
	mmFlushBuffer.t.Fatalf("Unexpected call to LogFilerMock.FlushBuffer.")

}

// FlushBufferAfterCounter returns a count of finished LogFilerMock.FlushBuffer invocations
func (mmFlushBuffer *LogFilerMock) FlushBufferAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushBuffer.afterFlushBufferCounter)
}

// FlushBufferBeforeCounter returns a count of LogFilerMock.FlushBuffer invocations
func (mmFlushBuffer *LogFilerMock) FlushBufferBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushBuffer.beforeFlushBufferCounter)
}

// MinimockFlushBufferDone returns true if the count of the FlushBuffer invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockFlushBufferDone() bool {
	for _, e := range m.FlushBufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushBufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushBuffer != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		return false
	}
	return true
}

// MinimockFlushBufferInspect logs each unmet expectation
func (m *LogFilerMock) MinimockFlushBufferInspect() {
	for _, e := range m.FlushBufferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.FlushBuffer")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushBufferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.FlushBuffer")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushBuffer != nil && mm_atomic.LoadUint64(&m.afterFlushBufferCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.FlushBuffer")
	}
}

type mLogFilerMockGetConn struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockGetConnExpectation
	expectations       []*LogFilerMockGetConnExpectation
}

// LogFilerMockGetConnExpectation specifies expectation struct of the LogFiler.GetConn
type LogFilerMockGetConnExpectation struct {
	mock *LogFilerMock

	results *LogFilerMockGetConnResults
	Counter uint64
}

// LogFilerMockGetConnResults contains results of the LogFiler.GetConn
type LogFilerMockGetConnResults struct {
	cp1 *mongo.Client
}

// Expect sets up expected params for LogFiler.GetConn
func (mmGetConn *mLogFilerMockGetConn) Expect() *mLogFilerMockGetConn {
	if mmGetConn.mock.funcGetConn != nil {
		mmGetConn.mock.t.Fatalf("LogFilerMock.GetConn mock is already set by Set")
	}

	if mmGetConn.defaultExpectation == nil {
		mmGetConn.defaultExpectation = &LogFilerMockGetConnExpectation{}
	}

	return mmGetConn
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.GetConn
func (mmGetConn *mLogFilerMockGetConn) Inspect(f func()) *mLogFilerMockGetConn {
	if mmGetConn.mock.inspectFuncGetConn != nil {
		mmGetConn.mock.t.Fatalf("Inspect function is already set for LogFilerMock.GetConn")
	}

	mmGetConn.mock.inspectFuncGetConn = f

	return mmGetConn
}

// Return sets up results that will be returned by LogFiler.GetConn
func (mmGetConn *mLogFilerMockGetConn) Return(cp1 *mongo.Client) *LogFilerMock {
	if mmGetConn.mock.funcGetConn != nil {
		mmGetConn.mock.t.Fatalf("LogFilerMock.GetConn mock is already set by Set")
	}

	if mmGetConn.defaultExpectation == nil {
		mmGetConn.defaultExpectation = &LogFilerMockGetConnExpectation{mock: mmGetConn.mock}
	}
	mmGetConn.defaultExpectation.results = &LogFilerMockGetConnResults{cp1}
	return mmGetConn.mock
}

//Set uses given function f to mock the LogFiler.GetConn method
func (mmGetConn *mLogFilerMockGetConn) Set(f func() (cp1 *mongo.Client)) *LogFilerMock {
	if mmGetConn.defaultExpectation != nil {
		mmGetConn.mock.t.Fatalf("Default expectation is already set for the LogFiler.GetConn method")
	}

	if len(mmGetConn.expectations) > 0 {
		mmGetConn.mock.t.Fatalf("Some expectations are already set for the LogFiler.GetConn method")
	}

	mmGetConn.mock.funcGetConn = f
	return mmGetConn.mock
}

// GetConn implements server.LogFiler
func (mmGetConn *LogFilerMock) GetConn() (cp1 *mongo.Client) {
	mm_atomic.AddUint64(&mmGetConn.beforeGetConnCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConn.afterGetConnCounter, 1)

	if mmGetConn.inspectFuncGetConn != nil {
		mmGetConn.inspectFuncGetConn()
	}

	if mmGetConn.GetConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConn.GetConnMock.defaultExpectation.Counter, 1)

		mm_results := mmGetConn.GetConnMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConn.t.Fatal("No results are set for the LogFilerMock.GetConn")
		}
		return (*mm_results).cp1
	}
	if mmGetConn.funcGetConn != nil {
		return mmGetConn.funcGetConn()
	}
	mmGetConn.t.Fatalf("Unexpected call to LogFilerMock.GetConn.")
	return
}

// GetConnAfterCounter returns a count of finished LogFilerMock.GetConn invocations
func (mmGetConn *LogFilerMock) GetConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConn.afterGetConnCounter)
}

// GetConnBeforeCounter returns a count of LogFilerMock.GetConn invocations
func (mmGetConn *LogFilerMock) GetConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConn.beforeGetConnCounter)
}

// MinimockGetConnDone returns true if the count of the GetConn invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockGetConnDone() bool {
	for _, e := range m.GetConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConn != nil && mm_atomic.LoadUint64(&m.afterGetConnCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetConnInspect logs each unmet expectation
func (m *LogFilerMock) MinimockGetConnInspect() {
	for _, e := range m.GetConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.GetConn")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConnCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.GetConn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConn != nil && mm_atomic.LoadUint64(&m.afterGetConnCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.GetConn")
	}
}

type mLogFilerMockLock struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockLockExpectation
	expectations       []*LogFilerMockLockExpectation
}

// LogFilerMockLockExpectation specifies expectation struct of the LogFiler.Lock
type LogFilerMockLockExpectation struct {
	mock *LogFilerMock

	Counter uint64
}

// Expect sets up expected params for LogFiler.Lock
func (mmLock *mLogFilerMockLock) Expect() *mLogFilerMockLock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("LogFilerMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &LogFilerMockLockExpectation{}
	}

	return mmLock
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Lock
func (mmLock *mLogFilerMockLock) Inspect(f func()) *mLogFilerMockLock {
	if mmLock.mock.inspectFuncLock != nil {
		mmLock.mock.t.Fatalf("Inspect function is already set for LogFilerMock.Lock")
	}

	mmLock.mock.inspectFuncLock = f

	return mmLock
}

// Return sets up results that will be returned by LogFiler.Lock
func (mmLock *mLogFilerMockLock) Return() *LogFilerMock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("LogFilerMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &LogFilerMockLockExpectation{mock: mmLock.mock}
	}

	return mmLock.mock
}

//Set uses given function f to mock the LogFiler.Lock method
func (mmLock *mLogFilerMockLock) Set(f func()) *LogFilerMock {
	if mmLock.defaultExpectation != nil {
		mmLock.mock.t.Fatalf("Default expectation is already set for the LogFiler.Lock method")
	}

	if len(mmLock.expectations) > 0 {
		mmLock.mock.t.Fatalf("Some expectations are already set for the LogFiler.Lock method")
	}

	mmLock.mock.funcLock = f
	return mmLock.mock
}

// Lock implements server.LogFiler
func (mmLock *LogFilerMock) Lock() {
	mm_atomic.AddUint64(&mmLock.beforeLockCounter, 1)
	defer mm_atomic.AddUint64(&mmLock.afterLockCounter, 1)

	if mmLock.inspectFuncLock != nil {
		mmLock.inspectFuncLock()
	}

	if mmLock.LockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLock.LockMock.defaultExpectation.Counter, 1)

		return

	}
	if mmLock.funcLock != nil {
		mmLock.funcLock()
		return
	}
	mmLock.t.Fatalf("Unexpected call to LogFilerMock.Lock.")

}

// LockAfterCounter returns a count of finished LogFilerMock.Lock invocations
func (mmLock *LogFilerMock) LockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.afterLockCounter)
}

// LockBeforeCounter returns a count of LogFilerMock.Lock invocations
func (mmLock *LogFilerMock) LockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.beforeLockCounter)
}

// MinimockLockDone returns true if the count of the Lock invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockLockDone() bool {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	return true
}

// MinimockLockInspect logs each unmet expectation
func (m *LogFilerMock) MinimockLockInspect() {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.Lock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Lock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Lock")
	}
}

type mLogFilerMockName struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockNameExpectation
	expectations       []*LogFilerMockNameExpectation
}

// LogFilerMockNameExpectation specifies expectation struct of the LogFiler.Name
type LogFilerMockNameExpectation struct {
	mock *LogFilerMock

	results *LogFilerMockNameResults
	Counter uint64
}

// LogFilerMockNameResults contains results of the LogFiler.Name
type LogFilerMockNameResults struct {
	s1 string
}

// Expect sets up expected params for LogFiler.Name
func (mmName *mLogFilerMockName) Expect() *mLogFilerMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("LogFilerMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &LogFilerMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Name
func (mmName *mLogFilerMockName) Inspect(f func()) *mLogFilerMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for LogFilerMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by LogFiler.Name
func (mmName *mLogFilerMockName) Return(s1 string) *LogFilerMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("LogFilerMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &LogFilerMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &LogFilerMockNameResults{s1}
	return mmName.mock
}

//Set uses given function f to mock the LogFiler.Name method
func (mmName *mLogFilerMockName) Set(f func() (s1 string)) *LogFilerMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the LogFiler.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the LogFiler.Name method")
	}

	mmName.mock.funcName = f
	return mmName.mock
}

// Name implements server.LogFiler
func (mmName *LogFilerMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the LogFilerMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to LogFilerMock.Name.")
	return
}

// NameAfterCounter returns a count of finished LogFilerMock.Name invocations
func (mmName *LogFilerMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of LogFilerMock.Name invocations
func (mmName *LogFilerMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockNameDone() bool {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockNameInspect logs each unmet expectation
func (m *LogFilerMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.Name")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Name")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Name")
	}
}

type mLogFilerMockSetState struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockSetStateExpectation
	expectations       []*LogFilerMockSetStateExpectation

	callArgs []*LogFilerMockSetStateParams
	mutex    sync.RWMutex
}

// LogFilerMockSetStateExpectation specifies expectation struct of the LogFiler.SetState
type LogFilerMockSetStateExpectation struct {
	mock   *LogFilerMock
	params *LogFilerMockSetStateParams

	Counter uint64
}

// LogFilerMockSetStateParams contains parameters of the LogFiler.SetState
type LogFilerMockSetStateParams struct {
	state mm_server.StateType
}

// Expect sets up expected params for LogFiler.SetState
func (mmSetState *mLogFilerMockSetState) Expect(state mm_server.StateType) *mLogFilerMockSetState {
	if mmSetState.mock.funcSetState != nil {
		mmSetState.mock.t.Fatalf("LogFilerMock.SetState mock is already set by Set")
	}

	if mmSetState.defaultExpectation == nil {
		mmSetState.defaultExpectation = &LogFilerMockSetStateExpectation{}
	}

	mmSetState.defaultExpectation.params = &LogFilerMockSetStateParams{state}
	for _, e := range mmSetState.expectations {
		if minimock.Equal(e.params, mmSetState.defaultExpectation.params) {
			mmSetState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetState.defaultExpectation.params)
		}
	}

	return mmSetState
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.SetState
func (mmSetState *mLogFilerMockSetState) Inspect(f func(state mm_server.StateType)) *mLogFilerMockSetState {
	if mmSetState.mock.inspectFuncSetState != nil {
		mmSetState.mock.t.Fatalf("Inspect function is already set for LogFilerMock.SetState")
	}

	mmSetState.mock.inspectFuncSetState = f

	return mmSetState
}

// Return sets up results that will be returned by LogFiler.SetState
func (mmSetState *mLogFilerMockSetState) Return() *LogFilerMock {
	if mmSetState.mock.funcSetState != nil {
		mmSetState.mock.t.Fatalf("LogFilerMock.SetState mock is already set by Set")
	}

	if mmSetState.defaultExpectation == nil {
		mmSetState.defaultExpectation = &LogFilerMockSetStateExpectation{mock: mmSetState.mock}
	}

	return mmSetState.mock
}

//Set uses given function f to mock the LogFiler.SetState method
func (mmSetState *mLogFilerMockSetState) Set(f func(state mm_server.StateType)) *LogFilerMock {
	if mmSetState.defaultExpectation != nil {
		mmSetState.mock.t.Fatalf("Default expectation is already set for the LogFiler.SetState method")
	}

	if len(mmSetState.expectations) > 0 {
		mmSetState.mock.t.Fatalf("Some expectations are already set for the LogFiler.SetState method")
	}

	mmSetState.mock.funcSetState = f
	return mmSetState.mock
}

// SetState implements server.LogFiler
func (mmSetState *LogFilerMock) SetState(state mm_server.StateType) {
	mm_atomic.AddUint64(&mmSetState.beforeSetStateCounter, 1)
	defer mm_atomic.AddUint64(&mmSetState.afterSetStateCounter, 1)

	if mmSetState.inspectFuncSetState != nil {
		mmSetState.inspectFuncSetState(state)
	}

	mm_params := &LogFilerMockSetStateParams{state}

	// Record call args
	mmSetState.SetStateMock.mutex.Lock()
	mmSetState.SetStateMock.callArgs = append(mmSetState.SetStateMock.callArgs, mm_params)
	mmSetState.SetStateMock.mutex.Unlock()

	for _, e := range mmSetState.SetStateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetState.SetStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetState.SetStateMock.defaultExpectation.Counter, 1)
		mm_want := mmSetState.SetStateMock.defaultExpectation.params
		mm_got := LogFilerMockSetStateParams{state}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetState.t.Errorf("LogFilerMock.SetState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetState.funcSetState != nil {
		mmSetState.funcSetState(state)
		return
	}
	mmSetState.t.Fatalf("Unexpected call to LogFilerMock.SetState. %v", state)

}

// SetStateAfterCounter returns a count of finished LogFilerMock.SetState invocations
func (mmSetState *LogFilerMock) SetStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetState.afterSetStateCounter)
}

// SetStateBeforeCounter returns a count of LogFilerMock.SetState invocations
func (mmSetState *LogFilerMock) SetStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetState.beforeSetStateCounter)
}

// Calls returns a list of arguments used in each call to LogFilerMock.SetState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetState *mLogFilerMockSetState) Calls() []*LogFilerMockSetStateParams {
	mmSetState.mutex.RLock()

	argCopy := make([]*LogFilerMockSetStateParams, len(mmSetState.callArgs))
	copy(argCopy, mmSetState.callArgs)

	mmSetState.mutex.RUnlock()

	return argCopy
}

// MinimockSetStateDone returns true if the count of the SetState invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockSetStateDone() bool {
	for _, e := range m.SetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetState != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStateInspect logs each unmet expectation
func (m *LogFilerMock) MinimockSetStateInspect() {
	for _, e := range m.SetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogFilerMock.SetState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		if m.SetStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogFilerMock.SetState")
		} else {
			m.t.Errorf("Expected call to LogFilerMock.SetState with params: %#v", *m.SetStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetState != nil && mm_atomic.LoadUint64(&m.afterSetStateCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.SetState")
	}
}

type mLogFilerMockState struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockStateExpectation
	expectations       []*LogFilerMockStateExpectation
}

// LogFilerMockStateExpectation specifies expectation struct of the LogFiler.State
type LogFilerMockStateExpectation struct {
	mock *LogFilerMock

	results *LogFilerMockStateResults
	Counter uint64
}

// LogFilerMockStateResults contains results of the LogFiler.State
type LogFilerMockStateResults struct {
	s1 mm_server.StateType
}

// Expect sets up expected params for LogFiler.State
func (mmState *mLogFilerMockState) Expect() *mLogFilerMockState {
	if mmState.mock.funcState != nil {
		mmState.mock.t.Fatalf("LogFilerMock.State mock is already set by Set")
	}

	if mmState.defaultExpectation == nil {
		mmState.defaultExpectation = &LogFilerMockStateExpectation{}
	}

	return mmState
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.State
func (mmState *mLogFilerMockState) Inspect(f func()) *mLogFilerMockState {
	if mmState.mock.inspectFuncState != nil {
		mmState.mock.t.Fatalf("Inspect function is already set for LogFilerMock.State")
	}

	mmState.mock.inspectFuncState = f

	return mmState
}

// Return sets up results that will be returned by LogFiler.State
func (mmState *mLogFilerMockState) Return(s1 mm_server.StateType) *LogFilerMock {
	if mmState.mock.funcState != nil {
		mmState.mock.t.Fatalf("LogFilerMock.State mock is already set by Set")
	}

	if mmState.defaultExpectation == nil {
		mmState.defaultExpectation = &LogFilerMockStateExpectation{mock: mmState.mock}
	}
	mmState.defaultExpectation.results = &LogFilerMockStateResults{s1}
	return mmState.mock
}

//Set uses given function f to mock the LogFiler.State method
func (mmState *mLogFilerMockState) Set(f func() (s1 mm_server.StateType)) *LogFilerMock {
	if mmState.defaultExpectation != nil {
		mmState.mock.t.Fatalf("Default expectation is already set for the LogFiler.State method")
	}

	if len(mmState.expectations) > 0 {
		mmState.mock.t.Fatalf("Some expectations are already set for the LogFiler.State method")
	}

	mmState.mock.funcState = f
	return mmState.mock
}

// State implements server.LogFiler
func (mmState *LogFilerMock) State() (s1 mm_server.StateType) {
	mm_atomic.AddUint64(&mmState.beforeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmState.afterStateCounter, 1)

	if mmState.inspectFuncState != nil {
		mmState.inspectFuncState()
	}

	if mmState.StateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmState.StateMock.defaultExpectation.Counter, 1)

		mm_results := mmState.StateMock.defaultExpectation.results
		if mm_results == nil {
			mmState.t.Fatal("No results are set for the LogFilerMock.State")
		}
		return (*mm_results).s1
	}
	if mmState.funcState != nil {
		return mmState.funcState()
	}
	mmState.t.Fatalf("Unexpected call to LogFilerMock.State.")
	return
}

// StateAfterCounter returns a count of finished LogFilerMock.State invocations
func (mmState *LogFilerMock) StateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmState.afterStateCounter)
}

// StateBeforeCounter returns a count of LogFilerMock.State invocations
func (mmState *LogFilerMock) StateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmState.beforeStateCounter)
}

// MinimockStateDone returns true if the count of the State invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockStateDone() bool {
	for _, e := range m.StateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcState != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockStateInspect logs each unmet expectation
func (m *LogFilerMock) MinimockStateInspect() {
	for _, e := range m.StateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.State")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.State")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcState != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.State")
	}
}

type mLogFilerMockUnlock struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockUnlockExpectation
	expectations       []*LogFilerMockUnlockExpectation
}

// LogFilerMockUnlockExpectation specifies expectation struct of the LogFiler.Unlock
type LogFilerMockUnlockExpectation struct {
	mock *LogFilerMock

	Counter uint64
}

// Expect sets up expected params for LogFiler.Unlock
func (mmUnlock *mLogFilerMockUnlock) Expect() *mLogFilerMockUnlock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("LogFilerMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &LogFilerMockUnlockExpectation{}
	}

	return mmUnlock
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.Unlock
func (mmUnlock *mLogFilerMockUnlock) Inspect(f func()) *mLogFilerMockUnlock {
	if mmUnlock.mock.inspectFuncUnlock != nil {
		mmUnlock.mock.t.Fatalf("Inspect function is already set for LogFilerMock.Unlock")
	}

	mmUnlock.mock.inspectFuncUnlock = f

	return mmUnlock
}

// Return sets up results that will be returned by LogFiler.Unlock
func (mmUnlock *mLogFilerMockUnlock) Return() *LogFilerMock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("LogFilerMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &LogFilerMockUnlockExpectation{mock: mmUnlock.mock}
	}

	return mmUnlock.mock
}

//Set uses given function f to mock the LogFiler.Unlock method
func (mmUnlock *mLogFilerMockUnlock) Set(f func()) *LogFilerMock {
	if mmUnlock.defaultExpectation != nil {
		mmUnlock.mock.t.Fatalf("Default expectation is already set for the LogFiler.Unlock method")
	}

	if len(mmUnlock.expectations) > 0 {
		mmUnlock.mock.t.Fatalf("Some expectations are already set for the LogFiler.Unlock method")
	}

	mmUnlock.mock.funcUnlock = f
	return mmUnlock.mock
}

// Unlock implements server.LogFiler
func (mmUnlock *LogFilerMock) Unlock() {
	mm_atomic.AddUint64(&mmUnlock.beforeUnlockCounter, 1)
	defer mm_atomic.AddUint64(&mmUnlock.afterUnlockCounter, 1)

	if mmUnlock.inspectFuncUnlock != nil {
		mmUnlock.inspectFuncUnlock()
	}

	if mmUnlock.UnlockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnlock.UnlockMock.defaultExpectation.Counter, 1)

		return

	}
	if mmUnlock.funcUnlock != nil {
		mmUnlock.funcUnlock()
		return
	}
	mmUnlock.t.Fatalf("Unexpected call to LogFilerMock.Unlock.")

}

// UnlockAfterCounter returns a count of finished LogFilerMock.Unlock invocations
func (mmUnlock *LogFilerMock) UnlockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.afterUnlockCounter)
}

// UnlockBeforeCounter returns a count of LogFilerMock.Unlock invocations
func (mmUnlock *LogFilerMock) UnlockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.beforeUnlockCounter)
}

// MinimockUnlockDone returns true if the count of the Unlock invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockUnlockDone() bool {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnlockInspect logs each unmet expectation
func (m *LogFilerMock) MinimockUnlockInspect() {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LogFilerMock.Unlock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Unlock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.Unlock")
	}
}

type mLogFilerMockWriteLine struct {
	mock               *LogFilerMock
	defaultExpectation *LogFilerMockWriteLineExpectation
	expectations       []*LogFilerMockWriteLineExpectation

	callArgs []*LogFilerMockWriteLineParams
	mutex    sync.RWMutex
}

// LogFilerMockWriteLineExpectation specifies expectation struct of the LogFiler.WriteLine
type LogFilerMockWriteLineExpectation struct {
	mock   *LogFilerMock
	params *LogFilerMockWriteLineParams

	Counter uint64
}

// LogFilerMockWriteLineParams contains parameters of the LogFiler.WriteLine
type LogFilerMockWriteLineParams struct {
	msg string
}

// Expect sets up expected params for LogFiler.WriteLine
func (mmWriteLine *mLogFilerMockWriteLine) Expect(msg string) *mLogFilerMockWriteLine {
	if mmWriteLine.mock.funcWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("LogFilerMock.WriteLine mock is already set by Set")
	}

	if mmWriteLine.defaultExpectation == nil {
		mmWriteLine.defaultExpectation = &LogFilerMockWriteLineExpectation{}
	}

	mmWriteLine.defaultExpectation.params = &LogFilerMockWriteLineParams{msg}
	for _, e := range mmWriteLine.expectations {
		if minimock.Equal(e.params, mmWriteLine.defaultExpectation.params) {
			mmWriteLine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteLine.defaultExpectation.params)
		}
	}

	return mmWriteLine
}

// Inspect accepts an inspector function that has same arguments as the LogFiler.WriteLine
func (mmWriteLine *mLogFilerMockWriteLine) Inspect(f func(msg string)) *mLogFilerMockWriteLine {
	if mmWriteLine.mock.inspectFuncWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("Inspect function is already set for LogFilerMock.WriteLine")
	}

	mmWriteLine.mock.inspectFuncWriteLine = f

	return mmWriteLine
}

// Return sets up results that will be returned by LogFiler.WriteLine
func (mmWriteLine *mLogFilerMockWriteLine) Return() *LogFilerMock {
	if mmWriteLine.mock.funcWriteLine != nil {
		mmWriteLine.mock.t.Fatalf("LogFilerMock.WriteLine mock is already set by Set")
	}

	if mmWriteLine.defaultExpectation == nil {
		mmWriteLine.defaultExpectation = &LogFilerMockWriteLineExpectation{mock: mmWriteLine.mock}
	}

	return mmWriteLine.mock
}

//Set uses given function f to mock the LogFiler.WriteLine method
func (mmWriteLine *mLogFilerMockWriteLine) Set(f func(msg string)) *LogFilerMock {
	if mmWriteLine.defaultExpectation != nil {
		mmWriteLine.mock.t.Fatalf("Default expectation is already set for the LogFiler.WriteLine method")
	}

	if len(mmWriteLine.expectations) > 0 {
		mmWriteLine.mock.t.Fatalf("Some expectations are already set for the LogFiler.WriteLine method")
	}

	mmWriteLine.mock.funcWriteLine = f
	return mmWriteLine.mock
}

// WriteLine implements server.LogFiler
func (mmWriteLine *LogFilerMock) WriteLine(msg string) {
	mm_atomic.AddUint64(&mmWriteLine.beforeWriteLineCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteLine.afterWriteLineCounter, 1)

	if mmWriteLine.inspectFuncWriteLine != nil {
		mmWriteLine.inspectFuncWriteLine(msg)
	}

	mm_params := &LogFilerMockWriteLineParams{msg}

	// Record call args
	mmWriteLine.WriteLineMock.mutex.Lock()
	mmWriteLine.WriteLineMock.callArgs = append(mmWriteLine.WriteLineMock.callArgs, mm_params)
	mmWriteLine.WriteLineMock.mutex.Unlock()

	for _, e := range mmWriteLine.WriteLineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWriteLine.WriteLineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteLine.WriteLineMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteLine.WriteLineMock.defaultExpectation.params
		mm_got := LogFilerMockWriteLineParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteLine.t.Errorf("LogFilerMock.WriteLine got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWriteLine.funcWriteLine != nil {
		mmWriteLine.funcWriteLine(msg)
		return
	}
	mmWriteLine.t.Fatalf("Unexpected call to LogFilerMock.WriteLine. %v", msg)

}

// WriteLineAfterCounter returns a count of finished LogFilerMock.WriteLine invocations
func (mmWriteLine *LogFilerMock) WriteLineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteLine.afterWriteLineCounter)
}

// WriteLineBeforeCounter returns a count of LogFilerMock.WriteLine invocations
func (mmWriteLine *LogFilerMock) WriteLineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteLine.beforeWriteLineCounter)
}

// Calls returns a list of arguments used in each call to LogFilerMock.WriteLine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteLine *mLogFilerMockWriteLine) Calls() []*LogFilerMockWriteLineParams {
	mmWriteLine.mutex.RLock()

	argCopy := make([]*LogFilerMockWriteLineParams, len(mmWriteLine.callArgs))
	copy(argCopy, mmWriteLine.callArgs)

	mmWriteLine.mutex.RUnlock()

	return argCopy
}

// MinimockWriteLineDone returns true if the count of the WriteLine invocations corresponds
// the number of defined expectations
func (m *LogFilerMock) MinimockWriteLineDone() bool {
	for _, e := range m.WriteLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteLine != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteLineInspect logs each unmet expectation
func (m *LogFilerMock) MinimockWriteLineInspect() {
	for _, e := range m.WriteLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogFilerMock.WriteLine with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteLineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		if m.WriteLineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogFilerMock.WriteLine")
		} else {
			m.t.Errorf("Expected call to LogFilerMock.WriteLine with params: %#v", *m.WriteLineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteLine != nil && mm_atomic.LoadUint64(&m.afterWriteLineCounter) < 1 {
		m.t.Error("Expected call to LogFilerMock.WriteLine")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LogFilerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBufferInspect()

		m.MinimockChannelInspect()

		m.MinimockFlushBufferInspect()

		m.MinimockGetConnInspect()

		m.MinimockLockInspect()

		m.MinimockNameInspect()

		m.MinimockSetStateInspect()

		m.MinimockStateInspect()

		m.MinimockUnlockInspect()

		m.MinimockWriteLineInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LogFilerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LogFilerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBufferDone() &&
		m.MinimockChannelDone() &&
		m.MinimockFlushBufferDone() &&
		m.MinimockGetConnDone() &&
		m.MinimockLockDone() &&
		m.MinimockNameDone() &&
		m.MinimockSetStateDone() &&
		m.MinimockStateDone() &&
		m.MinimockUnlockDone() &&
		m.MinimockWriteLineDone()
}
