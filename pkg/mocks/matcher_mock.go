package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/stats.Matcher -o ./pkg/mocks/matcher_mock.go

import (
	mm_stats "LogWatcher/pkg/stats"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// MatcherMock implements stats.Matcher
type MatcherMock struct {
	t minimock.Tester

	funcDomain          func() (s1 string)
	inspectFuncDomain   func()
	afterDomainCounter  uint64
	beforeDomainCounter uint64
	DomainMock          mMatcherMockDomain

	funcFlush          func()
	inspectFuncFlush   func()
	afterFlushCounter  uint64
	beforeFlushCounter uint64
	FlushMock          mMatcherMockFlush

	funcLengthSeconds          func() (i1 int)
	inspectFuncLengthSeconds   func()
	afterLengthSecondsCounter  uint64
	beforeLengthSecondsCounter uint64
	LengthSecondsMock          mMatcherMockLengthSeconds

	funcMap          func() (s1 string)
	inspectFuncMap   func()
	afterMapCounter  uint64
	beforeMapCounter uint64
	MapMock          mMatcherMockMap

	funcPickupID          func() (i1 int)
	inspectFuncPickupID   func()
	afterPickupIDCounter  uint64
	beforePickupIDCounter uint64
	PickupIDMock          mMatcherMockPickupID

	funcPickupPlayers          func() (ppa1 []*mm_stats.PickupPlayer)
	inspectFuncPickupPlayers   func()
	afterPickupPlayersCounter  uint64
	beforePickupPlayersCounter uint64
	PickupPlayersMock          mMatcherMockPickupPlayers

	funcPlayerStats          func() (p1 mm_stats.PlayerStatsCollection)
	inspectFuncPlayerStats   func()
	afterPlayerStatsCounter  uint64
	beforePlayerStatsCounter uint64
	PlayerStatsMock          mMatcherMockPlayerStats

	funcSetBlueScore          func(score int)
	inspectFuncSetBlueScore   func(score int)
	afterSetBlueScoreCounter  uint64
	beforeSetBlueScoreCounter uint64
	SetBlueScoreMock          mMatcherMockSetBlueScore

	funcSetLength          func(msg string)
	inspectFuncSetLength   func(msg string)
	afterSetLengthCounter  uint64
	beforeSetLengthCounter uint64
	SetLengthMock          mMatcherMockSetLength

	funcSetMap          func(m string)
	inspectFuncSetMap   func(m string)
	afterSetMapCounter  uint64
	beforeSetMapCounter uint64
	SetMapMock          mMatcherMockSetMap

	funcSetPickupID          func(id int)
	inspectFuncSetPickupID   func(id int)
	afterSetPickupIDCounter  uint64
	beforeSetPickupIDCounter uint64
	SetPickupIDMock          mMatcherMockSetPickupID

	funcSetPlayerStats          func(stats mm_stats.PlayerStatsCollection)
	inspectFuncSetPlayerStats   func(stats mm_stats.PlayerStatsCollection)
	afterSetPlayerStatsCounter  uint64
	beforeSetPlayerStatsCounter uint64
	SetPlayerStatsMock          mMatcherMockSetPlayerStats

	funcSetPlayers          func(players []*mm_stats.PickupPlayer)
	inspectFuncSetPlayers   func(players []*mm_stats.PickupPlayer)
	afterSetPlayersCounter  uint64
	beforeSetPlayersCounter uint64
	SetPlayersMock          mMatcherMockSetPlayers

	funcSetRedScore          func(score int)
	inspectFuncSetRedScore   func(score int)
	afterSetRedScoreCounter  uint64
	beforeSetRedScoreCounter uint64
	SetRedScoreMock          mMatcherMockSetRedScore

	funcSetStartTime          func(msg string)
	inspectFuncSetStartTime   func(msg string)
	afterSetStartTimeCounter  uint64
	beforeSetStartTimeCounter uint64
	SetStartTimeMock          mMatcherMockSetStartTime

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mMatcherMockString

	funcTryParseGameMap          func(msg string)
	inspectFuncTryParseGameMap   func(msg string)
	afterTryParseGameMapCounter  uint64
	beforeTryParseGameMapCounter uint64
	TryParseGameMapMock          mMatcherMockTryParseGameMap
}

// NewMatcherMock returns a mock for stats.Matcher
func NewMatcherMock(t minimock.Tester) *MatcherMock {
	m := &MatcherMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DomainMock = mMatcherMockDomain{mock: m}

	m.FlushMock = mMatcherMockFlush{mock: m}

	m.LengthSecondsMock = mMatcherMockLengthSeconds{mock: m}

	m.MapMock = mMatcherMockMap{mock: m}

	m.PickupIDMock = mMatcherMockPickupID{mock: m}

	m.PickupPlayersMock = mMatcherMockPickupPlayers{mock: m}

	m.PlayerStatsMock = mMatcherMockPlayerStats{mock: m}

	m.SetBlueScoreMock = mMatcherMockSetBlueScore{mock: m}
	m.SetBlueScoreMock.callArgs = []*MatcherMockSetBlueScoreParams{}

	m.SetLengthMock = mMatcherMockSetLength{mock: m}
	m.SetLengthMock.callArgs = []*MatcherMockSetLengthParams{}

	m.SetMapMock = mMatcherMockSetMap{mock: m}
	m.SetMapMock.callArgs = []*MatcherMockSetMapParams{}

	m.SetPickupIDMock = mMatcherMockSetPickupID{mock: m}
	m.SetPickupIDMock.callArgs = []*MatcherMockSetPickupIDParams{}

	m.SetPlayerStatsMock = mMatcherMockSetPlayerStats{mock: m}
	m.SetPlayerStatsMock.callArgs = []*MatcherMockSetPlayerStatsParams{}

	m.SetPlayersMock = mMatcherMockSetPlayers{mock: m}
	m.SetPlayersMock.callArgs = []*MatcherMockSetPlayersParams{}

	m.SetRedScoreMock = mMatcherMockSetRedScore{mock: m}
	m.SetRedScoreMock.callArgs = []*MatcherMockSetRedScoreParams{}

	m.SetStartTimeMock = mMatcherMockSetStartTime{mock: m}
	m.SetStartTimeMock.callArgs = []*MatcherMockSetStartTimeParams{}

	m.StringMock = mMatcherMockString{mock: m}

	m.TryParseGameMapMock = mMatcherMockTryParseGameMap{mock: m}
	m.TryParseGameMapMock.callArgs = []*MatcherMockTryParseGameMapParams{}

	return m
}

type mMatcherMockDomain struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockDomainExpectation
	expectations       []*MatcherMockDomainExpectation
}

// MatcherMockDomainExpectation specifies expectation struct of the Matcher.Domain
type MatcherMockDomainExpectation struct {
	mock *MatcherMock

	results *MatcherMockDomainResults
	Counter uint64
}

// MatcherMockDomainResults contains results of the Matcher.Domain
type MatcherMockDomainResults struct {
	s1 string
}

// Expect sets up expected params for Matcher.Domain
func (mmDomain *mMatcherMockDomain) Expect() *mMatcherMockDomain {
	if mmDomain.mock.funcDomain != nil {
		mmDomain.mock.t.Fatalf("MatcherMock.Domain mock is already set by Set")
	}

	if mmDomain.defaultExpectation == nil {
		mmDomain.defaultExpectation = &MatcherMockDomainExpectation{}
	}

	return mmDomain
}

// Inspect accepts an inspector function that has same arguments as the Matcher.Domain
func (mmDomain *mMatcherMockDomain) Inspect(f func()) *mMatcherMockDomain {
	if mmDomain.mock.inspectFuncDomain != nil {
		mmDomain.mock.t.Fatalf("Inspect function is already set for MatcherMock.Domain")
	}

	mmDomain.mock.inspectFuncDomain = f

	return mmDomain
}

// Return sets up results that will be returned by Matcher.Domain
func (mmDomain *mMatcherMockDomain) Return(s1 string) *MatcherMock {
	if mmDomain.mock.funcDomain != nil {
		mmDomain.mock.t.Fatalf("MatcherMock.Domain mock is already set by Set")
	}

	if mmDomain.defaultExpectation == nil {
		mmDomain.defaultExpectation = &MatcherMockDomainExpectation{mock: mmDomain.mock}
	}
	mmDomain.defaultExpectation.results = &MatcherMockDomainResults{s1}
	return mmDomain.mock
}

//Set uses given function f to mock the Matcher.Domain method
func (mmDomain *mMatcherMockDomain) Set(f func() (s1 string)) *MatcherMock {
	if mmDomain.defaultExpectation != nil {
		mmDomain.mock.t.Fatalf("Default expectation is already set for the Matcher.Domain method")
	}

	if len(mmDomain.expectations) > 0 {
		mmDomain.mock.t.Fatalf("Some expectations are already set for the Matcher.Domain method")
	}

	mmDomain.mock.funcDomain = f
	return mmDomain.mock
}

// Domain implements stats.Matcher
func (mmDomain *MatcherMock) Domain() (s1 string) {
	mm_atomic.AddUint64(&mmDomain.beforeDomainCounter, 1)
	defer mm_atomic.AddUint64(&mmDomain.afterDomainCounter, 1)

	if mmDomain.inspectFuncDomain != nil {
		mmDomain.inspectFuncDomain()
	}

	if mmDomain.DomainMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDomain.DomainMock.defaultExpectation.Counter, 1)

		mm_results := mmDomain.DomainMock.defaultExpectation.results
		if mm_results == nil {
			mmDomain.t.Fatal("No results are set for the MatcherMock.Domain")
		}
		return (*mm_results).s1
	}
	if mmDomain.funcDomain != nil {
		return mmDomain.funcDomain()
	}
	mmDomain.t.Fatalf("Unexpected call to MatcherMock.Domain.")
	return
}

// DomainAfterCounter returns a count of finished MatcherMock.Domain invocations
func (mmDomain *MatcherMock) DomainAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDomain.afterDomainCounter)
}

// DomainBeforeCounter returns a count of MatcherMock.Domain invocations
func (mmDomain *MatcherMock) DomainBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDomain.beforeDomainCounter)
}

// MinimockDomainDone returns true if the count of the Domain invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockDomainDone() bool {
	for _, e := range m.DomainMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DomainMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDomainCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDomain != nil && mm_atomic.LoadUint64(&m.afterDomainCounter) < 1 {
		return false
	}
	return true
}

// MinimockDomainInspect logs each unmet expectation
func (m *MatcherMock) MinimockDomainInspect() {
	for _, e := range m.DomainMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatcherMock.Domain")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DomainMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDomainCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.Domain")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDomain != nil && mm_atomic.LoadUint64(&m.afterDomainCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.Domain")
	}
}

type mMatcherMockFlush struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockFlushExpectation
	expectations       []*MatcherMockFlushExpectation
}

// MatcherMockFlushExpectation specifies expectation struct of the Matcher.Flush
type MatcherMockFlushExpectation struct {
	mock *MatcherMock

	Counter uint64
}

// Expect sets up expected params for Matcher.Flush
func (mmFlush *mMatcherMockFlush) Expect() *mMatcherMockFlush {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("MatcherMock.Flush mock is already set by Set")
	}

	if mmFlush.defaultExpectation == nil {
		mmFlush.defaultExpectation = &MatcherMockFlushExpectation{}
	}

	return mmFlush
}

// Inspect accepts an inspector function that has same arguments as the Matcher.Flush
func (mmFlush *mMatcherMockFlush) Inspect(f func()) *mMatcherMockFlush {
	if mmFlush.mock.inspectFuncFlush != nil {
		mmFlush.mock.t.Fatalf("Inspect function is already set for MatcherMock.Flush")
	}

	mmFlush.mock.inspectFuncFlush = f

	return mmFlush
}

// Return sets up results that will be returned by Matcher.Flush
func (mmFlush *mMatcherMockFlush) Return() *MatcherMock {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("MatcherMock.Flush mock is already set by Set")
	}

	if mmFlush.defaultExpectation == nil {
		mmFlush.defaultExpectation = &MatcherMockFlushExpectation{mock: mmFlush.mock}
	}

	return mmFlush.mock
}

//Set uses given function f to mock the Matcher.Flush method
func (mmFlush *mMatcherMockFlush) Set(f func()) *MatcherMock {
	if mmFlush.defaultExpectation != nil {
		mmFlush.mock.t.Fatalf("Default expectation is already set for the Matcher.Flush method")
	}

	if len(mmFlush.expectations) > 0 {
		mmFlush.mock.t.Fatalf("Some expectations are already set for the Matcher.Flush method")
	}

	mmFlush.mock.funcFlush = f
	return mmFlush.mock
}

// Flush implements stats.Matcher
func (mmFlush *MatcherMock) Flush() {
	mm_atomic.AddUint64(&mmFlush.beforeFlushCounter, 1)
	defer mm_atomic.AddUint64(&mmFlush.afterFlushCounter, 1)

	if mmFlush.inspectFuncFlush != nil {
		mmFlush.inspectFuncFlush()
	}

	if mmFlush.FlushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlush.FlushMock.defaultExpectation.Counter, 1)

		return

	}
	if mmFlush.funcFlush != nil {
		mmFlush.funcFlush()
		return
	}
	mmFlush.t.Fatalf("Unexpected call to MatcherMock.Flush.")

}

// FlushAfterCounter returns a count of finished MatcherMock.Flush invocations
func (mmFlush *MatcherMock) FlushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlush.afterFlushCounter)
}

// FlushBeforeCounter returns a count of MatcherMock.Flush invocations
func (mmFlush *MatcherMock) FlushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlush.beforeFlushCounter)
}

// MinimockFlushDone returns true if the count of the Flush invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockFlushDone() bool {
	for _, e := range m.FlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlush != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		return false
	}
	return true
}

// MinimockFlushInspect logs each unmet expectation
func (m *MatcherMock) MinimockFlushInspect() {
	for _, e := range m.FlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatcherMock.Flush")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.Flush")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlush != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.Flush")
	}
}

type mMatcherMockLengthSeconds struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockLengthSecondsExpectation
	expectations       []*MatcherMockLengthSecondsExpectation
}

// MatcherMockLengthSecondsExpectation specifies expectation struct of the Matcher.LengthSeconds
type MatcherMockLengthSecondsExpectation struct {
	mock *MatcherMock

	results *MatcherMockLengthSecondsResults
	Counter uint64
}

// MatcherMockLengthSecondsResults contains results of the Matcher.LengthSeconds
type MatcherMockLengthSecondsResults struct {
	i1 int
}

// Expect sets up expected params for Matcher.LengthSeconds
func (mmLengthSeconds *mMatcherMockLengthSeconds) Expect() *mMatcherMockLengthSeconds {
	if mmLengthSeconds.mock.funcLengthSeconds != nil {
		mmLengthSeconds.mock.t.Fatalf("MatcherMock.LengthSeconds mock is already set by Set")
	}

	if mmLengthSeconds.defaultExpectation == nil {
		mmLengthSeconds.defaultExpectation = &MatcherMockLengthSecondsExpectation{}
	}

	return mmLengthSeconds
}

// Inspect accepts an inspector function that has same arguments as the Matcher.LengthSeconds
func (mmLengthSeconds *mMatcherMockLengthSeconds) Inspect(f func()) *mMatcherMockLengthSeconds {
	if mmLengthSeconds.mock.inspectFuncLengthSeconds != nil {
		mmLengthSeconds.mock.t.Fatalf("Inspect function is already set for MatcherMock.LengthSeconds")
	}

	mmLengthSeconds.mock.inspectFuncLengthSeconds = f

	return mmLengthSeconds
}

// Return sets up results that will be returned by Matcher.LengthSeconds
func (mmLengthSeconds *mMatcherMockLengthSeconds) Return(i1 int) *MatcherMock {
	if mmLengthSeconds.mock.funcLengthSeconds != nil {
		mmLengthSeconds.mock.t.Fatalf("MatcherMock.LengthSeconds mock is already set by Set")
	}

	if mmLengthSeconds.defaultExpectation == nil {
		mmLengthSeconds.defaultExpectation = &MatcherMockLengthSecondsExpectation{mock: mmLengthSeconds.mock}
	}
	mmLengthSeconds.defaultExpectation.results = &MatcherMockLengthSecondsResults{i1}
	return mmLengthSeconds.mock
}

//Set uses given function f to mock the Matcher.LengthSeconds method
func (mmLengthSeconds *mMatcherMockLengthSeconds) Set(f func() (i1 int)) *MatcherMock {
	if mmLengthSeconds.defaultExpectation != nil {
		mmLengthSeconds.mock.t.Fatalf("Default expectation is already set for the Matcher.LengthSeconds method")
	}

	if len(mmLengthSeconds.expectations) > 0 {
		mmLengthSeconds.mock.t.Fatalf("Some expectations are already set for the Matcher.LengthSeconds method")
	}

	mmLengthSeconds.mock.funcLengthSeconds = f
	return mmLengthSeconds.mock
}

// LengthSeconds implements stats.Matcher
func (mmLengthSeconds *MatcherMock) LengthSeconds() (i1 int) {
	mm_atomic.AddUint64(&mmLengthSeconds.beforeLengthSecondsCounter, 1)
	defer mm_atomic.AddUint64(&mmLengthSeconds.afterLengthSecondsCounter, 1)

	if mmLengthSeconds.inspectFuncLengthSeconds != nil {
		mmLengthSeconds.inspectFuncLengthSeconds()
	}

	if mmLengthSeconds.LengthSecondsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLengthSeconds.LengthSecondsMock.defaultExpectation.Counter, 1)

		mm_results := mmLengthSeconds.LengthSecondsMock.defaultExpectation.results
		if mm_results == nil {
			mmLengthSeconds.t.Fatal("No results are set for the MatcherMock.LengthSeconds")
		}
		return (*mm_results).i1
	}
	if mmLengthSeconds.funcLengthSeconds != nil {
		return mmLengthSeconds.funcLengthSeconds()
	}
	mmLengthSeconds.t.Fatalf("Unexpected call to MatcherMock.LengthSeconds.")
	return
}

// LengthSecondsAfterCounter returns a count of finished MatcherMock.LengthSeconds invocations
func (mmLengthSeconds *MatcherMock) LengthSecondsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLengthSeconds.afterLengthSecondsCounter)
}

// LengthSecondsBeforeCounter returns a count of MatcherMock.LengthSeconds invocations
func (mmLengthSeconds *MatcherMock) LengthSecondsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLengthSeconds.beforeLengthSecondsCounter)
}

// MinimockLengthSecondsDone returns true if the count of the LengthSeconds invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockLengthSecondsDone() bool {
	for _, e := range m.LengthSecondsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthSecondsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthSecondsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLengthSeconds != nil && mm_atomic.LoadUint64(&m.afterLengthSecondsCounter) < 1 {
		return false
	}
	return true
}

// MinimockLengthSecondsInspect logs each unmet expectation
func (m *MatcherMock) MinimockLengthSecondsInspect() {
	for _, e := range m.LengthSecondsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatcherMock.LengthSeconds")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthSecondsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthSecondsCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.LengthSeconds")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLengthSeconds != nil && mm_atomic.LoadUint64(&m.afterLengthSecondsCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.LengthSeconds")
	}
}

type mMatcherMockMap struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockMapExpectation
	expectations       []*MatcherMockMapExpectation
}

// MatcherMockMapExpectation specifies expectation struct of the Matcher.Map
type MatcherMockMapExpectation struct {
	mock *MatcherMock

	results *MatcherMockMapResults
	Counter uint64
}

// MatcherMockMapResults contains results of the Matcher.Map
type MatcherMockMapResults struct {
	s1 string
}

// Expect sets up expected params for Matcher.Map
func (mmMap *mMatcherMockMap) Expect() *mMatcherMockMap {
	if mmMap.mock.funcMap != nil {
		mmMap.mock.t.Fatalf("MatcherMock.Map mock is already set by Set")
	}

	if mmMap.defaultExpectation == nil {
		mmMap.defaultExpectation = &MatcherMockMapExpectation{}
	}

	return mmMap
}

// Inspect accepts an inspector function that has same arguments as the Matcher.Map
func (mmMap *mMatcherMockMap) Inspect(f func()) *mMatcherMockMap {
	if mmMap.mock.inspectFuncMap != nil {
		mmMap.mock.t.Fatalf("Inspect function is already set for MatcherMock.Map")
	}

	mmMap.mock.inspectFuncMap = f

	return mmMap
}

// Return sets up results that will be returned by Matcher.Map
func (mmMap *mMatcherMockMap) Return(s1 string) *MatcherMock {
	if mmMap.mock.funcMap != nil {
		mmMap.mock.t.Fatalf("MatcherMock.Map mock is already set by Set")
	}

	if mmMap.defaultExpectation == nil {
		mmMap.defaultExpectation = &MatcherMockMapExpectation{mock: mmMap.mock}
	}
	mmMap.defaultExpectation.results = &MatcherMockMapResults{s1}
	return mmMap.mock
}

//Set uses given function f to mock the Matcher.Map method
func (mmMap *mMatcherMockMap) Set(f func() (s1 string)) *MatcherMock {
	if mmMap.defaultExpectation != nil {
		mmMap.mock.t.Fatalf("Default expectation is already set for the Matcher.Map method")
	}

	if len(mmMap.expectations) > 0 {
		mmMap.mock.t.Fatalf("Some expectations are already set for the Matcher.Map method")
	}

	mmMap.mock.funcMap = f
	return mmMap.mock
}

// Map implements stats.Matcher
func (mmMap *MatcherMock) Map() (s1 string) {
	mm_atomic.AddUint64(&mmMap.beforeMapCounter, 1)
	defer mm_atomic.AddUint64(&mmMap.afterMapCounter, 1)

	if mmMap.inspectFuncMap != nil {
		mmMap.inspectFuncMap()
	}

	if mmMap.MapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMap.MapMock.defaultExpectation.Counter, 1)

		mm_results := mmMap.MapMock.defaultExpectation.results
		if mm_results == nil {
			mmMap.t.Fatal("No results are set for the MatcherMock.Map")
		}
		return (*mm_results).s1
	}
	if mmMap.funcMap != nil {
		return mmMap.funcMap()
	}
	mmMap.t.Fatalf("Unexpected call to MatcherMock.Map.")
	return
}

// MapAfterCounter returns a count of finished MatcherMock.Map invocations
func (mmMap *MatcherMock) MapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMap.afterMapCounter)
}

// MapBeforeCounter returns a count of MatcherMock.Map invocations
func (mmMap *MatcherMock) MapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMap.beforeMapCounter)
}

// MinimockMapDone returns true if the count of the Map invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockMapDone() bool {
	for _, e := range m.MapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMap != nil && mm_atomic.LoadUint64(&m.afterMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockMapInspect logs each unmet expectation
func (m *MatcherMock) MinimockMapInspect() {
	for _, e := range m.MapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatcherMock.Map")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMapCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.Map")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMap != nil && mm_atomic.LoadUint64(&m.afterMapCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.Map")
	}
}

type mMatcherMockPickupID struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockPickupIDExpectation
	expectations       []*MatcherMockPickupIDExpectation
}

// MatcherMockPickupIDExpectation specifies expectation struct of the Matcher.PickupID
type MatcherMockPickupIDExpectation struct {
	mock *MatcherMock

	results *MatcherMockPickupIDResults
	Counter uint64
}

// MatcherMockPickupIDResults contains results of the Matcher.PickupID
type MatcherMockPickupIDResults struct {
	i1 int
}

// Expect sets up expected params for Matcher.PickupID
func (mmPickupID *mMatcherMockPickupID) Expect() *mMatcherMockPickupID {
	if mmPickupID.mock.funcPickupID != nil {
		mmPickupID.mock.t.Fatalf("MatcherMock.PickupID mock is already set by Set")
	}

	if mmPickupID.defaultExpectation == nil {
		mmPickupID.defaultExpectation = &MatcherMockPickupIDExpectation{}
	}

	return mmPickupID
}

// Inspect accepts an inspector function that has same arguments as the Matcher.PickupID
func (mmPickupID *mMatcherMockPickupID) Inspect(f func()) *mMatcherMockPickupID {
	if mmPickupID.mock.inspectFuncPickupID != nil {
		mmPickupID.mock.t.Fatalf("Inspect function is already set for MatcherMock.PickupID")
	}

	mmPickupID.mock.inspectFuncPickupID = f

	return mmPickupID
}

// Return sets up results that will be returned by Matcher.PickupID
func (mmPickupID *mMatcherMockPickupID) Return(i1 int) *MatcherMock {
	if mmPickupID.mock.funcPickupID != nil {
		mmPickupID.mock.t.Fatalf("MatcherMock.PickupID mock is already set by Set")
	}

	if mmPickupID.defaultExpectation == nil {
		mmPickupID.defaultExpectation = &MatcherMockPickupIDExpectation{mock: mmPickupID.mock}
	}
	mmPickupID.defaultExpectation.results = &MatcherMockPickupIDResults{i1}
	return mmPickupID.mock
}

//Set uses given function f to mock the Matcher.PickupID method
func (mmPickupID *mMatcherMockPickupID) Set(f func() (i1 int)) *MatcherMock {
	if mmPickupID.defaultExpectation != nil {
		mmPickupID.mock.t.Fatalf("Default expectation is already set for the Matcher.PickupID method")
	}

	if len(mmPickupID.expectations) > 0 {
		mmPickupID.mock.t.Fatalf("Some expectations are already set for the Matcher.PickupID method")
	}

	mmPickupID.mock.funcPickupID = f
	return mmPickupID.mock
}

// PickupID implements stats.Matcher
func (mmPickupID *MatcherMock) PickupID() (i1 int) {
	mm_atomic.AddUint64(&mmPickupID.beforePickupIDCounter, 1)
	defer mm_atomic.AddUint64(&mmPickupID.afterPickupIDCounter, 1)

	if mmPickupID.inspectFuncPickupID != nil {
		mmPickupID.inspectFuncPickupID()
	}

	if mmPickupID.PickupIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPickupID.PickupIDMock.defaultExpectation.Counter, 1)

		mm_results := mmPickupID.PickupIDMock.defaultExpectation.results
		if mm_results == nil {
			mmPickupID.t.Fatal("No results are set for the MatcherMock.PickupID")
		}
		return (*mm_results).i1
	}
	if mmPickupID.funcPickupID != nil {
		return mmPickupID.funcPickupID()
	}
	mmPickupID.t.Fatalf("Unexpected call to MatcherMock.PickupID.")
	return
}

// PickupIDAfterCounter returns a count of finished MatcherMock.PickupID invocations
func (mmPickupID *MatcherMock) PickupIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickupID.afterPickupIDCounter)
}

// PickupIDBeforeCounter returns a count of MatcherMock.PickupID invocations
func (mmPickupID *MatcherMock) PickupIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickupID.beforePickupIDCounter)
}

// MinimockPickupIDDone returns true if the count of the PickupID invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockPickupIDDone() bool {
	for _, e := range m.PickupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PickupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPickupIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickupID != nil && mm_atomic.LoadUint64(&m.afterPickupIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockPickupIDInspect logs each unmet expectation
func (m *MatcherMock) MinimockPickupIDInspect() {
	for _, e := range m.PickupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatcherMock.PickupID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PickupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPickupIDCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.PickupID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickupID != nil && mm_atomic.LoadUint64(&m.afterPickupIDCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.PickupID")
	}
}

type mMatcherMockPickupPlayers struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockPickupPlayersExpectation
	expectations       []*MatcherMockPickupPlayersExpectation
}

// MatcherMockPickupPlayersExpectation specifies expectation struct of the Matcher.PickupPlayers
type MatcherMockPickupPlayersExpectation struct {
	mock *MatcherMock

	results *MatcherMockPickupPlayersResults
	Counter uint64
}

// MatcherMockPickupPlayersResults contains results of the Matcher.PickupPlayers
type MatcherMockPickupPlayersResults struct {
	ppa1 []*mm_stats.PickupPlayer
}

// Expect sets up expected params for Matcher.PickupPlayers
func (mmPickupPlayers *mMatcherMockPickupPlayers) Expect() *mMatcherMockPickupPlayers {
	if mmPickupPlayers.mock.funcPickupPlayers != nil {
		mmPickupPlayers.mock.t.Fatalf("MatcherMock.PickupPlayers mock is already set by Set")
	}

	if mmPickupPlayers.defaultExpectation == nil {
		mmPickupPlayers.defaultExpectation = &MatcherMockPickupPlayersExpectation{}
	}

	return mmPickupPlayers
}

// Inspect accepts an inspector function that has same arguments as the Matcher.PickupPlayers
func (mmPickupPlayers *mMatcherMockPickupPlayers) Inspect(f func()) *mMatcherMockPickupPlayers {
	if mmPickupPlayers.mock.inspectFuncPickupPlayers != nil {
		mmPickupPlayers.mock.t.Fatalf("Inspect function is already set for MatcherMock.PickupPlayers")
	}

	mmPickupPlayers.mock.inspectFuncPickupPlayers = f

	return mmPickupPlayers
}

// Return sets up results that will be returned by Matcher.PickupPlayers
func (mmPickupPlayers *mMatcherMockPickupPlayers) Return(ppa1 []*mm_stats.PickupPlayer) *MatcherMock {
	if mmPickupPlayers.mock.funcPickupPlayers != nil {
		mmPickupPlayers.mock.t.Fatalf("MatcherMock.PickupPlayers mock is already set by Set")
	}

	if mmPickupPlayers.defaultExpectation == nil {
		mmPickupPlayers.defaultExpectation = &MatcherMockPickupPlayersExpectation{mock: mmPickupPlayers.mock}
	}
	mmPickupPlayers.defaultExpectation.results = &MatcherMockPickupPlayersResults{ppa1}
	return mmPickupPlayers.mock
}

//Set uses given function f to mock the Matcher.PickupPlayers method
func (mmPickupPlayers *mMatcherMockPickupPlayers) Set(f func() (ppa1 []*mm_stats.PickupPlayer)) *MatcherMock {
	if mmPickupPlayers.defaultExpectation != nil {
		mmPickupPlayers.mock.t.Fatalf("Default expectation is already set for the Matcher.PickupPlayers method")
	}

	if len(mmPickupPlayers.expectations) > 0 {
		mmPickupPlayers.mock.t.Fatalf("Some expectations are already set for the Matcher.PickupPlayers method")
	}

	mmPickupPlayers.mock.funcPickupPlayers = f
	return mmPickupPlayers.mock
}

// PickupPlayers implements stats.Matcher
func (mmPickupPlayers *MatcherMock) PickupPlayers() (ppa1 []*mm_stats.PickupPlayer) {
	mm_atomic.AddUint64(&mmPickupPlayers.beforePickupPlayersCounter, 1)
	defer mm_atomic.AddUint64(&mmPickupPlayers.afterPickupPlayersCounter, 1)

	if mmPickupPlayers.inspectFuncPickupPlayers != nil {
		mmPickupPlayers.inspectFuncPickupPlayers()
	}

	if mmPickupPlayers.PickupPlayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPickupPlayers.PickupPlayersMock.defaultExpectation.Counter, 1)

		mm_results := mmPickupPlayers.PickupPlayersMock.defaultExpectation.results
		if mm_results == nil {
			mmPickupPlayers.t.Fatal("No results are set for the MatcherMock.PickupPlayers")
		}
		return (*mm_results).ppa1
	}
	if mmPickupPlayers.funcPickupPlayers != nil {
		return mmPickupPlayers.funcPickupPlayers()
	}
	mmPickupPlayers.t.Fatalf("Unexpected call to MatcherMock.PickupPlayers.")
	return
}

// PickupPlayersAfterCounter returns a count of finished MatcherMock.PickupPlayers invocations
func (mmPickupPlayers *MatcherMock) PickupPlayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickupPlayers.afterPickupPlayersCounter)
}

// PickupPlayersBeforeCounter returns a count of MatcherMock.PickupPlayers invocations
func (mmPickupPlayers *MatcherMock) PickupPlayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickupPlayers.beforePickupPlayersCounter)
}

// MinimockPickupPlayersDone returns true if the count of the PickupPlayers invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockPickupPlayersDone() bool {
	for _, e := range m.PickupPlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PickupPlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPickupPlayersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickupPlayers != nil && mm_atomic.LoadUint64(&m.afterPickupPlayersCounter) < 1 {
		return false
	}
	return true
}

// MinimockPickupPlayersInspect logs each unmet expectation
func (m *MatcherMock) MinimockPickupPlayersInspect() {
	for _, e := range m.PickupPlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatcherMock.PickupPlayers")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PickupPlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPickupPlayersCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.PickupPlayers")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickupPlayers != nil && mm_atomic.LoadUint64(&m.afterPickupPlayersCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.PickupPlayers")
	}
}

type mMatcherMockPlayerStats struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockPlayerStatsExpectation
	expectations       []*MatcherMockPlayerStatsExpectation
}

// MatcherMockPlayerStatsExpectation specifies expectation struct of the Matcher.PlayerStats
type MatcherMockPlayerStatsExpectation struct {
	mock *MatcherMock

	results *MatcherMockPlayerStatsResults
	Counter uint64
}

// MatcherMockPlayerStatsResults contains results of the Matcher.PlayerStats
type MatcherMockPlayerStatsResults struct {
	p1 mm_stats.PlayerStatsCollection
}

// Expect sets up expected params for Matcher.PlayerStats
func (mmPlayerStats *mMatcherMockPlayerStats) Expect() *mMatcherMockPlayerStats {
	if mmPlayerStats.mock.funcPlayerStats != nil {
		mmPlayerStats.mock.t.Fatalf("MatcherMock.PlayerStats mock is already set by Set")
	}

	if mmPlayerStats.defaultExpectation == nil {
		mmPlayerStats.defaultExpectation = &MatcherMockPlayerStatsExpectation{}
	}

	return mmPlayerStats
}

// Inspect accepts an inspector function that has same arguments as the Matcher.PlayerStats
func (mmPlayerStats *mMatcherMockPlayerStats) Inspect(f func()) *mMatcherMockPlayerStats {
	if mmPlayerStats.mock.inspectFuncPlayerStats != nil {
		mmPlayerStats.mock.t.Fatalf("Inspect function is already set for MatcherMock.PlayerStats")
	}

	mmPlayerStats.mock.inspectFuncPlayerStats = f

	return mmPlayerStats
}

// Return sets up results that will be returned by Matcher.PlayerStats
func (mmPlayerStats *mMatcherMockPlayerStats) Return(p1 mm_stats.PlayerStatsCollection) *MatcherMock {
	if mmPlayerStats.mock.funcPlayerStats != nil {
		mmPlayerStats.mock.t.Fatalf("MatcherMock.PlayerStats mock is already set by Set")
	}

	if mmPlayerStats.defaultExpectation == nil {
		mmPlayerStats.defaultExpectation = &MatcherMockPlayerStatsExpectation{mock: mmPlayerStats.mock}
	}
	mmPlayerStats.defaultExpectation.results = &MatcherMockPlayerStatsResults{p1}
	return mmPlayerStats.mock
}

//Set uses given function f to mock the Matcher.PlayerStats method
func (mmPlayerStats *mMatcherMockPlayerStats) Set(f func() (p1 mm_stats.PlayerStatsCollection)) *MatcherMock {
	if mmPlayerStats.defaultExpectation != nil {
		mmPlayerStats.mock.t.Fatalf("Default expectation is already set for the Matcher.PlayerStats method")
	}

	if len(mmPlayerStats.expectations) > 0 {
		mmPlayerStats.mock.t.Fatalf("Some expectations are already set for the Matcher.PlayerStats method")
	}

	mmPlayerStats.mock.funcPlayerStats = f
	return mmPlayerStats.mock
}

// PlayerStats implements stats.Matcher
func (mmPlayerStats *MatcherMock) PlayerStats() (p1 mm_stats.PlayerStatsCollection) {
	mm_atomic.AddUint64(&mmPlayerStats.beforePlayerStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmPlayerStats.afterPlayerStatsCounter, 1)

	if mmPlayerStats.inspectFuncPlayerStats != nil {
		mmPlayerStats.inspectFuncPlayerStats()
	}

	if mmPlayerStats.PlayerStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPlayerStats.PlayerStatsMock.defaultExpectation.Counter, 1)

		mm_results := mmPlayerStats.PlayerStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmPlayerStats.t.Fatal("No results are set for the MatcherMock.PlayerStats")
		}
		return (*mm_results).p1
	}
	if mmPlayerStats.funcPlayerStats != nil {
		return mmPlayerStats.funcPlayerStats()
	}
	mmPlayerStats.t.Fatalf("Unexpected call to MatcherMock.PlayerStats.")
	return
}

// PlayerStatsAfterCounter returns a count of finished MatcherMock.PlayerStats invocations
func (mmPlayerStats *MatcherMock) PlayerStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPlayerStats.afterPlayerStatsCounter)
}

// PlayerStatsBeforeCounter returns a count of MatcherMock.PlayerStats invocations
func (mmPlayerStats *MatcherMock) PlayerStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPlayerStats.beforePlayerStatsCounter)
}

// MinimockPlayerStatsDone returns true if the count of the PlayerStats invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockPlayerStatsDone() bool {
	for _, e := range m.PlayerStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PlayerStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPlayerStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPlayerStats != nil && mm_atomic.LoadUint64(&m.afterPlayerStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockPlayerStatsInspect logs each unmet expectation
func (m *MatcherMock) MinimockPlayerStatsInspect() {
	for _, e := range m.PlayerStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatcherMock.PlayerStats")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PlayerStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPlayerStatsCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.PlayerStats")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPlayerStats != nil && mm_atomic.LoadUint64(&m.afterPlayerStatsCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.PlayerStats")
	}
}

type mMatcherMockSetBlueScore struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockSetBlueScoreExpectation
	expectations       []*MatcherMockSetBlueScoreExpectation

	callArgs []*MatcherMockSetBlueScoreParams
	mutex    sync.RWMutex
}

// MatcherMockSetBlueScoreExpectation specifies expectation struct of the Matcher.SetBlueScore
type MatcherMockSetBlueScoreExpectation struct {
	mock   *MatcherMock
	params *MatcherMockSetBlueScoreParams

	Counter uint64
}

// MatcherMockSetBlueScoreParams contains parameters of the Matcher.SetBlueScore
type MatcherMockSetBlueScoreParams struct {
	score int
}

// Expect sets up expected params for Matcher.SetBlueScore
func (mmSetBlueScore *mMatcherMockSetBlueScore) Expect(score int) *mMatcherMockSetBlueScore {
	if mmSetBlueScore.mock.funcSetBlueScore != nil {
		mmSetBlueScore.mock.t.Fatalf("MatcherMock.SetBlueScore mock is already set by Set")
	}

	if mmSetBlueScore.defaultExpectation == nil {
		mmSetBlueScore.defaultExpectation = &MatcherMockSetBlueScoreExpectation{}
	}

	mmSetBlueScore.defaultExpectation.params = &MatcherMockSetBlueScoreParams{score}
	for _, e := range mmSetBlueScore.expectations {
		if minimock.Equal(e.params, mmSetBlueScore.defaultExpectation.params) {
			mmSetBlueScore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetBlueScore.defaultExpectation.params)
		}
	}

	return mmSetBlueScore
}

// Inspect accepts an inspector function that has same arguments as the Matcher.SetBlueScore
func (mmSetBlueScore *mMatcherMockSetBlueScore) Inspect(f func(score int)) *mMatcherMockSetBlueScore {
	if mmSetBlueScore.mock.inspectFuncSetBlueScore != nil {
		mmSetBlueScore.mock.t.Fatalf("Inspect function is already set for MatcherMock.SetBlueScore")
	}

	mmSetBlueScore.mock.inspectFuncSetBlueScore = f

	return mmSetBlueScore
}

// Return sets up results that will be returned by Matcher.SetBlueScore
func (mmSetBlueScore *mMatcherMockSetBlueScore) Return() *MatcherMock {
	if mmSetBlueScore.mock.funcSetBlueScore != nil {
		mmSetBlueScore.mock.t.Fatalf("MatcherMock.SetBlueScore mock is already set by Set")
	}

	if mmSetBlueScore.defaultExpectation == nil {
		mmSetBlueScore.defaultExpectation = &MatcherMockSetBlueScoreExpectation{mock: mmSetBlueScore.mock}
	}

	return mmSetBlueScore.mock
}

//Set uses given function f to mock the Matcher.SetBlueScore method
func (mmSetBlueScore *mMatcherMockSetBlueScore) Set(f func(score int)) *MatcherMock {
	if mmSetBlueScore.defaultExpectation != nil {
		mmSetBlueScore.mock.t.Fatalf("Default expectation is already set for the Matcher.SetBlueScore method")
	}

	if len(mmSetBlueScore.expectations) > 0 {
		mmSetBlueScore.mock.t.Fatalf("Some expectations are already set for the Matcher.SetBlueScore method")
	}

	mmSetBlueScore.mock.funcSetBlueScore = f
	return mmSetBlueScore.mock
}

// SetBlueScore implements stats.Matcher
func (mmSetBlueScore *MatcherMock) SetBlueScore(score int) {
	mm_atomic.AddUint64(&mmSetBlueScore.beforeSetBlueScoreCounter, 1)
	defer mm_atomic.AddUint64(&mmSetBlueScore.afterSetBlueScoreCounter, 1)

	if mmSetBlueScore.inspectFuncSetBlueScore != nil {
		mmSetBlueScore.inspectFuncSetBlueScore(score)
	}

	mm_params := &MatcherMockSetBlueScoreParams{score}

	// Record call args
	mmSetBlueScore.SetBlueScoreMock.mutex.Lock()
	mmSetBlueScore.SetBlueScoreMock.callArgs = append(mmSetBlueScore.SetBlueScoreMock.callArgs, mm_params)
	mmSetBlueScore.SetBlueScoreMock.mutex.Unlock()

	for _, e := range mmSetBlueScore.SetBlueScoreMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetBlueScore.SetBlueScoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetBlueScore.SetBlueScoreMock.defaultExpectation.Counter, 1)
		mm_want := mmSetBlueScore.SetBlueScoreMock.defaultExpectation.params
		mm_got := MatcherMockSetBlueScoreParams{score}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetBlueScore.t.Errorf("MatcherMock.SetBlueScore got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetBlueScore.funcSetBlueScore != nil {
		mmSetBlueScore.funcSetBlueScore(score)
		return
	}
	mmSetBlueScore.t.Fatalf("Unexpected call to MatcherMock.SetBlueScore. %v", score)

}

// SetBlueScoreAfterCounter returns a count of finished MatcherMock.SetBlueScore invocations
func (mmSetBlueScore *MatcherMock) SetBlueScoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetBlueScore.afterSetBlueScoreCounter)
}

// SetBlueScoreBeforeCounter returns a count of MatcherMock.SetBlueScore invocations
func (mmSetBlueScore *MatcherMock) SetBlueScoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetBlueScore.beforeSetBlueScoreCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.SetBlueScore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetBlueScore *mMatcherMockSetBlueScore) Calls() []*MatcherMockSetBlueScoreParams {
	mmSetBlueScore.mutex.RLock()

	argCopy := make([]*MatcherMockSetBlueScoreParams, len(mmSetBlueScore.callArgs))
	copy(argCopy, mmSetBlueScore.callArgs)

	mmSetBlueScore.mutex.RUnlock()

	return argCopy
}

// MinimockSetBlueScoreDone returns true if the count of the SetBlueScore invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockSetBlueScoreDone() bool {
	for _, e := range m.SetBlueScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetBlueScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetBlueScoreCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetBlueScore != nil && mm_atomic.LoadUint64(&m.afterSetBlueScoreCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetBlueScoreInspect logs each unmet expectation
func (m *MatcherMock) MinimockSetBlueScoreInspect() {
	for _, e := range m.SetBlueScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.SetBlueScore with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetBlueScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetBlueScoreCounter) < 1 {
		if m.SetBlueScoreMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.SetBlueScore")
		} else {
			m.t.Errorf("Expected call to MatcherMock.SetBlueScore with params: %#v", *m.SetBlueScoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetBlueScore != nil && mm_atomic.LoadUint64(&m.afterSetBlueScoreCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.SetBlueScore")
	}
}

type mMatcherMockSetLength struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockSetLengthExpectation
	expectations       []*MatcherMockSetLengthExpectation

	callArgs []*MatcherMockSetLengthParams
	mutex    sync.RWMutex
}

// MatcherMockSetLengthExpectation specifies expectation struct of the Matcher.SetLength
type MatcherMockSetLengthExpectation struct {
	mock   *MatcherMock
	params *MatcherMockSetLengthParams

	Counter uint64
}

// MatcherMockSetLengthParams contains parameters of the Matcher.SetLength
type MatcherMockSetLengthParams struct {
	msg string
}

// Expect sets up expected params for Matcher.SetLength
func (mmSetLength *mMatcherMockSetLength) Expect(msg string) *mMatcherMockSetLength {
	if mmSetLength.mock.funcSetLength != nil {
		mmSetLength.mock.t.Fatalf("MatcherMock.SetLength mock is already set by Set")
	}

	if mmSetLength.defaultExpectation == nil {
		mmSetLength.defaultExpectation = &MatcherMockSetLengthExpectation{}
	}

	mmSetLength.defaultExpectation.params = &MatcherMockSetLengthParams{msg}
	for _, e := range mmSetLength.expectations {
		if minimock.Equal(e.params, mmSetLength.defaultExpectation.params) {
			mmSetLength.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetLength.defaultExpectation.params)
		}
	}

	return mmSetLength
}

// Inspect accepts an inspector function that has same arguments as the Matcher.SetLength
func (mmSetLength *mMatcherMockSetLength) Inspect(f func(msg string)) *mMatcherMockSetLength {
	if mmSetLength.mock.inspectFuncSetLength != nil {
		mmSetLength.mock.t.Fatalf("Inspect function is already set for MatcherMock.SetLength")
	}

	mmSetLength.mock.inspectFuncSetLength = f

	return mmSetLength
}

// Return sets up results that will be returned by Matcher.SetLength
func (mmSetLength *mMatcherMockSetLength) Return() *MatcherMock {
	if mmSetLength.mock.funcSetLength != nil {
		mmSetLength.mock.t.Fatalf("MatcherMock.SetLength mock is already set by Set")
	}

	if mmSetLength.defaultExpectation == nil {
		mmSetLength.defaultExpectation = &MatcherMockSetLengthExpectation{mock: mmSetLength.mock}
	}

	return mmSetLength.mock
}

//Set uses given function f to mock the Matcher.SetLength method
func (mmSetLength *mMatcherMockSetLength) Set(f func(msg string)) *MatcherMock {
	if mmSetLength.defaultExpectation != nil {
		mmSetLength.mock.t.Fatalf("Default expectation is already set for the Matcher.SetLength method")
	}

	if len(mmSetLength.expectations) > 0 {
		mmSetLength.mock.t.Fatalf("Some expectations are already set for the Matcher.SetLength method")
	}

	mmSetLength.mock.funcSetLength = f
	return mmSetLength.mock
}

// SetLength implements stats.Matcher
func (mmSetLength *MatcherMock) SetLength(msg string) {
	mm_atomic.AddUint64(&mmSetLength.beforeSetLengthCounter, 1)
	defer mm_atomic.AddUint64(&mmSetLength.afterSetLengthCounter, 1)

	if mmSetLength.inspectFuncSetLength != nil {
		mmSetLength.inspectFuncSetLength(msg)
	}

	mm_params := &MatcherMockSetLengthParams{msg}

	// Record call args
	mmSetLength.SetLengthMock.mutex.Lock()
	mmSetLength.SetLengthMock.callArgs = append(mmSetLength.SetLengthMock.callArgs, mm_params)
	mmSetLength.SetLengthMock.mutex.Unlock()

	for _, e := range mmSetLength.SetLengthMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetLength.SetLengthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetLength.SetLengthMock.defaultExpectation.Counter, 1)
		mm_want := mmSetLength.SetLengthMock.defaultExpectation.params
		mm_got := MatcherMockSetLengthParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetLength.t.Errorf("MatcherMock.SetLength got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetLength.funcSetLength != nil {
		mmSetLength.funcSetLength(msg)
		return
	}
	mmSetLength.t.Fatalf("Unexpected call to MatcherMock.SetLength. %v", msg)

}

// SetLengthAfterCounter returns a count of finished MatcherMock.SetLength invocations
func (mmSetLength *MatcherMock) SetLengthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLength.afterSetLengthCounter)
}

// SetLengthBeforeCounter returns a count of MatcherMock.SetLength invocations
func (mmSetLength *MatcherMock) SetLengthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLength.beforeSetLengthCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.SetLength.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetLength *mMatcherMockSetLength) Calls() []*MatcherMockSetLengthParams {
	mmSetLength.mutex.RLock()

	argCopy := make([]*MatcherMockSetLengthParams, len(mmSetLength.callArgs))
	copy(argCopy, mmSetLength.callArgs)

	mmSetLength.mutex.RUnlock()

	return argCopy
}

// MinimockSetLengthDone returns true if the count of the SetLength invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockSetLengthDone() bool {
	for _, e := range m.SetLengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLengthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLength != nil && mm_atomic.LoadUint64(&m.afterSetLengthCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetLengthInspect logs each unmet expectation
func (m *MatcherMock) MinimockSetLengthInspect() {
	for _, e := range m.SetLengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.SetLength with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLengthCounter) < 1 {
		if m.SetLengthMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.SetLength")
		} else {
			m.t.Errorf("Expected call to MatcherMock.SetLength with params: %#v", *m.SetLengthMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLength != nil && mm_atomic.LoadUint64(&m.afterSetLengthCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.SetLength")
	}
}

type mMatcherMockSetMap struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockSetMapExpectation
	expectations       []*MatcherMockSetMapExpectation

	callArgs []*MatcherMockSetMapParams
	mutex    sync.RWMutex
}

// MatcherMockSetMapExpectation specifies expectation struct of the Matcher.SetMap
type MatcherMockSetMapExpectation struct {
	mock   *MatcherMock
	params *MatcherMockSetMapParams

	Counter uint64
}

// MatcherMockSetMapParams contains parameters of the Matcher.SetMap
type MatcherMockSetMapParams struct {
	m string
}

// Expect sets up expected params for Matcher.SetMap
func (mmSetMap *mMatcherMockSetMap) Expect(m string) *mMatcherMockSetMap {
	if mmSetMap.mock.funcSetMap != nil {
		mmSetMap.mock.t.Fatalf("MatcherMock.SetMap mock is already set by Set")
	}

	if mmSetMap.defaultExpectation == nil {
		mmSetMap.defaultExpectation = &MatcherMockSetMapExpectation{}
	}

	mmSetMap.defaultExpectation.params = &MatcherMockSetMapParams{m}
	for _, e := range mmSetMap.expectations {
		if minimock.Equal(e.params, mmSetMap.defaultExpectation.params) {
			mmSetMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetMap.defaultExpectation.params)
		}
	}

	return mmSetMap
}

// Inspect accepts an inspector function that has same arguments as the Matcher.SetMap
func (mmSetMap *mMatcherMockSetMap) Inspect(f func(m string)) *mMatcherMockSetMap {
	if mmSetMap.mock.inspectFuncSetMap != nil {
		mmSetMap.mock.t.Fatalf("Inspect function is already set for MatcherMock.SetMap")
	}

	mmSetMap.mock.inspectFuncSetMap = f

	return mmSetMap
}

// Return sets up results that will be returned by Matcher.SetMap
func (mmSetMap *mMatcherMockSetMap) Return() *MatcherMock {
	if mmSetMap.mock.funcSetMap != nil {
		mmSetMap.mock.t.Fatalf("MatcherMock.SetMap mock is already set by Set")
	}

	if mmSetMap.defaultExpectation == nil {
		mmSetMap.defaultExpectation = &MatcherMockSetMapExpectation{mock: mmSetMap.mock}
	}

	return mmSetMap.mock
}

//Set uses given function f to mock the Matcher.SetMap method
func (mmSetMap *mMatcherMockSetMap) Set(f func(m string)) *MatcherMock {
	if mmSetMap.defaultExpectation != nil {
		mmSetMap.mock.t.Fatalf("Default expectation is already set for the Matcher.SetMap method")
	}

	if len(mmSetMap.expectations) > 0 {
		mmSetMap.mock.t.Fatalf("Some expectations are already set for the Matcher.SetMap method")
	}

	mmSetMap.mock.funcSetMap = f
	return mmSetMap.mock
}

// SetMap implements stats.Matcher
func (mmSetMap *MatcherMock) SetMap(m string) {
	mm_atomic.AddUint64(&mmSetMap.beforeSetMapCounter, 1)
	defer mm_atomic.AddUint64(&mmSetMap.afterSetMapCounter, 1)

	if mmSetMap.inspectFuncSetMap != nil {
		mmSetMap.inspectFuncSetMap(m)
	}

	mm_params := &MatcherMockSetMapParams{m}

	// Record call args
	mmSetMap.SetMapMock.mutex.Lock()
	mmSetMap.SetMapMock.callArgs = append(mmSetMap.SetMapMock.callArgs, mm_params)
	mmSetMap.SetMapMock.mutex.Unlock()

	for _, e := range mmSetMap.SetMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetMap.SetMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetMap.SetMapMock.defaultExpectation.Counter, 1)
		mm_want := mmSetMap.SetMapMock.defaultExpectation.params
		mm_got := MatcherMockSetMapParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetMap.t.Errorf("MatcherMock.SetMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetMap.funcSetMap != nil {
		mmSetMap.funcSetMap(m)
		return
	}
	mmSetMap.t.Fatalf("Unexpected call to MatcherMock.SetMap. %v", m)

}

// SetMapAfterCounter returns a count of finished MatcherMock.SetMap invocations
func (mmSetMap *MatcherMock) SetMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetMap.afterSetMapCounter)
}

// SetMapBeforeCounter returns a count of MatcherMock.SetMap invocations
func (mmSetMap *MatcherMock) SetMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetMap.beforeSetMapCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.SetMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetMap *mMatcherMockSetMap) Calls() []*MatcherMockSetMapParams {
	mmSetMap.mutex.RLock()

	argCopy := make([]*MatcherMockSetMapParams, len(mmSetMap.callArgs))
	copy(argCopy, mmSetMap.callArgs)

	mmSetMap.mutex.RUnlock()

	return argCopy
}

// MinimockSetMapDone returns true if the count of the SetMap invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockSetMapDone() bool {
	for _, e := range m.SetMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetMap != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetMapInspect logs each unmet expectation
func (m *MatcherMock) MinimockSetMapInspect() {
	for _, e := range m.SetMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.SetMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		if m.SetMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.SetMap")
		} else {
			m.t.Errorf("Expected call to MatcherMock.SetMap with params: %#v", *m.SetMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetMap != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.SetMap")
	}
}

type mMatcherMockSetPickupID struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockSetPickupIDExpectation
	expectations       []*MatcherMockSetPickupIDExpectation

	callArgs []*MatcherMockSetPickupIDParams
	mutex    sync.RWMutex
}

// MatcherMockSetPickupIDExpectation specifies expectation struct of the Matcher.SetPickupID
type MatcherMockSetPickupIDExpectation struct {
	mock   *MatcherMock
	params *MatcherMockSetPickupIDParams

	Counter uint64
}

// MatcherMockSetPickupIDParams contains parameters of the Matcher.SetPickupID
type MatcherMockSetPickupIDParams struct {
	id int
}

// Expect sets up expected params for Matcher.SetPickupID
func (mmSetPickupID *mMatcherMockSetPickupID) Expect(id int) *mMatcherMockSetPickupID {
	if mmSetPickupID.mock.funcSetPickupID != nil {
		mmSetPickupID.mock.t.Fatalf("MatcherMock.SetPickupID mock is already set by Set")
	}

	if mmSetPickupID.defaultExpectation == nil {
		mmSetPickupID.defaultExpectation = &MatcherMockSetPickupIDExpectation{}
	}

	mmSetPickupID.defaultExpectation.params = &MatcherMockSetPickupIDParams{id}
	for _, e := range mmSetPickupID.expectations {
		if minimock.Equal(e.params, mmSetPickupID.defaultExpectation.params) {
			mmSetPickupID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPickupID.defaultExpectation.params)
		}
	}

	return mmSetPickupID
}

// Inspect accepts an inspector function that has same arguments as the Matcher.SetPickupID
func (mmSetPickupID *mMatcherMockSetPickupID) Inspect(f func(id int)) *mMatcherMockSetPickupID {
	if mmSetPickupID.mock.inspectFuncSetPickupID != nil {
		mmSetPickupID.mock.t.Fatalf("Inspect function is already set for MatcherMock.SetPickupID")
	}

	mmSetPickupID.mock.inspectFuncSetPickupID = f

	return mmSetPickupID
}

// Return sets up results that will be returned by Matcher.SetPickupID
func (mmSetPickupID *mMatcherMockSetPickupID) Return() *MatcherMock {
	if mmSetPickupID.mock.funcSetPickupID != nil {
		mmSetPickupID.mock.t.Fatalf("MatcherMock.SetPickupID mock is already set by Set")
	}

	if mmSetPickupID.defaultExpectation == nil {
		mmSetPickupID.defaultExpectation = &MatcherMockSetPickupIDExpectation{mock: mmSetPickupID.mock}
	}

	return mmSetPickupID.mock
}

//Set uses given function f to mock the Matcher.SetPickupID method
func (mmSetPickupID *mMatcherMockSetPickupID) Set(f func(id int)) *MatcherMock {
	if mmSetPickupID.defaultExpectation != nil {
		mmSetPickupID.mock.t.Fatalf("Default expectation is already set for the Matcher.SetPickupID method")
	}

	if len(mmSetPickupID.expectations) > 0 {
		mmSetPickupID.mock.t.Fatalf("Some expectations are already set for the Matcher.SetPickupID method")
	}

	mmSetPickupID.mock.funcSetPickupID = f
	return mmSetPickupID.mock
}

// SetPickupID implements stats.Matcher
func (mmSetPickupID *MatcherMock) SetPickupID(id int) {
	mm_atomic.AddUint64(&mmSetPickupID.beforeSetPickupIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPickupID.afterSetPickupIDCounter, 1)

	if mmSetPickupID.inspectFuncSetPickupID != nil {
		mmSetPickupID.inspectFuncSetPickupID(id)
	}

	mm_params := &MatcherMockSetPickupIDParams{id}

	// Record call args
	mmSetPickupID.SetPickupIDMock.mutex.Lock()
	mmSetPickupID.SetPickupIDMock.callArgs = append(mmSetPickupID.SetPickupIDMock.callArgs, mm_params)
	mmSetPickupID.SetPickupIDMock.mutex.Unlock()

	for _, e := range mmSetPickupID.SetPickupIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetPickupID.SetPickupIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPickupID.SetPickupIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPickupID.SetPickupIDMock.defaultExpectation.params
		mm_got := MatcherMockSetPickupIDParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPickupID.t.Errorf("MatcherMock.SetPickupID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetPickupID.funcSetPickupID != nil {
		mmSetPickupID.funcSetPickupID(id)
		return
	}
	mmSetPickupID.t.Fatalf("Unexpected call to MatcherMock.SetPickupID. %v", id)

}

// SetPickupIDAfterCounter returns a count of finished MatcherMock.SetPickupID invocations
func (mmSetPickupID *MatcherMock) SetPickupIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPickupID.afterSetPickupIDCounter)
}

// SetPickupIDBeforeCounter returns a count of MatcherMock.SetPickupID invocations
func (mmSetPickupID *MatcherMock) SetPickupIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPickupID.beforeSetPickupIDCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.SetPickupID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPickupID *mMatcherMockSetPickupID) Calls() []*MatcherMockSetPickupIDParams {
	mmSetPickupID.mutex.RLock()

	argCopy := make([]*MatcherMockSetPickupIDParams, len(mmSetPickupID.callArgs))
	copy(argCopy, mmSetPickupID.callArgs)

	mmSetPickupID.mutex.RUnlock()

	return argCopy
}

// MinimockSetPickupIDDone returns true if the count of the SetPickupID invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockSetPickupIDDone() bool {
	for _, e := range m.SetPickupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPickupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPickupIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPickupID != nil && mm_atomic.LoadUint64(&m.afterSetPickupIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetPickupIDInspect logs each unmet expectation
func (m *MatcherMock) MinimockSetPickupIDInspect() {
	for _, e := range m.SetPickupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.SetPickupID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPickupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPickupIDCounter) < 1 {
		if m.SetPickupIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.SetPickupID")
		} else {
			m.t.Errorf("Expected call to MatcherMock.SetPickupID with params: %#v", *m.SetPickupIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPickupID != nil && mm_atomic.LoadUint64(&m.afterSetPickupIDCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.SetPickupID")
	}
}

type mMatcherMockSetPlayerStats struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockSetPlayerStatsExpectation
	expectations       []*MatcherMockSetPlayerStatsExpectation

	callArgs []*MatcherMockSetPlayerStatsParams
	mutex    sync.RWMutex
}

// MatcherMockSetPlayerStatsExpectation specifies expectation struct of the Matcher.SetPlayerStats
type MatcherMockSetPlayerStatsExpectation struct {
	mock   *MatcherMock
	params *MatcherMockSetPlayerStatsParams

	Counter uint64
}

// MatcherMockSetPlayerStatsParams contains parameters of the Matcher.SetPlayerStats
type MatcherMockSetPlayerStatsParams struct {
	stats mm_stats.PlayerStatsCollection
}

// Expect sets up expected params for Matcher.SetPlayerStats
func (mmSetPlayerStats *mMatcherMockSetPlayerStats) Expect(stats mm_stats.PlayerStatsCollection) *mMatcherMockSetPlayerStats {
	if mmSetPlayerStats.mock.funcSetPlayerStats != nil {
		mmSetPlayerStats.mock.t.Fatalf("MatcherMock.SetPlayerStats mock is already set by Set")
	}

	if mmSetPlayerStats.defaultExpectation == nil {
		mmSetPlayerStats.defaultExpectation = &MatcherMockSetPlayerStatsExpectation{}
	}

	mmSetPlayerStats.defaultExpectation.params = &MatcherMockSetPlayerStatsParams{stats}
	for _, e := range mmSetPlayerStats.expectations {
		if minimock.Equal(e.params, mmSetPlayerStats.defaultExpectation.params) {
			mmSetPlayerStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPlayerStats.defaultExpectation.params)
		}
	}

	return mmSetPlayerStats
}

// Inspect accepts an inspector function that has same arguments as the Matcher.SetPlayerStats
func (mmSetPlayerStats *mMatcherMockSetPlayerStats) Inspect(f func(stats mm_stats.PlayerStatsCollection)) *mMatcherMockSetPlayerStats {
	if mmSetPlayerStats.mock.inspectFuncSetPlayerStats != nil {
		mmSetPlayerStats.mock.t.Fatalf("Inspect function is already set for MatcherMock.SetPlayerStats")
	}

	mmSetPlayerStats.mock.inspectFuncSetPlayerStats = f

	return mmSetPlayerStats
}

// Return sets up results that will be returned by Matcher.SetPlayerStats
func (mmSetPlayerStats *mMatcherMockSetPlayerStats) Return() *MatcherMock {
	if mmSetPlayerStats.mock.funcSetPlayerStats != nil {
		mmSetPlayerStats.mock.t.Fatalf("MatcherMock.SetPlayerStats mock is already set by Set")
	}

	if mmSetPlayerStats.defaultExpectation == nil {
		mmSetPlayerStats.defaultExpectation = &MatcherMockSetPlayerStatsExpectation{mock: mmSetPlayerStats.mock}
	}

	return mmSetPlayerStats.mock
}

//Set uses given function f to mock the Matcher.SetPlayerStats method
func (mmSetPlayerStats *mMatcherMockSetPlayerStats) Set(f func(stats mm_stats.PlayerStatsCollection)) *MatcherMock {
	if mmSetPlayerStats.defaultExpectation != nil {
		mmSetPlayerStats.mock.t.Fatalf("Default expectation is already set for the Matcher.SetPlayerStats method")
	}

	if len(mmSetPlayerStats.expectations) > 0 {
		mmSetPlayerStats.mock.t.Fatalf("Some expectations are already set for the Matcher.SetPlayerStats method")
	}

	mmSetPlayerStats.mock.funcSetPlayerStats = f
	return mmSetPlayerStats.mock
}

// SetPlayerStats implements stats.Matcher
func (mmSetPlayerStats *MatcherMock) SetPlayerStats(stats mm_stats.PlayerStatsCollection) {
	mm_atomic.AddUint64(&mmSetPlayerStats.beforeSetPlayerStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPlayerStats.afterSetPlayerStatsCounter, 1)

	if mmSetPlayerStats.inspectFuncSetPlayerStats != nil {
		mmSetPlayerStats.inspectFuncSetPlayerStats(stats)
	}

	mm_params := &MatcherMockSetPlayerStatsParams{stats}

	// Record call args
	mmSetPlayerStats.SetPlayerStatsMock.mutex.Lock()
	mmSetPlayerStats.SetPlayerStatsMock.callArgs = append(mmSetPlayerStats.SetPlayerStatsMock.callArgs, mm_params)
	mmSetPlayerStats.SetPlayerStatsMock.mutex.Unlock()

	for _, e := range mmSetPlayerStats.SetPlayerStatsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetPlayerStats.SetPlayerStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPlayerStats.SetPlayerStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPlayerStats.SetPlayerStatsMock.defaultExpectation.params
		mm_got := MatcherMockSetPlayerStatsParams{stats}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPlayerStats.t.Errorf("MatcherMock.SetPlayerStats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetPlayerStats.funcSetPlayerStats != nil {
		mmSetPlayerStats.funcSetPlayerStats(stats)
		return
	}
	mmSetPlayerStats.t.Fatalf("Unexpected call to MatcherMock.SetPlayerStats. %v", stats)

}

// SetPlayerStatsAfterCounter returns a count of finished MatcherMock.SetPlayerStats invocations
func (mmSetPlayerStats *MatcherMock) SetPlayerStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPlayerStats.afterSetPlayerStatsCounter)
}

// SetPlayerStatsBeforeCounter returns a count of MatcherMock.SetPlayerStats invocations
func (mmSetPlayerStats *MatcherMock) SetPlayerStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPlayerStats.beforeSetPlayerStatsCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.SetPlayerStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPlayerStats *mMatcherMockSetPlayerStats) Calls() []*MatcherMockSetPlayerStatsParams {
	mmSetPlayerStats.mutex.RLock()

	argCopy := make([]*MatcherMockSetPlayerStatsParams, len(mmSetPlayerStats.callArgs))
	copy(argCopy, mmSetPlayerStats.callArgs)

	mmSetPlayerStats.mutex.RUnlock()

	return argCopy
}

// MinimockSetPlayerStatsDone returns true if the count of the SetPlayerStats invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockSetPlayerStatsDone() bool {
	for _, e := range m.SetPlayerStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPlayerStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPlayerStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPlayerStats != nil && mm_atomic.LoadUint64(&m.afterSetPlayerStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetPlayerStatsInspect logs each unmet expectation
func (m *MatcherMock) MinimockSetPlayerStatsInspect() {
	for _, e := range m.SetPlayerStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.SetPlayerStats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPlayerStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPlayerStatsCounter) < 1 {
		if m.SetPlayerStatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.SetPlayerStats")
		} else {
			m.t.Errorf("Expected call to MatcherMock.SetPlayerStats with params: %#v", *m.SetPlayerStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPlayerStats != nil && mm_atomic.LoadUint64(&m.afterSetPlayerStatsCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.SetPlayerStats")
	}
}

type mMatcherMockSetPlayers struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockSetPlayersExpectation
	expectations       []*MatcherMockSetPlayersExpectation

	callArgs []*MatcherMockSetPlayersParams
	mutex    sync.RWMutex
}

// MatcherMockSetPlayersExpectation specifies expectation struct of the Matcher.SetPlayers
type MatcherMockSetPlayersExpectation struct {
	mock   *MatcherMock
	params *MatcherMockSetPlayersParams

	Counter uint64
}

// MatcherMockSetPlayersParams contains parameters of the Matcher.SetPlayers
type MatcherMockSetPlayersParams struct {
	players []*mm_stats.PickupPlayer
}

// Expect sets up expected params for Matcher.SetPlayers
func (mmSetPlayers *mMatcherMockSetPlayers) Expect(players []*mm_stats.PickupPlayer) *mMatcherMockSetPlayers {
	if mmSetPlayers.mock.funcSetPlayers != nil {
		mmSetPlayers.mock.t.Fatalf("MatcherMock.SetPlayers mock is already set by Set")
	}

	if mmSetPlayers.defaultExpectation == nil {
		mmSetPlayers.defaultExpectation = &MatcherMockSetPlayersExpectation{}
	}

	mmSetPlayers.defaultExpectation.params = &MatcherMockSetPlayersParams{players}
	for _, e := range mmSetPlayers.expectations {
		if minimock.Equal(e.params, mmSetPlayers.defaultExpectation.params) {
			mmSetPlayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPlayers.defaultExpectation.params)
		}
	}

	return mmSetPlayers
}

// Inspect accepts an inspector function that has same arguments as the Matcher.SetPlayers
func (mmSetPlayers *mMatcherMockSetPlayers) Inspect(f func(players []*mm_stats.PickupPlayer)) *mMatcherMockSetPlayers {
	if mmSetPlayers.mock.inspectFuncSetPlayers != nil {
		mmSetPlayers.mock.t.Fatalf("Inspect function is already set for MatcherMock.SetPlayers")
	}

	mmSetPlayers.mock.inspectFuncSetPlayers = f

	return mmSetPlayers
}

// Return sets up results that will be returned by Matcher.SetPlayers
func (mmSetPlayers *mMatcherMockSetPlayers) Return() *MatcherMock {
	if mmSetPlayers.mock.funcSetPlayers != nil {
		mmSetPlayers.mock.t.Fatalf("MatcherMock.SetPlayers mock is already set by Set")
	}

	if mmSetPlayers.defaultExpectation == nil {
		mmSetPlayers.defaultExpectation = &MatcherMockSetPlayersExpectation{mock: mmSetPlayers.mock}
	}

	return mmSetPlayers.mock
}

//Set uses given function f to mock the Matcher.SetPlayers method
func (mmSetPlayers *mMatcherMockSetPlayers) Set(f func(players []*mm_stats.PickupPlayer)) *MatcherMock {
	if mmSetPlayers.defaultExpectation != nil {
		mmSetPlayers.mock.t.Fatalf("Default expectation is already set for the Matcher.SetPlayers method")
	}

	if len(mmSetPlayers.expectations) > 0 {
		mmSetPlayers.mock.t.Fatalf("Some expectations are already set for the Matcher.SetPlayers method")
	}

	mmSetPlayers.mock.funcSetPlayers = f
	return mmSetPlayers.mock
}

// SetPlayers implements stats.Matcher
func (mmSetPlayers *MatcherMock) SetPlayers(players []*mm_stats.PickupPlayer) {
	mm_atomic.AddUint64(&mmSetPlayers.beforeSetPlayersCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPlayers.afterSetPlayersCounter, 1)

	if mmSetPlayers.inspectFuncSetPlayers != nil {
		mmSetPlayers.inspectFuncSetPlayers(players)
	}

	mm_params := &MatcherMockSetPlayersParams{players}

	// Record call args
	mmSetPlayers.SetPlayersMock.mutex.Lock()
	mmSetPlayers.SetPlayersMock.callArgs = append(mmSetPlayers.SetPlayersMock.callArgs, mm_params)
	mmSetPlayers.SetPlayersMock.mutex.Unlock()

	for _, e := range mmSetPlayers.SetPlayersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetPlayers.SetPlayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPlayers.SetPlayersMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPlayers.SetPlayersMock.defaultExpectation.params
		mm_got := MatcherMockSetPlayersParams{players}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPlayers.t.Errorf("MatcherMock.SetPlayers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetPlayers.funcSetPlayers != nil {
		mmSetPlayers.funcSetPlayers(players)
		return
	}
	mmSetPlayers.t.Fatalf("Unexpected call to MatcherMock.SetPlayers. %v", players)

}

// SetPlayersAfterCounter returns a count of finished MatcherMock.SetPlayers invocations
func (mmSetPlayers *MatcherMock) SetPlayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPlayers.afterSetPlayersCounter)
}

// SetPlayersBeforeCounter returns a count of MatcherMock.SetPlayers invocations
func (mmSetPlayers *MatcherMock) SetPlayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPlayers.beforeSetPlayersCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.SetPlayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPlayers *mMatcherMockSetPlayers) Calls() []*MatcherMockSetPlayersParams {
	mmSetPlayers.mutex.RLock()

	argCopy := make([]*MatcherMockSetPlayersParams, len(mmSetPlayers.callArgs))
	copy(argCopy, mmSetPlayers.callArgs)

	mmSetPlayers.mutex.RUnlock()

	return argCopy
}

// MinimockSetPlayersDone returns true if the count of the SetPlayers invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockSetPlayersDone() bool {
	for _, e := range m.SetPlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPlayersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPlayers != nil && mm_atomic.LoadUint64(&m.afterSetPlayersCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetPlayersInspect logs each unmet expectation
func (m *MatcherMock) MinimockSetPlayersInspect() {
	for _, e := range m.SetPlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.SetPlayers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPlayersCounter) < 1 {
		if m.SetPlayersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.SetPlayers")
		} else {
			m.t.Errorf("Expected call to MatcherMock.SetPlayers with params: %#v", *m.SetPlayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPlayers != nil && mm_atomic.LoadUint64(&m.afterSetPlayersCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.SetPlayers")
	}
}

type mMatcherMockSetRedScore struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockSetRedScoreExpectation
	expectations       []*MatcherMockSetRedScoreExpectation

	callArgs []*MatcherMockSetRedScoreParams
	mutex    sync.RWMutex
}

// MatcherMockSetRedScoreExpectation specifies expectation struct of the Matcher.SetRedScore
type MatcherMockSetRedScoreExpectation struct {
	mock   *MatcherMock
	params *MatcherMockSetRedScoreParams

	Counter uint64
}

// MatcherMockSetRedScoreParams contains parameters of the Matcher.SetRedScore
type MatcherMockSetRedScoreParams struct {
	score int
}

// Expect sets up expected params for Matcher.SetRedScore
func (mmSetRedScore *mMatcherMockSetRedScore) Expect(score int) *mMatcherMockSetRedScore {
	if mmSetRedScore.mock.funcSetRedScore != nil {
		mmSetRedScore.mock.t.Fatalf("MatcherMock.SetRedScore mock is already set by Set")
	}

	if mmSetRedScore.defaultExpectation == nil {
		mmSetRedScore.defaultExpectation = &MatcherMockSetRedScoreExpectation{}
	}

	mmSetRedScore.defaultExpectation.params = &MatcherMockSetRedScoreParams{score}
	for _, e := range mmSetRedScore.expectations {
		if minimock.Equal(e.params, mmSetRedScore.defaultExpectation.params) {
			mmSetRedScore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetRedScore.defaultExpectation.params)
		}
	}

	return mmSetRedScore
}

// Inspect accepts an inspector function that has same arguments as the Matcher.SetRedScore
func (mmSetRedScore *mMatcherMockSetRedScore) Inspect(f func(score int)) *mMatcherMockSetRedScore {
	if mmSetRedScore.mock.inspectFuncSetRedScore != nil {
		mmSetRedScore.mock.t.Fatalf("Inspect function is already set for MatcherMock.SetRedScore")
	}

	mmSetRedScore.mock.inspectFuncSetRedScore = f

	return mmSetRedScore
}

// Return sets up results that will be returned by Matcher.SetRedScore
func (mmSetRedScore *mMatcherMockSetRedScore) Return() *MatcherMock {
	if mmSetRedScore.mock.funcSetRedScore != nil {
		mmSetRedScore.mock.t.Fatalf("MatcherMock.SetRedScore mock is already set by Set")
	}

	if mmSetRedScore.defaultExpectation == nil {
		mmSetRedScore.defaultExpectation = &MatcherMockSetRedScoreExpectation{mock: mmSetRedScore.mock}
	}

	return mmSetRedScore.mock
}

//Set uses given function f to mock the Matcher.SetRedScore method
func (mmSetRedScore *mMatcherMockSetRedScore) Set(f func(score int)) *MatcherMock {
	if mmSetRedScore.defaultExpectation != nil {
		mmSetRedScore.mock.t.Fatalf("Default expectation is already set for the Matcher.SetRedScore method")
	}

	if len(mmSetRedScore.expectations) > 0 {
		mmSetRedScore.mock.t.Fatalf("Some expectations are already set for the Matcher.SetRedScore method")
	}

	mmSetRedScore.mock.funcSetRedScore = f
	return mmSetRedScore.mock
}

// SetRedScore implements stats.Matcher
func (mmSetRedScore *MatcherMock) SetRedScore(score int) {
	mm_atomic.AddUint64(&mmSetRedScore.beforeSetRedScoreCounter, 1)
	defer mm_atomic.AddUint64(&mmSetRedScore.afterSetRedScoreCounter, 1)

	if mmSetRedScore.inspectFuncSetRedScore != nil {
		mmSetRedScore.inspectFuncSetRedScore(score)
	}

	mm_params := &MatcherMockSetRedScoreParams{score}

	// Record call args
	mmSetRedScore.SetRedScoreMock.mutex.Lock()
	mmSetRedScore.SetRedScoreMock.callArgs = append(mmSetRedScore.SetRedScoreMock.callArgs, mm_params)
	mmSetRedScore.SetRedScoreMock.mutex.Unlock()

	for _, e := range mmSetRedScore.SetRedScoreMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetRedScore.SetRedScoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetRedScore.SetRedScoreMock.defaultExpectation.Counter, 1)
		mm_want := mmSetRedScore.SetRedScoreMock.defaultExpectation.params
		mm_got := MatcherMockSetRedScoreParams{score}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetRedScore.t.Errorf("MatcherMock.SetRedScore got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetRedScore.funcSetRedScore != nil {
		mmSetRedScore.funcSetRedScore(score)
		return
	}
	mmSetRedScore.t.Fatalf("Unexpected call to MatcherMock.SetRedScore. %v", score)

}

// SetRedScoreAfterCounter returns a count of finished MatcherMock.SetRedScore invocations
func (mmSetRedScore *MatcherMock) SetRedScoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRedScore.afterSetRedScoreCounter)
}

// SetRedScoreBeforeCounter returns a count of MatcherMock.SetRedScore invocations
func (mmSetRedScore *MatcherMock) SetRedScoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRedScore.beforeSetRedScoreCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.SetRedScore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetRedScore *mMatcherMockSetRedScore) Calls() []*MatcherMockSetRedScoreParams {
	mmSetRedScore.mutex.RLock()

	argCopy := make([]*MatcherMockSetRedScoreParams, len(mmSetRedScore.callArgs))
	copy(argCopy, mmSetRedScore.callArgs)

	mmSetRedScore.mutex.RUnlock()

	return argCopy
}

// MinimockSetRedScoreDone returns true if the count of the SetRedScore invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockSetRedScoreDone() bool {
	for _, e := range m.SetRedScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetRedScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetRedScoreCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRedScore != nil && mm_atomic.LoadUint64(&m.afterSetRedScoreCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetRedScoreInspect logs each unmet expectation
func (m *MatcherMock) MinimockSetRedScoreInspect() {
	for _, e := range m.SetRedScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.SetRedScore with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetRedScoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetRedScoreCounter) < 1 {
		if m.SetRedScoreMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.SetRedScore")
		} else {
			m.t.Errorf("Expected call to MatcherMock.SetRedScore with params: %#v", *m.SetRedScoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRedScore != nil && mm_atomic.LoadUint64(&m.afterSetRedScoreCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.SetRedScore")
	}
}

type mMatcherMockSetStartTime struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockSetStartTimeExpectation
	expectations       []*MatcherMockSetStartTimeExpectation

	callArgs []*MatcherMockSetStartTimeParams
	mutex    sync.RWMutex
}

// MatcherMockSetStartTimeExpectation specifies expectation struct of the Matcher.SetStartTime
type MatcherMockSetStartTimeExpectation struct {
	mock   *MatcherMock
	params *MatcherMockSetStartTimeParams

	Counter uint64
}

// MatcherMockSetStartTimeParams contains parameters of the Matcher.SetStartTime
type MatcherMockSetStartTimeParams struct {
	msg string
}

// Expect sets up expected params for Matcher.SetStartTime
func (mmSetStartTime *mMatcherMockSetStartTime) Expect(msg string) *mMatcherMockSetStartTime {
	if mmSetStartTime.mock.funcSetStartTime != nil {
		mmSetStartTime.mock.t.Fatalf("MatcherMock.SetStartTime mock is already set by Set")
	}

	if mmSetStartTime.defaultExpectation == nil {
		mmSetStartTime.defaultExpectation = &MatcherMockSetStartTimeExpectation{}
	}

	mmSetStartTime.defaultExpectation.params = &MatcherMockSetStartTimeParams{msg}
	for _, e := range mmSetStartTime.expectations {
		if minimock.Equal(e.params, mmSetStartTime.defaultExpectation.params) {
			mmSetStartTime.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStartTime.defaultExpectation.params)
		}
	}

	return mmSetStartTime
}

// Inspect accepts an inspector function that has same arguments as the Matcher.SetStartTime
func (mmSetStartTime *mMatcherMockSetStartTime) Inspect(f func(msg string)) *mMatcherMockSetStartTime {
	if mmSetStartTime.mock.inspectFuncSetStartTime != nil {
		mmSetStartTime.mock.t.Fatalf("Inspect function is already set for MatcherMock.SetStartTime")
	}

	mmSetStartTime.mock.inspectFuncSetStartTime = f

	return mmSetStartTime
}

// Return sets up results that will be returned by Matcher.SetStartTime
func (mmSetStartTime *mMatcherMockSetStartTime) Return() *MatcherMock {
	if mmSetStartTime.mock.funcSetStartTime != nil {
		mmSetStartTime.mock.t.Fatalf("MatcherMock.SetStartTime mock is already set by Set")
	}

	if mmSetStartTime.defaultExpectation == nil {
		mmSetStartTime.defaultExpectation = &MatcherMockSetStartTimeExpectation{mock: mmSetStartTime.mock}
	}

	return mmSetStartTime.mock
}

//Set uses given function f to mock the Matcher.SetStartTime method
func (mmSetStartTime *mMatcherMockSetStartTime) Set(f func(msg string)) *MatcherMock {
	if mmSetStartTime.defaultExpectation != nil {
		mmSetStartTime.mock.t.Fatalf("Default expectation is already set for the Matcher.SetStartTime method")
	}

	if len(mmSetStartTime.expectations) > 0 {
		mmSetStartTime.mock.t.Fatalf("Some expectations are already set for the Matcher.SetStartTime method")
	}

	mmSetStartTime.mock.funcSetStartTime = f
	return mmSetStartTime.mock
}

// SetStartTime implements stats.Matcher
func (mmSetStartTime *MatcherMock) SetStartTime(msg string) {
	mm_atomic.AddUint64(&mmSetStartTime.beforeSetStartTimeCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStartTime.afterSetStartTimeCounter, 1)

	if mmSetStartTime.inspectFuncSetStartTime != nil {
		mmSetStartTime.inspectFuncSetStartTime(msg)
	}

	mm_params := &MatcherMockSetStartTimeParams{msg}

	// Record call args
	mmSetStartTime.SetStartTimeMock.mutex.Lock()
	mmSetStartTime.SetStartTimeMock.callArgs = append(mmSetStartTime.SetStartTimeMock.callArgs, mm_params)
	mmSetStartTime.SetStartTimeMock.mutex.Unlock()

	for _, e := range mmSetStartTime.SetStartTimeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetStartTime.SetStartTimeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStartTime.SetStartTimeMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStartTime.SetStartTimeMock.defaultExpectation.params
		mm_got := MatcherMockSetStartTimeParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStartTime.t.Errorf("MatcherMock.SetStartTime got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetStartTime.funcSetStartTime != nil {
		mmSetStartTime.funcSetStartTime(msg)
		return
	}
	mmSetStartTime.t.Fatalf("Unexpected call to MatcherMock.SetStartTime. %v", msg)

}

// SetStartTimeAfterCounter returns a count of finished MatcherMock.SetStartTime invocations
func (mmSetStartTime *MatcherMock) SetStartTimeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStartTime.afterSetStartTimeCounter)
}

// SetStartTimeBeforeCounter returns a count of MatcherMock.SetStartTime invocations
func (mmSetStartTime *MatcherMock) SetStartTimeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStartTime.beforeSetStartTimeCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.SetStartTime.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStartTime *mMatcherMockSetStartTime) Calls() []*MatcherMockSetStartTimeParams {
	mmSetStartTime.mutex.RLock()

	argCopy := make([]*MatcherMockSetStartTimeParams, len(mmSetStartTime.callArgs))
	copy(argCopy, mmSetStartTime.callArgs)

	mmSetStartTime.mutex.RUnlock()

	return argCopy
}

// MinimockSetStartTimeDone returns true if the count of the SetStartTime invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockSetStartTimeDone() bool {
	for _, e := range m.SetStartTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStartTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStartTimeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStartTime != nil && mm_atomic.LoadUint64(&m.afterSetStartTimeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStartTimeInspect logs each unmet expectation
func (m *MatcherMock) MinimockSetStartTimeInspect() {
	for _, e := range m.SetStartTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.SetStartTime with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStartTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStartTimeCounter) < 1 {
		if m.SetStartTimeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.SetStartTime")
		} else {
			m.t.Errorf("Expected call to MatcherMock.SetStartTime with params: %#v", *m.SetStartTimeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStartTime != nil && mm_atomic.LoadUint64(&m.afterSetStartTimeCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.SetStartTime")
	}
}

type mMatcherMockString struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockStringExpectation
	expectations       []*MatcherMockStringExpectation
}

// MatcherMockStringExpectation specifies expectation struct of the Matcher.String
type MatcherMockStringExpectation struct {
	mock *MatcherMock

	results *MatcherMockStringResults
	Counter uint64
}

// MatcherMockStringResults contains results of the Matcher.String
type MatcherMockStringResults struct {
	s1 string
}

// Expect sets up expected params for Matcher.String
func (mmString *mMatcherMockString) Expect() *mMatcherMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("MatcherMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &MatcherMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the Matcher.String
func (mmString *mMatcherMockString) Inspect(f func()) *mMatcherMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for MatcherMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by Matcher.String
func (mmString *mMatcherMockString) Return(s1 string) *MatcherMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("MatcherMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &MatcherMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &MatcherMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the Matcher.String method
func (mmString *mMatcherMockString) Set(f func() (s1 string)) *MatcherMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the Matcher.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the Matcher.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements stats.Matcher
func (mmString *MatcherMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the MatcherMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to MatcherMock.String.")
	return
}

// StringAfterCounter returns a count of finished MatcherMock.String invocations
func (mmString *MatcherMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of MatcherMock.String invocations
func (mmString *MatcherMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *MatcherMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatcherMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.String")
	}
}

type mMatcherMockTryParseGameMap struct {
	mock               *MatcherMock
	defaultExpectation *MatcherMockTryParseGameMapExpectation
	expectations       []*MatcherMockTryParseGameMapExpectation

	callArgs []*MatcherMockTryParseGameMapParams
	mutex    sync.RWMutex
}

// MatcherMockTryParseGameMapExpectation specifies expectation struct of the Matcher.TryParseGameMap
type MatcherMockTryParseGameMapExpectation struct {
	mock   *MatcherMock
	params *MatcherMockTryParseGameMapParams

	Counter uint64
}

// MatcherMockTryParseGameMapParams contains parameters of the Matcher.TryParseGameMap
type MatcherMockTryParseGameMapParams struct {
	msg string
}

// Expect sets up expected params for Matcher.TryParseGameMap
func (mmTryParseGameMap *mMatcherMockTryParseGameMap) Expect(msg string) *mMatcherMockTryParseGameMap {
	if mmTryParseGameMap.mock.funcTryParseGameMap != nil {
		mmTryParseGameMap.mock.t.Fatalf("MatcherMock.TryParseGameMap mock is already set by Set")
	}

	if mmTryParseGameMap.defaultExpectation == nil {
		mmTryParseGameMap.defaultExpectation = &MatcherMockTryParseGameMapExpectation{}
	}

	mmTryParseGameMap.defaultExpectation.params = &MatcherMockTryParseGameMapParams{msg}
	for _, e := range mmTryParseGameMap.expectations {
		if minimock.Equal(e.params, mmTryParseGameMap.defaultExpectation.params) {
			mmTryParseGameMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTryParseGameMap.defaultExpectation.params)
		}
	}

	return mmTryParseGameMap
}

// Inspect accepts an inspector function that has same arguments as the Matcher.TryParseGameMap
func (mmTryParseGameMap *mMatcherMockTryParseGameMap) Inspect(f func(msg string)) *mMatcherMockTryParseGameMap {
	if mmTryParseGameMap.mock.inspectFuncTryParseGameMap != nil {
		mmTryParseGameMap.mock.t.Fatalf("Inspect function is already set for MatcherMock.TryParseGameMap")
	}

	mmTryParseGameMap.mock.inspectFuncTryParseGameMap = f

	return mmTryParseGameMap
}

// Return sets up results that will be returned by Matcher.TryParseGameMap
func (mmTryParseGameMap *mMatcherMockTryParseGameMap) Return() *MatcherMock {
	if mmTryParseGameMap.mock.funcTryParseGameMap != nil {
		mmTryParseGameMap.mock.t.Fatalf("MatcherMock.TryParseGameMap mock is already set by Set")
	}

	if mmTryParseGameMap.defaultExpectation == nil {
		mmTryParseGameMap.defaultExpectation = &MatcherMockTryParseGameMapExpectation{mock: mmTryParseGameMap.mock}
	}

	return mmTryParseGameMap.mock
}

//Set uses given function f to mock the Matcher.TryParseGameMap method
func (mmTryParseGameMap *mMatcherMockTryParseGameMap) Set(f func(msg string)) *MatcherMock {
	if mmTryParseGameMap.defaultExpectation != nil {
		mmTryParseGameMap.mock.t.Fatalf("Default expectation is already set for the Matcher.TryParseGameMap method")
	}

	if len(mmTryParseGameMap.expectations) > 0 {
		mmTryParseGameMap.mock.t.Fatalf("Some expectations are already set for the Matcher.TryParseGameMap method")
	}

	mmTryParseGameMap.mock.funcTryParseGameMap = f
	return mmTryParseGameMap.mock
}

// TryParseGameMap implements stats.Matcher
func (mmTryParseGameMap *MatcherMock) TryParseGameMap(msg string) {
	mm_atomic.AddUint64(&mmTryParseGameMap.beforeTryParseGameMapCounter, 1)
	defer mm_atomic.AddUint64(&mmTryParseGameMap.afterTryParseGameMapCounter, 1)

	if mmTryParseGameMap.inspectFuncTryParseGameMap != nil {
		mmTryParseGameMap.inspectFuncTryParseGameMap(msg)
	}

	mm_params := &MatcherMockTryParseGameMapParams{msg}

	// Record call args
	mmTryParseGameMap.TryParseGameMapMock.mutex.Lock()
	mmTryParseGameMap.TryParseGameMapMock.callArgs = append(mmTryParseGameMap.TryParseGameMapMock.callArgs, mm_params)
	mmTryParseGameMap.TryParseGameMapMock.mutex.Unlock()

	for _, e := range mmTryParseGameMap.TryParseGameMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmTryParseGameMap.TryParseGameMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTryParseGameMap.TryParseGameMapMock.defaultExpectation.Counter, 1)
		mm_want := mmTryParseGameMap.TryParseGameMapMock.defaultExpectation.params
		mm_got := MatcherMockTryParseGameMapParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTryParseGameMap.t.Errorf("MatcherMock.TryParseGameMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmTryParseGameMap.funcTryParseGameMap != nil {
		mmTryParseGameMap.funcTryParseGameMap(msg)
		return
	}
	mmTryParseGameMap.t.Fatalf("Unexpected call to MatcherMock.TryParseGameMap. %v", msg)

}

// TryParseGameMapAfterCounter returns a count of finished MatcherMock.TryParseGameMap invocations
func (mmTryParseGameMap *MatcherMock) TryParseGameMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTryParseGameMap.afterTryParseGameMapCounter)
}

// TryParseGameMapBeforeCounter returns a count of MatcherMock.TryParseGameMap invocations
func (mmTryParseGameMap *MatcherMock) TryParseGameMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTryParseGameMap.beforeTryParseGameMapCounter)
}

// Calls returns a list of arguments used in each call to MatcherMock.TryParseGameMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTryParseGameMap *mMatcherMockTryParseGameMap) Calls() []*MatcherMockTryParseGameMapParams {
	mmTryParseGameMap.mutex.RLock()

	argCopy := make([]*MatcherMockTryParseGameMapParams, len(mmTryParseGameMap.callArgs))
	copy(argCopy, mmTryParseGameMap.callArgs)

	mmTryParseGameMap.mutex.RUnlock()

	return argCopy
}

// MinimockTryParseGameMapDone returns true if the count of the TryParseGameMap invocations corresponds
// the number of defined expectations
func (m *MatcherMock) MinimockTryParseGameMapDone() bool {
	for _, e := range m.TryParseGameMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TryParseGameMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTryParseGameMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTryParseGameMap != nil && mm_atomic.LoadUint64(&m.afterTryParseGameMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockTryParseGameMapInspect logs each unmet expectation
func (m *MatcherMock) MinimockTryParseGameMapInspect() {
	for _, e := range m.TryParseGameMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatcherMock.TryParseGameMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TryParseGameMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTryParseGameMapCounter) < 1 {
		if m.TryParseGameMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatcherMock.TryParseGameMap")
		} else {
			m.t.Errorf("Expected call to MatcherMock.TryParseGameMap with params: %#v", *m.TryParseGameMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTryParseGameMap != nil && mm_atomic.LoadUint64(&m.afterTryParseGameMapCounter) < 1 {
		m.t.Error("Expected call to MatcherMock.TryParseGameMap")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MatcherMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDomainInspect()

		m.MinimockFlushInspect()

		m.MinimockLengthSecondsInspect()

		m.MinimockMapInspect()

		m.MinimockPickupIDInspect()

		m.MinimockPickupPlayersInspect()

		m.MinimockPlayerStatsInspect()

		m.MinimockSetBlueScoreInspect()

		m.MinimockSetLengthInspect()

		m.MinimockSetMapInspect()

		m.MinimockSetPickupIDInspect()

		m.MinimockSetPlayerStatsInspect()

		m.MinimockSetPlayersInspect()

		m.MinimockSetRedScoreInspect()

		m.MinimockSetStartTimeInspect()

		m.MinimockStringInspect()

		m.MinimockTryParseGameMapInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MatcherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MatcherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDomainDone() &&
		m.MinimockFlushDone() &&
		m.MinimockLengthSecondsDone() &&
		m.MinimockMapDone() &&
		m.MinimockPickupIDDone() &&
		m.MinimockPickupPlayersDone() &&
		m.MinimockPlayerStatsDone() &&
		m.MinimockSetBlueScoreDone() &&
		m.MinimockSetLengthDone() &&
		m.MinimockSetMapDone() &&
		m.MinimockSetPickupIDDone() &&
		m.MinimockSetPlayerStatsDone() &&
		m.MinimockSetPlayersDone() &&
		m.MinimockSetRedScoreDone() &&
		m.MinimockSetStartTimeDone() &&
		m.MinimockStringDone() &&
		m.MinimockTryParseGameMapDone()
}
