package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i LogWatcher/pkg/stats.MatchDater -o ./mocks/match_dater_mock.go

import (
	mm_stats "LogWatcher/pkg/stats"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// MatchDaterMock implements stats.MatchDater
type MatchDaterMock struct {
	t minimock.Tester

	funcDomain          func() (s1 string)
	inspectFuncDomain   func()
	afterDomainCounter  uint64
	beforeDomainCounter uint64
	DomainMock          mMatchDaterMockDomain

	funcFlushPlayerStatsMap          func()
	inspectFuncFlushPlayerStatsMap   func()
	afterFlushPlayerStatsMapCounter  uint64
	beforeFlushPlayerStatsMapCounter uint64
	FlushPlayerStatsMapMock          mMatchDaterMockFlushPlayerStatsMap

	funcLengthSeconds          func() (i1 int)
	inspectFuncLengthSeconds   func()
	afterLengthSecondsCounter  uint64
	beforeLengthSecondsCounter uint64
	LengthSecondsMock          mMatchDaterMockLengthSeconds

	funcMap          func() (s1 string)
	inspectFuncMap   func()
	afterMapCounter  uint64
	beforeMapCounter uint64
	MapMock          mMatchDaterMockMap

	funcPickupID          func() (i1 int)
	inspectFuncPickupID   func()
	afterPickupIDCounter  uint64
	beforePickupIDCounter uint64
	PickupIDMock          mMatchDaterMockPickupID

	funcPickupPlayers          func() (ppa1 []*mm_stats.PickupPlayer)
	inspectFuncPickupPlayers   func()
	afterPickupPlayersCounter  uint64
	beforePickupPlayersCounter uint64
	PickupPlayersMock          mMatchDaterMockPickupPlayers

	funcPlayerStatsMap          func() (p1 mm_stats.PlayerStatsCollection)
	inspectFuncPlayerStatsMap   func()
	afterPlayerStatsMapCounter  uint64
	beforePlayerStatsMapCounter uint64
	PlayerStatsMapMock          mMatchDaterMockPlayerStatsMap

	funcSetLength          func(msg string)
	inspectFuncSetLength   func(msg string)
	afterSetLengthCounter  uint64
	beforeSetLengthCounter uint64
	SetLengthMock          mMatchDaterMockSetLength

	funcSetMap          func(m string)
	inspectFuncSetMap   func(m string)
	afterSetMapCounter  uint64
	beforeSetMapCounter uint64
	SetMapMock          mMatchDaterMockSetMap

	funcSetPickupID          func(id int)
	inspectFuncSetPickupID   func(id int)
	afterSetPickupIDCounter  uint64
	beforeSetPickupIDCounter uint64
	SetPickupIDMock          mMatchDaterMockSetPickupID

	funcSetPlayers          func(players []*mm_stats.PickupPlayer)
	inspectFuncSetPlayers   func(players []*mm_stats.PickupPlayer)
	afterSetPlayersCounter  uint64
	beforeSetPlayersCounter uint64
	SetPlayersMock          mMatchDaterMockSetPlayers

	funcSetStartTime          func(msg string)
	inspectFuncSetStartTime   func(msg string)
	afterSetStartTimeCounter  uint64
	beforeSetStartTimeCounter uint64
	SetStartTimeMock          mMatchDaterMockSetStartTime

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mMatchDaterMockString

	funcTryParseGameMap          func(msg string)
	inspectFuncTryParseGameMap   func(msg string)
	afterTryParseGameMapCounter  uint64
	beforeTryParseGameMapCounter uint64
	TryParseGameMapMock          mMatchDaterMockTryParseGameMap
}

// NewMatchDaterMock returns a mock for stats.MatchDater
func NewMatchDaterMock(t minimock.Tester) *MatchDaterMock {
	m := &MatchDaterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DomainMock = mMatchDaterMockDomain{mock: m}

	m.FlushPlayerStatsMapMock = mMatchDaterMockFlushPlayerStatsMap{mock: m}

	m.LengthSecondsMock = mMatchDaterMockLengthSeconds{mock: m}

	m.MapMock = mMatchDaterMockMap{mock: m}

	m.PickupIDMock = mMatchDaterMockPickupID{mock: m}

	m.PickupPlayersMock = mMatchDaterMockPickupPlayers{mock: m}

	m.PlayerStatsMapMock = mMatchDaterMockPlayerStatsMap{mock: m}

	m.SetLengthMock = mMatchDaterMockSetLength{mock: m}
	m.SetLengthMock.callArgs = []*MatchDaterMockSetLengthParams{}

	m.SetMapMock = mMatchDaterMockSetMap{mock: m}
	m.SetMapMock.callArgs = []*MatchDaterMockSetMapParams{}

	m.SetPickupIDMock = mMatchDaterMockSetPickupID{mock: m}
	m.SetPickupIDMock.callArgs = []*MatchDaterMockSetPickupIDParams{}

	m.SetPlayersMock = mMatchDaterMockSetPlayers{mock: m}
	m.SetPlayersMock.callArgs = []*MatchDaterMockSetPlayersParams{}

	m.SetStartTimeMock = mMatchDaterMockSetStartTime{mock: m}
	m.SetStartTimeMock.callArgs = []*MatchDaterMockSetStartTimeParams{}

	m.StringMock = mMatchDaterMockString{mock: m}

	m.TryParseGameMapMock = mMatchDaterMockTryParseGameMap{mock: m}
	m.TryParseGameMapMock.callArgs = []*MatchDaterMockTryParseGameMapParams{}

	return m
}

type mMatchDaterMockDomain struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockDomainExpectation
	expectations       []*MatchDaterMockDomainExpectation
}

// MatchDaterMockDomainExpectation specifies expectation struct of the MatchDater.Domain
type MatchDaterMockDomainExpectation struct {
	mock *MatchDaterMock

	results *MatchDaterMockDomainResults
	Counter uint64
}

// MatchDaterMockDomainResults contains results of the MatchDater.Domain
type MatchDaterMockDomainResults struct {
	s1 string
}

// Expect sets up expected params for MatchDater.Domain
func (mmDomain *mMatchDaterMockDomain) Expect() *mMatchDaterMockDomain {
	if mmDomain.mock.funcDomain != nil {
		mmDomain.mock.t.Fatalf("MatchDaterMock.Domain mock is already set by Set")
	}

	if mmDomain.defaultExpectation == nil {
		mmDomain.defaultExpectation = &MatchDaterMockDomainExpectation{}
	}

	return mmDomain
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.Domain
func (mmDomain *mMatchDaterMockDomain) Inspect(f func()) *mMatchDaterMockDomain {
	if mmDomain.mock.inspectFuncDomain != nil {
		mmDomain.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.Domain")
	}

	mmDomain.mock.inspectFuncDomain = f

	return mmDomain
}

// Return sets up results that will be returned by MatchDater.Domain
func (mmDomain *mMatchDaterMockDomain) Return(s1 string) *MatchDaterMock {
	if mmDomain.mock.funcDomain != nil {
		mmDomain.mock.t.Fatalf("MatchDaterMock.Domain mock is already set by Set")
	}

	if mmDomain.defaultExpectation == nil {
		mmDomain.defaultExpectation = &MatchDaterMockDomainExpectation{mock: mmDomain.mock}
	}
	mmDomain.defaultExpectation.results = &MatchDaterMockDomainResults{s1}
	return mmDomain.mock
}

//Set uses given function f to mock the MatchDater.Domain method
func (mmDomain *mMatchDaterMockDomain) Set(f func() (s1 string)) *MatchDaterMock {
	if mmDomain.defaultExpectation != nil {
		mmDomain.mock.t.Fatalf("Default expectation is already set for the MatchDater.Domain method")
	}

	if len(mmDomain.expectations) > 0 {
		mmDomain.mock.t.Fatalf("Some expectations are already set for the MatchDater.Domain method")
	}

	mmDomain.mock.funcDomain = f
	return mmDomain.mock
}

// Domain implements stats.MatchDater
func (mmDomain *MatchDaterMock) Domain() (s1 string) {
	mm_atomic.AddUint64(&mmDomain.beforeDomainCounter, 1)
	defer mm_atomic.AddUint64(&mmDomain.afterDomainCounter, 1)

	if mmDomain.inspectFuncDomain != nil {
		mmDomain.inspectFuncDomain()
	}

	if mmDomain.DomainMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDomain.DomainMock.defaultExpectation.Counter, 1)

		mm_results := mmDomain.DomainMock.defaultExpectation.results
		if mm_results == nil {
			mmDomain.t.Fatal("No results are set for the MatchDaterMock.Domain")
		}
		return (*mm_results).s1
	}
	if mmDomain.funcDomain != nil {
		return mmDomain.funcDomain()
	}
	mmDomain.t.Fatalf("Unexpected call to MatchDaterMock.Domain.")
	return
}

// DomainAfterCounter returns a count of finished MatchDaterMock.Domain invocations
func (mmDomain *MatchDaterMock) DomainAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDomain.afterDomainCounter)
}

// DomainBeforeCounter returns a count of MatchDaterMock.Domain invocations
func (mmDomain *MatchDaterMock) DomainBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDomain.beforeDomainCounter)
}

// MinimockDomainDone returns true if the count of the Domain invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockDomainDone() bool {
	for _, e := range m.DomainMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DomainMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDomainCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDomain != nil && mm_atomic.LoadUint64(&m.afterDomainCounter) < 1 {
		return false
	}
	return true
}

// MinimockDomainInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockDomainInspect() {
	for _, e := range m.DomainMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatchDaterMock.Domain")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DomainMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDomainCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.Domain")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDomain != nil && mm_atomic.LoadUint64(&m.afterDomainCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.Domain")
	}
}

type mMatchDaterMockFlushPlayerStatsMap struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockFlushPlayerStatsMapExpectation
	expectations       []*MatchDaterMockFlushPlayerStatsMapExpectation
}

// MatchDaterMockFlushPlayerStatsMapExpectation specifies expectation struct of the MatchDater.FlushPlayerStatsCollection
type MatchDaterMockFlushPlayerStatsMapExpectation struct {
	mock *MatchDaterMock

	Counter uint64
}

// Expect sets up expected params for MatchDater.FlushPlayerStatsCollection
func (mmFlushPlayerStatsMap *mMatchDaterMockFlushPlayerStatsMap) Expect() *mMatchDaterMockFlushPlayerStatsMap {
	if mmFlushPlayerStatsMap.mock.funcFlushPlayerStatsMap != nil {
		mmFlushPlayerStatsMap.mock.t.Fatalf("MatchDaterMock.FlushPlayerStatsCollection mock is already set by Set")
	}

	if mmFlushPlayerStatsMap.defaultExpectation == nil {
		mmFlushPlayerStatsMap.defaultExpectation = &MatchDaterMockFlushPlayerStatsMapExpectation{}
	}

	return mmFlushPlayerStatsMap
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.FlushPlayerStatsCollection
func (mmFlushPlayerStatsMap *mMatchDaterMockFlushPlayerStatsMap) Inspect(f func()) *mMatchDaterMockFlushPlayerStatsMap {
	if mmFlushPlayerStatsMap.mock.inspectFuncFlushPlayerStatsMap != nil {
		mmFlushPlayerStatsMap.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.FlushPlayerStatsCollection")
	}

	mmFlushPlayerStatsMap.mock.inspectFuncFlushPlayerStatsMap = f

	return mmFlushPlayerStatsMap
}

// Return sets up results that will be returned by MatchDater.FlushPlayerStatsCollection
func (mmFlushPlayerStatsMap *mMatchDaterMockFlushPlayerStatsMap) Return() *MatchDaterMock {
	if mmFlushPlayerStatsMap.mock.funcFlushPlayerStatsMap != nil {
		mmFlushPlayerStatsMap.mock.t.Fatalf("MatchDaterMock.FlushPlayerStatsCollection mock is already set by Set")
	}

	if mmFlushPlayerStatsMap.defaultExpectation == nil {
		mmFlushPlayerStatsMap.defaultExpectation = &MatchDaterMockFlushPlayerStatsMapExpectation{mock: mmFlushPlayerStatsMap.mock}
	}

	return mmFlushPlayerStatsMap.mock
}

//Set uses given function f to mock the MatchDater.FlushPlayerStatsCollection method
func (mmFlushPlayerStatsMap *mMatchDaterMockFlushPlayerStatsMap) Set(f func()) *MatchDaterMock {
	if mmFlushPlayerStatsMap.defaultExpectation != nil {
		mmFlushPlayerStatsMap.mock.t.Fatalf("Default expectation is already set for the MatchDater.FlushPlayerStatsCollection method")
	}

	if len(mmFlushPlayerStatsMap.expectations) > 0 {
		mmFlushPlayerStatsMap.mock.t.Fatalf("Some expectations are already set for the MatchDater.FlushPlayerStatsCollection method")
	}

	mmFlushPlayerStatsMap.mock.funcFlushPlayerStatsMap = f
	return mmFlushPlayerStatsMap.mock
}

// FlushPlayerStatsMap implements stats.MatchDater
func (mmFlushPlayerStatsMap *MatchDaterMock) FlushPlayerStatsCollection() {
	mm_atomic.AddUint64(&mmFlushPlayerStatsMap.beforeFlushPlayerStatsMapCounter, 1)
	defer mm_atomic.AddUint64(&mmFlushPlayerStatsMap.afterFlushPlayerStatsMapCounter, 1)

	if mmFlushPlayerStatsMap.inspectFuncFlushPlayerStatsMap != nil {
		mmFlushPlayerStatsMap.inspectFuncFlushPlayerStatsMap()
	}

	if mmFlushPlayerStatsMap.FlushPlayerStatsMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlushPlayerStatsMap.FlushPlayerStatsMapMock.defaultExpectation.Counter, 1)

		return

	}
	if mmFlushPlayerStatsMap.funcFlushPlayerStatsMap != nil {
		mmFlushPlayerStatsMap.funcFlushPlayerStatsMap()
		return
	}
	mmFlushPlayerStatsMap.t.Fatalf("Unexpected call to MatchDaterMock.FlushPlayerStatsCollection.")

}

// FlushPlayerStatsMapAfterCounter returns a count of finished MatchDaterMock.FlushPlayerStatsMap invocations
func (mmFlushPlayerStatsMap *MatchDaterMock) FlushPlayerStatsMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushPlayerStatsMap.afterFlushPlayerStatsMapCounter)
}

// FlushPlayerStatsMapBeforeCounter returns a count of MatchDaterMock.FlushPlayerStatsMap invocations
func (mmFlushPlayerStatsMap *MatchDaterMock) FlushPlayerStatsMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushPlayerStatsMap.beforeFlushPlayerStatsMapCounter)
}

// MinimockFlushPlayerStatsMapDone returns true if the count of the FlushPlayerStatsMap invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockFlushPlayerStatsMapDone() bool {
	for _, e := range m.FlushPlayerStatsMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushPlayerStatsMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushPlayerStatsMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushPlayerStatsMap != nil && mm_atomic.LoadUint64(&m.afterFlushPlayerStatsMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockFlushPlayerStatsMapInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockFlushPlayerStatsMapInspect() {
	for _, e := range m.FlushPlayerStatsMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatchDaterMock.FlushPlayerStatsCollection")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushPlayerStatsMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushPlayerStatsMapCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.FlushPlayerStatsCollection")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushPlayerStatsMap != nil && mm_atomic.LoadUint64(&m.afterFlushPlayerStatsMapCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.FlushPlayerStatsCollection")
	}
}

type mMatchDaterMockLengthSeconds struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockLengthSecondsExpectation
	expectations       []*MatchDaterMockLengthSecondsExpectation
}

// MatchDaterMockLengthSecondsExpectation specifies expectation struct of the MatchDater.LengthSeconds
type MatchDaterMockLengthSecondsExpectation struct {
	mock *MatchDaterMock

	results *MatchDaterMockLengthSecondsResults
	Counter uint64
}

// MatchDaterMockLengthSecondsResults contains results of the MatchDater.LengthSeconds
type MatchDaterMockLengthSecondsResults struct {
	i1 int
}

// Expect sets up expected params for MatchDater.LengthSeconds
func (mmLengthSeconds *mMatchDaterMockLengthSeconds) Expect() *mMatchDaterMockLengthSeconds {
	if mmLengthSeconds.mock.funcLengthSeconds != nil {
		mmLengthSeconds.mock.t.Fatalf("MatchDaterMock.LengthSeconds mock is already set by Set")
	}

	if mmLengthSeconds.defaultExpectation == nil {
		mmLengthSeconds.defaultExpectation = &MatchDaterMockLengthSecondsExpectation{}
	}

	return mmLengthSeconds
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.LengthSeconds
func (mmLengthSeconds *mMatchDaterMockLengthSeconds) Inspect(f func()) *mMatchDaterMockLengthSeconds {
	if mmLengthSeconds.mock.inspectFuncLengthSeconds != nil {
		mmLengthSeconds.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.LengthSeconds")
	}

	mmLengthSeconds.mock.inspectFuncLengthSeconds = f

	return mmLengthSeconds
}

// Return sets up results that will be returned by MatchDater.LengthSeconds
func (mmLengthSeconds *mMatchDaterMockLengthSeconds) Return(i1 int) *MatchDaterMock {
	if mmLengthSeconds.mock.funcLengthSeconds != nil {
		mmLengthSeconds.mock.t.Fatalf("MatchDaterMock.LengthSeconds mock is already set by Set")
	}

	if mmLengthSeconds.defaultExpectation == nil {
		mmLengthSeconds.defaultExpectation = &MatchDaterMockLengthSecondsExpectation{mock: mmLengthSeconds.mock}
	}
	mmLengthSeconds.defaultExpectation.results = &MatchDaterMockLengthSecondsResults{i1}
	return mmLengthSeconds.mock
}

//Set uses given function f to mock the MatchDater.LengthSeconds method
func (mmLengthSeconds *mMatchDaterMockLengthSeconds) Set(f func() (i1 int)) *MatchDaterMock {
	if mmLengthSeconds.defaultExpectation != nil {
		mmLengthSeconds.mock.t.Fatalf("Default expectation is already set for the MatchDater.LengthSeconds method")
	}

	if len(mmLengthSeconds.expectations) > 0 {
		mmLengthSeconds.mock.t.Fatalf("Some expectations are already set for the MatchDater.LengthSeconds method")
	}

	mmLengthSeconds.mock.funcLengthSeconds = f
	return mmLengthSeconds.mock
}

// LengthSeconds implements stats.MatchDater
func (mmLengthSeconds *MatchDaterMock) LengthSeconds() (i1 int) {
	mm_atomic.AddUint64(&mmLengthSeconds.beforeLengthSecondsCounter, 1)
	defer mm_atomic.AddUint64(&mmLengthSeconds.afterLengthSecondsCounter, 1)

	if mmLengthSeconds.inspectFuncLengthSeconds != nil {
		mmLengthSeconds.inspectFuncLengthSeconds()
	}

	if mmLengthSeconds.LengthSecondsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLengthSeconds.LengthSecondsMock.defaultExpectation.Counter, 1)

		mm_results := mmLengthSeconds.LengthSecondsMock.defaultExpectation.results
		if mm_results == nil {
			mmLengthSeconds.t.Fatal("No results are set for the MatchDaterMock.LengthSeconds")
		}
		return (*mm_results).i1
	}
	if mmLengthSeconds.funcLengthSeconds != nil {
		return mmLengthSeconds.funcLengthSeconds()
	}
	mmLengthSeconds.t.Fatalf("Unexpected call to MatchDaterMock.LengthSeconds.")
	return
}

// LengthSecondsAfterCounter returns a count of finished MatchDaterMock.LengthSeconds invocations
func (mmLengthSeconds *MatchDaterMock) LengthSecondsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLengthSeconds.afterLengthSecondsCounter)
}

// LengthSecondsBeforeCounter returns a count of MatchDaterMock.LengthSeconds invocations
func (mmLengthSeconds *MatchDaterMock) LengthSecondsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLengthSeconds.beforeLengthSecondsCounter)
}

// MinimockLengthSecondsDone returns true if the count of the LengthSeconds invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockLengthSecondsDone() bool {
	for _, e := range m.LengthSecondsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthSecondsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthSecondsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLengthSeconds != nil && mm_atomic.LoadUint64(&m.afterLengthSecondsCounter) < 1 {
		return false
	}
	return true
}

// MinimockLengthSecondsInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockLengthSecondsInspect() {
	for _, e := range m.LengthSecondsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatchDaterMock.LengthSeconds")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthSecondsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthSecondsCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.LengthSeconds")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLengthSeconds != nil && mm_atomic.LoadUint64(&m.afterLengthSecondsCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.LengthSeconds")
	}
}

type mMatchDaterMockMap struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockMapExpectation
	expectations       []*MatchDaterMockMapExpectation
}

// MatchDaterMockMapExpectation specifies expectation struct of the MatchDater.Map
type MatchDaterMockMapExpectation struct {
	mock *MatchDaterMock

	results *MatchDaterMockMapResults
	Counter uint64
}

// MatchDaterMockMapResults contains results of the MatchDater.Map
type MatchDaterMockMapResults struct {
	s1 string
}

// Expect sets up expected params for MatchDater.Map
func (mmMap *mMatchDaterMockMap) Expect() *mMatchDaterMockMap {
	if mmMap.mock.funcMap != nil {
		mmMap.mock.t.Fatalf("MatchDaterMock.Map mock is already set by Set")
	}

	if mmMap.defaultExpectation == nil {
		mmMap.defaultExpectation = &MatchDaterMockMapExpectation{}
	}

	return mmMap
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.Map
func (mmMap *mMatchDaterMockMap) Inspect(f func()) *mMatchDaterMockMap {
	if mmMap.mock.inspectFuncMap != nil {
		mmMap.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.Map")
	}

	mmMap.mock.inspectFuncMap = f

	return mmMap
}

// Return sets up results that will be returned by MatchDater.Map
func (mmMap *mMatchDaterMockMap) Return(s1 string) *MatchDaterMock {
	if mmMap.mock.funcMap != nil {
		mmMap.mock.t.Fatalf("MatchDaterMock.Map mock is already set by Set")
	}

	if mmMap.defaultExpectation == nil {
		mmMap.defaultExpectation = &MatchDaterMockMapExpectation{mock: mmMap.mock}
	}
	mmMap.defaultExpectation.results = &MatchDaterMockMapResults{s1}
	return mmMap.mock
}

//Set uses given function f to mock the MatchDater.Map method
func (mmMap *mMatchDaterMockMap) Set(f func() (s1 string)) *MatchDaterMock {
	if mmMap.defaultExpectation != nil {
		mmMap.mock.t.Fatalf("Default expectation is already set for the MatchDater.Map method")
	}

	if len(mmMap.expectations) > 0 {
		mmMap.mock.t.Fatalf("Some expectations are already set for the MatchDater.Map method")
	}

	mmMap.mock.funcMap = f
	return mmMap.mock
}

// Map implements stats.MatchDater
func (mmMap *MatchDaterMock) Map() (s1 string) {
	mm_atomic.AddUint64(&mmMap.beforeMapCounter, 1)
	defer mm_atomic.AddUint64(&mmMap.afterMapCounter, 1)

	if mmMap.inspectFuncMap != nil {
		mmMap.inspectFuncMap()
	}

	if mmMap.MapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMap.MapMock.defaultExpectation.Counter, 1)

		mm_results := mmMap.MapMock.defaultExpectation.results
		if mm_results == nil {
			mmMap.t.Fatal("No results are set for the MatchDaterMock.Map")
		}
		return (*mm_results).s1
	}
	if mmMap.funcMap != nil {
		return mmMap.funcMap()
	}
	mmMap.t.Fatalf("Unexpected call to MatchDaterMock.Map.")
	return
}

// MapAfterCounter returns a count of finished MatchDaterMock.Map invocations
func (mmMap *MatchDaterMock) MapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMap.afterMapCounter)
}

// MapBeforeCounter returns a count of MatchDaterMock.Map invocations
func (mmMap *MatchDaterMock) MapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMap.beforeMapCounter)
}

// MinimockMapDone returns true if the count of the Map invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockMapDone() bool {
	for _, e := range m.MapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMap != nil && mm_atomic.LoadUint64(&m.afterMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockMapInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockMapInspect() {
	for _, e := range m.MapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatchDaterMock.Map")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMapCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.Map")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMap != nil && mm_atomic.LoadUint64(&m.afterMapCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.Map")
	}
}

type mMatchDaterMockPickupID struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockPickupIDExpectation
	expectations       []*MatchDaterMockPickupIDExpectation
}

// MatchDaterMockPickupIDExpectation specifies expectation struct of the MatchDater.PickupID
type MatchDaterMockPickupIDExpectation struct {
	mock *MatchDaterMock

	results *MatchDaterMockPickupIDResults
	Counter uint64
}

// MatchDaterMockPickupIDResults contains results of the MatchDater.PickupID
type MatchDaterMockPickupIDResults struct {
	i1 int
}

// Expect sets up expected params for MatchDater.PickupID
func (mmPickupID *mMatchDaterMockPickupID) Expect() *mMatchDaterMockPickupID {
	if mmPickupID.mock.funcPickupID != nil {
		mmPickupID.mock.t.Fatalf("MatchDaterMock.PickupID mock is already set by Set")
	}

	if mmPickupID.defaultExpectation == nil {
		mmPickupID.defaultExpectation = &MatchDaterMockPickupIDExpectation{}
	}

	return mmPickupID
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.PickupID
func (mmPickupID *mMatchDaterMockPickupID) Inspect(f func()) *mMatchDaterMockPickupID {
	if mmPickupID.mock.inspectFuncPickupID != nil {
		mmPickupID.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.PickupID")
	}

	mmPickupID.mock.inspectFuncPickupID = f

	return mmPickupID
}

// Return sets up results that will be returned by MatchDater.PickupID
func (mmPickupID *mMatchDaterMockPickupID) Return(i1 int) *MatchDaterMock {
	if mmPickupID.mock.funcPickupID != nil {
		mmPickupID.mock.t.Fatalf("MatchDaterMock.PickupID mock is already set by Set")
	}

	if mmPickupID.defaultExpectation == nil {
		mmPickupID.defaultExpectation = &MatchDaterMockPickupIDExpectation{mock: mmPickupID.mock}
	}
	mmPickupID.defaultExpectation.results = &MatchDaterMockPickupIDResults{i1}
	return mmPickupID.mock
}

//Set uses given function f to mock the MatchDater.PickupID method
func (mmPickupID *mMatchDaterMockPickupID) Set(f func() (i1 int)) *MatchDaterMock {
	if mmPickupID.defaultExpectation != nil {
		mmPickupID.mock.t.Fatalf("Default expectation is already set for the MatchDater.PickupID method")
	}

	if len(mmPickupID.expectations) > 0 {
		mmPickupID.mock.t.Fatalf("Some expectations are already set for the MatchDater.PickupID method")
	}

	mmPickupID.mock.funcPickupID = f
	return mmPickupID.mock
}

// PickupID implements stats.MatchDater
func (mmPickupID *MatchDaterMock) PickupID() (i1 int) {
	mm_atomic.AddUint64(&mmPickupID.beforePickupIDCounter, 1)
	defer mm_atomic.AddUint64(&mmPickupID.afterPickupIDCounter, 1)

	if mmPickupID.inspectFuncPickupID != nil {
		mmPickupID.inspectFuncPickupID()
	}

	if mmPickupID.PickupIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPickupID.PickupIDMock.defaultExpectation.Counter, 1)

		mm_results := mmPickupID.PickupIDMock.defaultExpectation.results
		if mm_results == nil {
			mmPickupID.t.Fatal("No results are set for the MatchDaterMock.PickupID")
		}
		return (*mm_results).i1
	}
	if mmPickupID.funcPickupID != nil {
		return mmPickupID.funcPickupID()
	}
	mmPickupID.t.Fatalf("Unexpected call to MatchDaterMock.PickupID.")
	return
}

// PickupIDAfterCounter returns a count of finished MatchDaterMock.PickupID invocations
func (mmPickupID *MatchDaterMock) PickupIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickupID.afterPickupIDCounter)
}

// PickupIDBeforeCounter returns a count of MatchDaterMock.PickupID invocations
func (mmPickupID *MatchDaterMock) PickupIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickupID.beforePickupIDCounter)
}

// MinimockPickupIDDone returns true if the count of the PickupID invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockPickupIDDone() bool {
	for _, e := range m.PickupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PickupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPickupIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickupID != nil && mm_atomic.LoadUint64(&m.afterPickupIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockPickupIDInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockPickupIDInspect() {
	for _, e := range m.PickupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatchDaterMock.PickupID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PickupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPickupIDCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.PickupID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickupID != nil && mm_atomic.LoadUint64(&m.afterPickupIDCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.PickupID")
	}
}

type mMatchDaterMockPickupPlayers struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockPickupPlayersExpectation
	expectations       []*MatchDaterMockPickupPlayersExpectation
}

// MatchDaterMockPickupPlayersExpectation specifies expectation struct of the MatchDater.PickupPlayers
type MatchDaterMockPickupPlayersExpectation struct {
	mock *MatchDaterMock

	results *MatchDaterMockPickupPlayersResults
	Counter uint64
}

// MatchDaterMockPickupPlayersResults contains results of the MatchDater.PickupPlayers
type MatchDaterMockPickupPlayersResults struct {
	ppa1 []*mm_stats.PickupPlayer
}

// Expect sets up expected params for MatchDater.PickupPlayers
func (mmPickupPlayers *mMatchDaterMockPickupPlayers) Expect() *mMatchDaterMockPickupPlayers {
	if mmPickupPlayers.mock.funcPickupPlayers != nil {
		mmPickupPlayers.mock.t.Fatalf("MatchDaterMock.PickupPlayers mock is already set by Set")
	}

	if mmPickupPlayers.defaultExpectation == nil {
		mmPickupPlayers.defaultExpectation = &MatchDaterMockPickupPlayersExpectation{}
	}

	return mmPickupPlayers
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.PickupPlayers
func (mmPickupPlayers *mMatchDaterMockPickupPlayers) Inspect(f func()) *mMatchDaterMockPickupPlayers {
	if mmPickupPlayers.mock.inspectFuncPickupPlayers != nil {
		mmPickupPlayers.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.PickupPlayers")
	}

	mmPickupPlayers.mock.inspectFuncPickupPlayers = f

	return mmPickupPlayers
}

// Return sets up results that will be returned by MatchDater.PickupPlayers
func (mmPickupPlayers *mMatchDaterMockPickupPlayers) Return(ppa1 []*mm_stats.PickupPlayer) *MatchDaterMock {
	if mmPickupPlayers.mock.funcPickupPlayers != nil {
		mmPickupPlayers.mock.t.Fatalf("MatchDaterMock.PickupPlayers mock is already set by Set")
	}

	if mmPickupPlayers.defaultExpectation == nil {
		mmPickupPlayers.defaultExpectation = &MatchDaterMockPickupPlayersExpectation{mock: mmPickupPlayers.mock}
	}
	mmPickupPlayers.defaultExpectation.results = &MatchDaterMockPickupPlayersResults{ppa1}
	return mmPickupPlayers.mock
}

//Set uses given function f to mock the MatchDater.PickupPlayers method
func (mmPickupPlayers *mMatchDaterMockPickupPlayers) Set(f func() (ppa1 []*mm_stats.PickupPlayer)) *MatchDaterMock {
	if mmPickupPlayers.defaultExpectation != nil {
		mmPickupPlayers.mock.t.Fatalf("Default expectation is already set for the MatchDater.PickupPlayers method")
	}

	if len(mmPickupPlayers.expectations) > 0 {
		mmPickupPlayers.mock.t.Fatalf("Some expectations are already set for the MatchDater.PickupPlayers method")
	}

	mmPickupPlayers.mock.funcPickupPlayers = f
	return mmPickupPlayers.mock
}

// PickupPlayers implements stats.MatchDater
func (mmPickupPlayers *MatchDaterMock) PickupPlayers() (ppa1 []*mm_stats.PickupPlayer) {
	mm_atomic.AddUint64(&mmPickupPlayers.beforePickupPlayersCounter, 1)
	defer mm_atomic.AddUint64(&mmPickupPlayers.afterPickupPlayersCounter, 1)

	if mmPickupPlayers.inspectFuncPickupPlayers != nil {
		mmPickupPlayers.inspectFuncPickupPlayers()
	}

	if mmPickupPlayers.PickupPlayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPickupPlayers.PickupPlayersMock.defaultExpectation.Counter, 1)

		mm_results := mmPickupPlayers.PickupPlayersMock.defaultExpectation.results
		if mm_results == nil {
			mmPickupPlayers.t.Fatal("No results are set for the MatchDaterMock.PickupPlayers")
		}
		return (*mm_results).ppa1
	}
	if mmPickupPlayers.funcPickupPlayers != nil {
		return mmPickupPlayers.funcPickupPlayers()
	}
	mmPickupPlayers.t.Fatalf("Unexpected call to MatchDaterMock.PickupPlayers.")
	return
}

// PickupPlayersAfterCounter returns a count of finished MatchDaterMock.PickupPlayers invocations
func (mmPickupPlayers *MatchDaterMock) PickupPlayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickupPlayers.afterPickupPlayersCounter)
}

// PickupPlayersBeforeCounter returns a count of MatchDaterMock.PickupPlayers invocations
func (mmPickupPlayers *MatchDaterMock) PickupPlayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPickupPlayers.beforePickupPlayersCounter)
}

// MinimockPickupPlayersDone returns true if the count of the PickupPlayers invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockPickupPlayersDone() bool {
	for _, e := range m.PickupPlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PickupPlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPickupPlayersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickupPlayers != nil && mm_atomic.LoadUint64(&m.afterPickupPlayersCounter) < 1 {
		return false
	}
	return true
}

// MinimockPickupPlayersInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockPickupPlayersInspect() {
	for _, e := range m.PickupPlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatchDaterMock.PickupPlayers")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PickupPlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPickupPlayersCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.PickupPlayers")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPickupPlayers != nil && mm_atomic.LoadUint64(&m.afterPickupPlayersCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.PickupPlayers")
	}
}

type mMatchDaterMockPlayerStatsMap struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockPlayerStatsMapExpectation
	expectations       []*MatchDaterMockPlayerStatsMapExpectation
}

// MatchDaterMockPlayerStatsMapExpectation specifies expectation struct of the MatchDater.PlayerStatsCollection
type MatchDaterMockPlayerStatsMapExpectation struct {
	mock *MatchDaterMock

	results *MatchDaterMockPlayerStatsMapResults
	Counter uint64
}

// MatchDaterMockPlayerStatsMapResults contains results of the MatchDater.PlayerStatsCollection
type MatchDaterMockPlayerStatsMapResults struct {
	p1 mm_stats.PlayerStatsCollection
}

// Expect sets up expected params for MatchDater.PlayerStatsCollection
func (mmPlayerStatsMap *mMatchDaterMockPlayerStatsMap) Expect() *mMatchDaterMockPlayerStatsMap {
	if mmPlayerStatsMap.mock.funcPlayerStatsMap != nil {
		mmPlayerStatsMap.mock.t.Fatalf("MatchDaterMock.PlayerStatsCollection mock is already set by Set")
	}

	if mmPlayerStatsMap.defaultExpectation == nil {
		mmPlayerStatsMap.defaultExpectation = &MatchDaterMockPlayerStatsMapExpectation{}
	}

	return mmPlayerStatsMap
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.PlayerStatsCollection
func (mmPlayerStatsMap *mMatchDaterMockPlayerStatsMap) Inspect(f func()) *mMatchDaterMockPlayerStatsMap {
	if mmPlayerStatsMap.mock.inspectFuncPlayerStatsMap != nil {
		mmPlayerStatsMap.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.PlayerStatsCollection")
	}

	mmPlayerStatsMap.mock.inspectFuncPlayerStatsMap = f

	return mmPlayerStatsMap
}

// Return sets up results that will be returned by MatchDater.PlayerStatsCollection
func (mmPlayerStatsMap *mMatchDaterMockPlayerStatsMap) Return(p1 mm_stats.PlayerStatsCollection) *MatchDaterMock {
	if mmPlayerStatsMap.mock.funcPlayerStatsMap != nil {
		mmPlayerStatsMap.mock.t.Fatalf("MatchDaterMock.PlayerStatsCollection mock is already set by Set")
	}

	if mmPlayerStatsMap.defaultExpectation == nil {
		mmPlayerStatsMap.defaultExpectation = &MatchDaterMockPlayerStatsMapExpectation{mock: mmPlayerStatsMap.mock}
	}
	mmPlayerStatsMap.defaultExpectation.results = &MatchDaterMockPlayerStatsMapResults{p1}
	return mmPlayerStatsMap.mock
}

//Set uses given function f to mock the MatchDater.PlayerStatsCollection method
func (mmPlayerStatsMap *mMatchDaterMockPlayerStatsMap) Set(f func() (p1 mm_stats.PlayerStatsCollection)) *MatchDaterMock {
	if mmPlayerStatsMap.defaultExpectation != nil {
		mmPlayerStatsMap.mock.t.Fatalf("Default expectation is already set for the MatchDater.PlayerStatsCollection method")
	}

	if len(mmPlayerStatsMap.expectations) > 0 {
		mmPlayerStatsMap.mock.t.Fatalf("Some expectations are already set for the MatchDater.PlayerStatsCollection method")
	}

	mmPlayerStatsMap.mock.funcPlayerStatsMap = f
	return mmPlayerStatsMap.mock
}

// PlayerStatsMap implements stats.MatchDater
func (mmPlayerStatsMap *MatchDaterMock) PlayerStatsCollection() (p1 mm_stats.PlayerStatsCollection) {
	mm_atomic.AddUint64(&mmPlayerStatsMap.beforePlayerStatsMapCounter, 1)
	defer mm_atomic.AddUint64(&mmPlayerStatsMap.afterPlayerStatsMapCounter, 1)

	if mmPlayerStatsMap.inspectFuncPlayerStatsMap != nil {
		mmPlayerStatsMap.inspectFuncPlayerStatsMap()
	}

	if mmPlayerStatsMap.PlayerStatsMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPlayerStatsMap.PlayerStatsMapMock.defaultExpectation.Counter, 1)

		mm_results := mmPlayerStatsMap.PlayerStatsMapMock.defaultExpectation.results
		if mm_results == nil {
			mmPlayerStatsMap.t.Fatal("No results are set for the MatchDaterMock.PlayerStatsCollection")
		}
		return (*mm_results).p1
	}
	if mmPlayerStatsMap.funcPlayerStatsMap != nil {
		return mmPlayerStatsMap.funcPlayerStatsMap()
	}
	mmPlayerStatsMap.t.Fatalf("Unexpected call to MatchDaterMock.PlayerStatsCollection.")
	return
}

// PlayerStatsMapAfterCounter returns a count of finished MatchDaterMock.PlayerStatsMap invocations
func (mmPlayerStatsMap *MatchDaterMock) PlayerStatsMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPlayerStatsMap.afterPlayerStatsMapCounter)
}

// PlayerStatsMapBeforeCounter returns a count of MatchDaterMock.PlayerStatsMap invocations
func (mmPlayerStatsMap *MatchDaterMock) PlayerStatsMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPlayerStatsMap.beforePlayerStatsMapCounter)
}

// MinimockPlayerStatsMapDone returns true if the count of the PlayerStatsMap invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockPlayerStatsMapDone() bool {
	for _, e := range m.PlayerStatsMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PlayerStatsMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPlayerStatsMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPlayerStatsMap != nil && mm_atomic.LoadUint64(&m.afterPlayerStatsMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockPlayerStatsMapInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockPlayerStatsMapInspect() {
	for _, e := range m.PlayerStatsMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatchDaterMock.PlayerStatsCollection")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PlayerStatsMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPlayerStatsMapCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.PlayerStatsCollection")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPlayerStatsMap != nil && mm_atomic.LoadUint64(&m.afterPlayerStatsMapCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.PlayerStatsCollection")
	}
}

type mMatchDaterMockSetLength struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockSetLengthExpectation
	expectations       []*MatchDaterMockSetLengthExpectation

	callArgs []*MatchDaterMockSetLengthParams
	mutex    sync.RWMutex
}

// MatchDaterMockSetLengthExpectation specifies expectation struct of the MatchDater.SetLength
type MatchDaterMockSetLengthExpectation struct {
	mock   *MatchDaterMock
	params *MatchDaterMockSetLengthParams

	Counter uint64
}

// MatchDaterMockSetLengthParams contains parameters of the MatchDater.SetLength
type MatchDaterMockSetLengthParams struct {
	msg string
}

// Expect sets up expected params for MatchDater.SetLength
func (mmSetLength *mMatchDaterMockSetLength) Expect(msg string) *mMatchDaterMockSetLength {
	if mmSetLength.mock.funcSetLength != nil {
		mmSetLength.mock.t.Fatalf("MatchDaterMock.SetLength mock is already set by Set")
	}

	if mmSetLength.defaultExpectation == nil {
		mmSetLength.defaultExpectation = &MatchDaterMockSetLengthExpectation{}
	}

	mmSetLength.defaultExpectation.params = &MatchDaterMockSetLengthParams{msg}
	for _, e := range mmSetLength.expectations {
		if minimock.Equal(e.params, mmSetLength.defaultExpectation.params) {
			mmSetLength.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetLength.defaultExpectation.params)
		}
	}

	return mmSetLength
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.SetLength
func (mmSetLength *mMatchDaterMockSetLength) Inspect(f func(msg string)) *mMatchDaterMockSetLength {
	if mmSetLength.mock.inspectFuncSetLength != nil {
		mmSetLength.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.SetLength")
	}

	mmSetLength.mock.inspectFuncSetLength = f

	return mmSetLength
}

// Return sets up results that will be returned by MatchDater.SetLength
func (mmSetLength *mMatchDaterMockSetLength) Return() *MatchDaterMock {
	if mmSetLength.mock.funcSetLength != nil {
		mmSetLength.mock.t.Fatalf("MatchDaterMock.SetLength mock is already set by Set")
	}

	if mmSetLength.defaultExpectation == nil {
		mmSetLength.defaultExpectation = &MatchDaterMockSetLengthExpectation{mock: mmSetLength.mock}
	}

	return mmSetLength.mock
}

//Set uses given function f to mock the MatchDater.SetLength method
func (mmSetLength *mMatchDaterMockSetLength) Set(f func(msg string)) *MatchDaterMock {
	if mmSetLength.defaultExpectation != nil {
		mmSetLength.mock.t.Fatalf("Default expectation is already set for the MatchDater.SetLength method")
	}

	if len(mmSetLength.expectations) > 0 {
		mmSetLength.mock.t.Fatalf("Some expectations are already set for the MatchDater.SetLength method")
	}

	mmSetLength.mock.funcSetLength = f
	return mmSetLength.mock
}

// SetLength implements stats.MatchDater
func (mmSetLength *MatchDaterMock) SetLength(msg string) {
	mm_atomic.AddUint64(&mmSetLength.beforeSetLengthCounter, 1)
	defer mm_atomic.AddUint64(&mmSetLength.afterSetLengthCounter, 1)

	if mmSetLength.inspectFuncSetLength != nil {
		mmSetLength.inspectFuncSetLength(msg)
	}

	mm_params := &MatchDaterMockSetLengthParams{msg}

	// Record call args
	mmSetLength.SetLengthMock.mutex.Lock()
	mmSetLength.SetLengthMock.callArgs = append(mmSetLength.SetLengthMock.callArgs, mm_params)
	mmSetLength.SetLengthMock.mutex.Unlock()

	for _, e := range mmSetLength.SetLengthMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetLength.SetLengthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetLength.SetLengthMock.defaultExpectation.Counter, 1)
		mm_want := mmSetLength.SetLengthMock.defaultExpectation.params
		mm_got := MatchDaterMockSetLengthParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetLength.t.Errorf("MatchDaterMock.SetLength got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetLength.funcSetLength != nil {
		mmSetLength.funcSetLength(msg)
		return
	}
	mmSetLength.t.Fatalf("Unexpected call to MatchDaterMock.SetLength. %v", msg)

}

// SetLengthAfterCounter returns a count of finished MatchDaterMock.SetLength invocations
func (mmSetLength *MatchDaterMock) SetLengthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLength.afterSetLengthCounter)
}

// SetLengthBeforeCounter returns a count of MatchDaterMock.SetLength invocations
func (mmSetLength *MatchDaterMock) SetLengthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLength.beforeSetLengthCounter)
}

// Calls returns a list of arguments used in each call to MatchDaterMock.SetLength.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetLength *mMatchDaterMockSetLength) Calls() []*MatchDaterMockSetLengthParams {
	mmSetLength.mutex.RLock()

	argCopy := make([]*MatchDaterMockSetLengthParams, len(mmSetLength.callArgs))
	copy(argCopy, mmSetLength.callArgs)

	mmSetLength.mutex.RUnlock()

	return argCopy
}

// MinimockSetLengthDone returns true if the count of the SetLength invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockSetLengthDone() bool {
	for _, e := range m.SetLengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLengthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLength != nil && mm_atomic.LoadUint64(&m.afterSetLengthCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetLengthInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockSetLengthInspect() {
	for _, e := range m.SetLengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatchDaterMock.SetLength with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLengthCounter) < 1 {
		if m.SetLengthMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatchDaterMock.SetLength")
		} else {
			m.t.Errorf("Expected call to MatchDaterMock.SetLength with params: %#v", *m.SetLengthMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLength != nil && mm_atomic.LoadUint64(&m.afterSetLengthCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.SetLength")
	}
}

type mMatchDaterMockSetMap struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockSetMapExpectation
	expectations       []*MatchDaterMockSetMapExpectation

	callArgs []*MatchDaterMockSetMapParams
	mutex    sync.RWMutex
}

// MatchDaterMockSetMapExpectation specifies expectation struct of the MatchDater.SetMap
type MatchDaterMockSetMapExpectation struct {
	mock   *MatchDaterMock
	params *MatchDaterMockSetMapParams

	Counter uint64
}

// MatchDaterMockSetMapParams contains parameters of the MatchDater.SetMap
type MatchDaterMockSetMapParams struct {
	m string
}

// Expect sets up expected params for MatchDater.SetMap
func (mmSetMap *mMatchDaterMockSetMap) Expect(m string) *mMatchDaterMockSetMap {
	if mmSetMap.mock.funcSetMap != nil {
		mmSetMap.mock.t.Fatalf("MatchDaterMock.SetMap mock is already set by Set")
	}

	if mmSetMap.defaultExpectation == nil {
		mmSetMap.defaultExpectation = &MatchDaterMockSetMapExpectation{}
	}

	mmSetMap.defaultExpectation.params = &MatchDaterMockSetMapParams{m}
	for _, e := range mmSetMap.expectations {
		if minimock.Equal(e.params, mmSetMap.defaultExpectation.params) {
			mmSetMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetMap.defaultExpectation.params)
		}
	}

	return mmSetMap
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.SetMap
func (mmSetMap *mMatchDaterMockSetMap) Inspect(f func(m string)) *mMatchDaterMockSetMap {
	if mmSetMap.mock.inspectFuncSetMap != nil {
		mmSetMap.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.SetMap")
	}

	mmSetMap.mock.inspectFuncSetMap = f

	return mmSetMap
}

// Return sets up results that will be returned by MatchDater.SetMap
func (mmSetMap *mMatchDaterMockSetMap) Return() *MatchDaterMock {
	if mmSetMap.mock.funcSetMap != nil {
		mmSetMap.mock.t.Fatalf("MatchDaterMock.SetMap mock is already set by Set")
	}

	if mmSetMap.defaultExpectation == nil {
		mmSetMap.defaultExpectation = &MatchDaterMockSetMapExpectation{mock: mmSetMap.mock}
	}

	return mmSetMap.mock
}

//Set uses given function f to mock the MatchDater.SetMap method
func (mmSetMap *mMatchDaterMockSetMap) Set(f func(m string)) *MatchDaterMock {
	if mmSetMap.defaultExpectation != nil {
		mmSetMap.mock.t.Fatalf("Default expectation is already set for the MatchDater.SetMap method")
	}

	if len(mmSetMap.expectations) > 0 {
		mmSetMap.mock.t.Fatalf("Some expectations are already set for the MatchDater.SetMap method")
	}

	mmSetMap.mock.funcSetMap = f
	return mmSetMap.mock
}

// SetMap implements stats.MatchDater
func (mmSetMap *MatchDaterMock) SetMap(m string) {
	mm_atomic.AddUint64(&mmSetMap.beforeSetMapCounter, 1)
	defer mm_atomic.AddUint64(&mmSetMap.afterSetMapCounter, 1)

	if mmSetMap.inspectFuncSetMap != nil {
		mmSetMap.inspectFuncSetMap(m)
	}

	mm_params := &MatchDaterMockSetMapParams{m}

	// Record call args
	mmSetMap.SetMapMock.mutex.Lock()
	mmSetMap.SetMapMock.callArgs = append(mmSetMap.SetMapMock.callArgs, mm_params)
	mmSetMap.SetMapMock.mutex.Unlock()

	for _, e := range mmSetMap.SetMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetMap.SetMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetMap.SetMapMock.defaultExpectation.Counter, 1)
		mm_want := mmSetMap.SetMapMock.defaultExpectation.params
		mm_got := MatchDaterMockSetMapParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetMap.t.Errorf("MatchDaterMock.SetMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetMap.funcSetMap != nil {
		mmSetMap.funcSetMap(m)
		return
	}
	mmSetMap.t.Fatalf("Unexpected call to MatchDaterMock.SetMap. %v", m)

}

// SetMapAfterCounter returns a count of finished MatchDaterMock.SetMap invocations
func (mmSetMap *MatchDaterMock) SetMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetMap.afterSetMapCounter)
}

// SetMapBeforeCounter returns a count of MatchDaterMock.SetMap invocations
func (mmSetMap *MatchDaterMock) SetMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetMap.beforeSetMapCounter)
}

// Calls returns a list of arguments used in each call to MatchDaterMock.SetMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetMap *mMatchDaterMockSetMap) Calls() []*MatchDaterMockSetMapParams {
	mmSetMap.mutex.RLock()

	argCopy := make([]*MatchDaterMockSetMapParams, len(mmSetMap.callArgs))
	copy(argCopy, mmSetMap.callArgs)

	mmSetMap.mutex.RUnlock()

	return argCopy
}

// MinimockSetMapDone returns true if the count of the SetMap invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockSetMapDone() bool {
	for _, e := range m.SetMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetMap != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetMapInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockSetMapInspect() {
	for _, e := range m.SetMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatchDaterMock.SetMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		if m.SetMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatchDaterMock.SetMap")
		} else {
			m.t.Errorf("Expected call to MatchDaterMock.SetMap with params: %#v", *m.SetMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetMap != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.SetMap")
	}
}

type mMatchDaterMockSetPickupID struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockSetPickupIDExpectation
	expectations       []*MatchDaterMockSetPickupIDExpectation

	callArgs []*MatchDaterMockSetPickupIDParams
	mutex    sync.RWMutex
}

// MatchDaterMockSetPickupIDExpectation specifies expectation struct of the MatchDater.SetPickupID
type MatchDaterMockSetPickupIDExpectation struct {
	mock   *MatchDaterMock
	params *MatchDaterMockSetPickupIDParams

	Counter uint64
}

// MatchDaterMockSetPickupIDParams contains parameters of the MatchDater.SetPickupID
type MatchDaterMockSetPickupIDParams struct {
	id int
}

// Expect sets up expected params for MatchDater.SetPickupID
func (mmSetPickupID *mMatchDaterMockSetPickupID) Expect(id int) *mMatchDaterMockSetPickupID {
	if mmSetPickupID.mock.funcSetPickupID != nil {
		mmSetPickupID.mock.t.Fatalf("MatchDaterMock.SetPickupID mock is already set by Set")
	}

	if mmSetPickupID.defaultExpectation == nil {
		mmSetPickupID.defaultExpectation = &MatchDaterMockSetPickupIDExpectation{}
	}

	mmSetPickupID.defaultExpectation.params = &MatchDaterMockSetPickupIDParams{id}
	for _, e := range mmSetPickupID.expectations {
		if minimock.Equal(e.params, mmSetPickupID.defaultExpectation.params) {
			mmSetPickupID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPickupID.defaultExpectation.params)
		}
	}

	return mmSetPickupID
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.SetPickupID
func (mmSetPickupID *mMatchDaterMockSetPickupID) Inspect(f func(id int)) *mMatchDaterMockSetPickupID {
	if mmSetPickupID.mock.inspectFuncSetPickupID != nil {
		mmSetPickupID.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.SetPickupID")
	}

	mmSetPickupID.mock.inspectFuncSetPickupID = f

	return mmSetPickupID
}

// Return sets up results that will be returned by MatchDater.SetPickupID
func (mmSetPickupID *mMatchDaterMockSetPickupID) Return() *MatchDaterMock {
	if mmSetPickupID.mock.funcSetPickupID != nil {
		mmSetPickupID.mock.t.Fatalf("MatchDaterMock.SetPickupID mock is already set by Set")
	}

	if mmSetPickupID.defaultExpectation == nil {
		mmSetPickupID.defaultExpectation = &MatchDaterMockSetPickupIDExpectation{mock: mmSetPickupID.mock}
	}

	return mmSetPickupID.mock
}

//Set uses given function f to mock the MatchDater.SetPickupID method
func (mmSetPickupID *mMatchDaterMockSetPickupID) Set(f func(id int)) *MatchDaterMock {
	if mmSetPickupID.defaultExpectation != nil {
		mmSetPickupID.mock.t.Fatalf("Default expectation is already set for the MatchDater.SetPickupID method")
	}

	if len(mmSetPickupID.expectations) > 0 {
		mmSetPickupID.mock.t.Fatalf("Some expectations are already set for the MatchDater.SetPickupID method")
	}

	mmSetPickupID.mock.funcSetPickupID = f
	return mmSetPickupID.mock
}

// SetPickupID implements stats.MatchDater
func (mmSetPickupID *MatchDaterMock) SetPickupID(id int) {
	mm_atomic.AddUint64(&mmSetPickupID.beforeSetPickupIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPickupID.afterSetPickupIDCounter, 1)

	if mmSetPickupID.inspectFuncSetPickupID != nil {
		mmSetPickupID.inspectFuncSetPickupID(id)
	}

	mm_params := &MatchDaterMockSetPickupIDParams{id}

	// Record call args
	mmSetPickupID.SetPickupIDMock.mutex.Lock()
	mmSetPickupID.SetPickupIDMock.callArgs = append(mmSetPickupID.SetPickupIDMock.callArgs, mm_params)
	mmSetPickupID.SetPickupIDMock.mutex.Unlock()

	for _, e := range mmSetPickupID.SetPickupIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetPickupID.SetPickupIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPickupID.SetPickupIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPickupID.SetPickupIDMock.defaultExpectation.params
		mm_got := MatchDaterMockSetPickupIDParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPickupID.t.Errorf("MatchDaterMock.SetPickupID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetPickupID.funcSetPickupID != nil {
		mmSetPickupID.funcSetPickupID(id)
		return
	}
	mmSetPickupID.t.Fatalf("Unexpected call to MatchDaterMock.SetPickupID. %v", id)

}

// SetPickupIDAfterCounter returns a count of finished MatchDaterMock.SetPickupID invocations
func (mmSetPickupID *MatchDaterMock) SetPickupIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPickupID.afterSetPickupIDCounter)
}

// SetPickupIDBeforeCounter returns a count of MatchDaterMock.SetPickupID invocations
func (mmSetPickupID *MatchDaterMock) SetPickupIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPickupID.beforeSetPickupIDCounter)
}

// Calls returns a list of arguments used in each call to MatchDaterMock.SetPickupID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPickupID *mMatchDaterMockSetPickupID) Calls() []*MatchDaterMockSetPickupIDParams {
	mmSetPickupID.mutex.RLock()

	argCopy := make([]*MatchDaterMockSetPickupIDParams, len(mmSetPickupID.callArgs))
	copy(argCopy, mmSetPickupID.callArgs)

	mmSetPickupID.mutex.RUnlock()

	return argCopy
}

// MinimockSetPickupIDDone returns true if the count of the SetPickupID invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockSetPickupIDDone() bool {
	for _, e := range m.SetPickupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPickupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPickupIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPickupID != nil && mm_atomic.LoadUint64(&m.afterSetPickupIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetPickupIDInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockSetPickupIDInspect() {
	for _, e := range m.SetPickupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatchDaterMock.SetPickupID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPickupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPickupIDCounter) < 1 {
		if m.SetPickupIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatchDaterMock.SetPickupID")
		} else {
			m.t.Errorf("Expected call to MatchDaterMock.SetPickupID with params: %#v", *m.SetPickupIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPickupID != nil && mm_atomic.LoadUint64(&m.afterSetPickupIDCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.SetPickupID")
	}
}

type mMatchDaterMockSetPlayers struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockSetPlayersExpectation
	expectations       []*MatchDaterMockSetPlayersExpectation

	callArgs []*MatchDaterMockSetPlayersParams
	mutex    sync.RWMutex
}

// MatchDaterMockSetPlayersExpectation specifies expectation struct of the MatchDater.SetPlayers
type MatchDaterMockSetPlayersExpectation struct {
	mock   *MatchDaterMock
	params *MatchDaterMockSetPlayersParams

	Counter uint64
}

// MatchDaterMockSetPlayersParams contains parameters of the MatchDater.SetPlayers
type MatchDaterMockSetPlayersParams struct {
	players []*mm_stats.PickupPlayer
}

// Expect sets up expected params for MatchDater.SetPlayers
func (mmSetPlayers *mMatchDaterMockSetPlayers) Expect(players []*mm_stats.PickupPlayer) *mMatchDaterMockSetPlayers {
	if mmSetPlayers.mock.funcSetPlayers != nil {
		mmSetPlayers.mock.t.Fatalf("MatchDaterMock.SetPlayers mock is already set by Set")
	}

	if mmSetPlayers.defaultExpectation == nil {
		mmSetPlayers.defaultExpectation = &MatchDaterMockSetPlayersExpectation{}
	}

	mmSetPlayers.defaultExpectation.params = &MatchDaterMockSetPlayersParams{players}
	for _, e := range mmSetPlayers.expectations {
		if minimock.Equal(e.params, mmSetPlayers.defaultExpectation.params) {
			mmSetPlayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPlayers.defaultExpectation.params)
		}
	}

	return mmSetPlayers
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.SetPlayers
func (mmSetPlayers *mMatchDaterMockSetPlayers) Inspect(f func(players []*mm_stats.PickupPlayer)) *mMatchDaterMockSetPlayers {
	if mmSetPlayers.mock.inspectFuncSetPlayers != nil {
		mmSetPlayers.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.SetPlayers")
	}

	mmSetPlayers.mock.inspectFuncSetPlayers = f

	return mmSetPlayers
}

// Return sets up results that will be returned by MatchDater.SetPlayers
func (mmSetPlayers *mMatchDaterMockSetPlayers) Return() *MatchDaterMock {
	if mmSetPlayers.mock.funcSetPlayers != nil {
		mmSetPlayers.mock.t.Fatalf("MatchDaterMock.SetPlayers mock is already set by Set")
	}

	if mmSetPlayers.defaultExpectation == nil {
		mmSetPlayers.defaultExpectation = &MatchDaterMockSetPlayersExpectation{mock: mmSetPlayers.mock}
	}

	return mmSetPlayers.mock
}

//Set uses given function f to mock the MatchDater.SetPlayers method
func (mmSetPlayers *mMatchDaterMockSetPlayers) Set(f func(players []*mm_stats.PickupPlayer)) *MatchDaterMock {
	if mmSetPlayers.defaultExpectation != nil {
		mmSetPlayers.mock.t.Fatalf("Default expectation is already set for the MatchDater.SetPlayers method")
	}

	if len(mmSetPlayers.expectations) > 0 {
		mmSetPlayers.mock.t.Fatalf("Some expectations are already set for the MatchDater.SetPlayers method")
	}

	mmSetPlayers.mock.funcSetPlayers = f
	return mmSetPlayers.mock
}

// SetPlayers implements stats.MatchDater
func (mmSetPlayers *MatchDaterMock) SetPlayers(players []*mm_stats.PickupPlayer) {
	mm_atomic.AddUint64(&mmSetPlayers.beforeSetPlayersCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPlayers.afterSetPlayersCounter, 1)

	if mmSetPlayers.inspectFuncSetPlayers != nil {
		mmSetPlayers.inspectFuncSetPlayers(players)
	}

	mm_params := &MatchDaterMockSetPlayersParams{players}

	// Record call args
	mmSetPlayers.SetPlayersMock.mutex.Lock()
	mmSetPlayers.SetPlayersMock.callArgs = append(mmSetPlayers.SetPlayersMock.callArgs, mm_params)
	mmSetPlayers.SetPlayersMock.mutex.Unlock()

	for _, e := range mmSetPlayers.SetPlayersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetPlayers.SetPlayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPlayers.SetPlayersMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPlayers.SetPlayersMock.defaultExpectation.params
		mm_got := MatchDaterMockSetPlayersParams{players}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPlayers.t.Errorf("MatchDaterMock.SetPlayers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetPlayers.funcSetPlayers != nil {
		mmSetPlayers.funcSetPlayers(players)
		return
	}
	mmSetPlayers.t.Fatalf("Unexpected call to MatchDaterMock.SetPlayers. %v", players)

}

// SetPlayersAfterCounter returns a count of finished MatchDaterMock.SetPlayers invocations
func (mmSetPlayers *MatchDaterMock) SetPlayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPlayers.afterSetPlayersCounter)
}

// SetPlayersBeforeCounter returns a count of MatchDaterMock.SetPlayers invocations
func (mmSetPlayers *MatchDaterMock) SetPlayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPlayers.beforeSetPlayersCounter)
}

// Calls returns a list of arguments used in each call to MatchDaterMock.SetPlayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPlayers *mMatchDaterMockSetPlayers) Calls() []*MatchDaterMockSetPlayersParams {
	mmSetPlayers.mutex.RLock()

	argCopy := make([]*MatchDaterMockSetPlayersParams, len(mmSetPlayers.callArgs))
	copy(argCopy, mmSetPlayers.callArgs)

	mmSetPlayers.mutex.RUnlock()

	return argCopy
}

// MinimockSetPlayersDone returns true if the count of the SetPlayers invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockSetPlayersDone() bool {
	for _, e := range m.SetPlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPlayersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPlayers != nil && mm_atomic.LoadUint64(&m.afterSetPlayersCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetPlayersInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockSetPlayersInspect() {
	for _, e := range m.SetPlayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatchDaterMock.SetPlayers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPlayersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPlayersCounter) < 1 {
		if m.SetPlayersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatchDaterMock.SetPlayers")
		} else {
			m.t.Errorf("Expected call to MatchDaterMock.SetPlayers with params: %#v", *m.SetPlayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPlayers != nil && mm_atomic.LoadUint64(&m.afterSetPlayersCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.SetPlayers")
	}
}

type mMatchDaterMockSetStartTime struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockSetStartTimeExpectation
	expectations       []*MatchDaterMockSetStartTimeExpectation

	callArgs []*MatchDaterMockSetStartTimeParams
	mutex    sync.RWMutex
}

// MatchDaterMockSetStartTimeExpectation specifies expectation struct of the MatchDater.SetStartTime
type MatchDaterMockSetStartTimeExpectation struct {
	mock   *MatchDaterMock
	params *MatchDaterMockSetStartTimeParams

	Counter uint64
}

// MatchDaterMockSetStartTimeParams contains parameters of the MatchDater.SetStartTime
type MatchDaterMockSetStartTimeParams struct {
	msg string
}

// Expect sets up expected params for MatchDater.SetStartTime
func (mmSetStartTime *mMatchDaterMockSetStartTime) Expect(msg string) *mMatchDaterMockSetStartTime {
	if mmSetStartTime.mock.funcSetStartTime != nil {
		mmSetStartTime.mock.t.Fatalf("MatchDaterMock.SetStartTime mock is already set by Set")
	}

	if mmSetStartTime.defaultExpectation == nil {
		mmSetStartTime.defaultExpectation = &MatchDaterMockSetStartTimeExpectation{}
	}

	mmSetStartTime.defaultExpectation.params = &MatchDaterMockSetStartTimeParams{msg}
	for _, e := range mmSetStartTime.expectations {
		if minimock.Equal(e.params, mmSetStartTime.defaultExpectation.params) {
			mmSetStartTime.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStartTime.defaultExpectation.params)
		}
	}

	return mmSetStartTime
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.SetStartTime
func (mmSetStartTime *mMatchDaterMockSetStartTime) Inspect(f func(msg string)) *mMatchDaterMockSetStartTime {
	if mmSetStartTime.mock.inspectFuncSetStartTime != nil {
		mmSetStartTime.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.SetStartTime")
	}

	mmSetStartTime.mock.inspectFuncSetStartTime = f

	return mmSetStartTime
}

// Return sets up results that will be returned by MatchDater.SetStartTime
func (mmSetStartTime *mMatchDaterMockSetStartTime) Return() *MatchDaterMock {
	if mmSetStartTime.mock.funcSetStartTime != nil {
		mmSetStartTime.mock.t.Fatalf("MatchDaterMock.SetStartTime mock is already set by Set")
	}

	if mmSetStartTime.defaultExpectation == nil {
		mmSetStartTime.defaultExpectation = &MatchDaterMockSetStartTimeExpectation{mock: mmSetStartTime.mock}
	}

	return mmSetStartTime.mock
}

//Set uses given function f to mock the MatchDater.SetStartTime method
func (mmSetStartTime *mMatchDaterMockSetStartTime) Set(f func(msg string)) *MatchDaterMock {
	if mmSetStartTime.defaultExpectation != nil {
		mmSetStartTime.mock.t.Fatalf("Default expectation is already set for the MatchDater.SetStartTime method")
	}

	if len(mmSetStartTime.expectations) > 0 {
		mmSetStartTime.mock.t.Fatalf("Some expectations are already set for the MatchDater.SetStartTime method")
	}

	mmSetStartTime.mock.funcSetStartTime = f
	return mmSetStartTime.mock
}

// SetStartTime implements stats.MatchDater
func (mmSetStartTime *MatchDaterMock) SetStartTime(msg string) {
	mm_atomic.AddUint64(&mmSetStartTime.beforeSetStartTimeCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStartTime.afterSetStartTimeCounter, 1)

	if mmSetStartTime.inspectFuncSetStartTime != nil {
		mmSetStartTime.inspectFuncSetStartTime(msg)
	}

	mm_params := &MatchDaterMockSetStartTimeParams{msg}

	// Record call args
	mmSetStartTime.SetStartTimeMock.mutex.Lock()
	mmSetStartTime.SetStartTimeMock.callArgs = append(mmSetStartTime.SetStartTimeMock.callArgs, mm_params)
	mmSetStartTime.SetStartTimeMock.mutex.Unlock()

	for _, e := range mmSetStartTime.SetStartTimeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetStartTime.SetStartTimeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStartTime.SetStartTimeMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStartTime.SetStartTimeMock.defaultExpectation.params
		mm_got := MatchDaterMockSetStartTimeParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStartTime.t.Errorf("MatchDaterMock.SetStartTime got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetStartTime.funcSetStartTime != nil {
		mmSetStartTime.funcSetStartTime(msg)
		return
	}
	mmSetStartTime.t.Fatalf("Unexpected call to MatchDaterMock.SetStartTime. %v", msg)

}

// SetStartTimeAfterCounter returns a count of finished MatchDaterMock.SetStartTime invocations
func (mmSetStartTime *MatchDaterMock) SetStartTimeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStartTime.afterSetStartTimeCounter)
}

// SetStartTimeBeforeCounter returns a count of MatchDaterMock.SetStartTime invocations
func (mmSetStartTime *MatchDaterMock) SetStartTimeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStartTime.beforeSetStartTimeCounter)
}

// Calls returns a list of arguments used in each call to MatchDaterMock.SetStartTime.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStartTime *mMatchDaterMockSetStartTime) Calls() []*MatchDaterMockSetStartTimeParams {
	mmSetStartTime.mutex.RLock()

	argCopy := make([]*MatchDaterMockSetStartTimeParams, len(mmSetStartTime.callArgs))
	copy(argCopy, mmSetStartTime.callArgs)

	mmSetStartTime.mutex.RUnlock()

	return argCopy
}

// MinimockSetStartTimeDone returns true if the count of the SetStartTime invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockSetStartTimeDone() bool {
	for _, e := range m.SetStartTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStartTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStartTimeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStartTime != nil && mm_atomic.LoadUint64(&m.afterSetStartTimeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStartTimeInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockSetStartTimeInspect() {
	for _, e := range m.SetStartTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatchDaterMock.SetStartTime with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStartTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStartTimeCounter) < 1 {
		if m.SetStartTimeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatchDaterMock.SetStartTime")
		} else {
			m.t.Errorf("Expected call to MatchDaterMock.SetStartTime with params: %#v", *m.SetStartTimeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStartTime != nil && mm_atomic.LoadUint64(&m.afterSetStartTimeCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.SetStartTime")
	}
}

type mMatchDaterMockString struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockStringExpectation
	expectations       []*MatchDaterMockStringExpectation
}

// MatchDaterMockStringExpectation specifies expectation struct of the MatchDater.String
type MatchDaterMockStringExpectation struct {
	mock *MatchDaterMock

	results *MatchDaterMockStringResults
	Counter uint64
}

// MatchDaterMockStringResults contains results of the MatchDater.String
type MatchDaterMockStringResults struct {
	s1 string
}

// Expect sets up expected params for MatchDater.String
func (mmString *mMatchDaterMockString) Expect() *mMatchDaterMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("MatchDaterMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &MatchDaterMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.String
func (mmString *mMatchDaterMockString) Inspect(f func()) *mMatchDaterMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by MatchDater.String
func (mmString *mMatchDaterMockString) Return(s1 string) *MatchDaterMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("MatchDaterMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &MatchDaterMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &MatchDaterMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the MatchDater.String method
func (mmString *mMatchDaterMockString) Set(f func() (s1 string)) *MatchDaterMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the MatchDater.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the MatchDater.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements stats.MatchDater
func (mmString *MatchDaterMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the MatchDaterMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to MatchDaterMock.String.")
	return
}

// StringAfterCounter returns a count of finished MatchDaterMock.String invocations
func (mmString *MatchDaterMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of MatchDaterMock.String invocations
func (mmString *MatchDaterMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MatchDaterMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.String")
	}
}

type mMatchDaterMockTryParseGameMap struct {
	mock               *MatchDaterMock
	defaultExpectation *MatchDaterMockTryParseGameMapExpectation
	expectations       []*MatchDaterMockTryParseGameMapExpectation

	callArgs []*MatchDaterMockTryParseGameMapParams
	mutex    sync.RWMutex
}

// MatchDaterMockTryParseGameMapExpectation specifies expectation struct of the MatchDater.TryParseGameMap
type MatchDaterMockTryParseGameMapExpectation struct {
	mock   *MatchDaterMock
	params *MatchDaterMockTryParseGameMapParams

	Counter uint64
}

// MatchDaterMockTryParseGameMapParams contains parameters of the MatchDater.TryParseGameMap
type MatchDaterMockTryParseGameMapParams struct {
	msg string
}

// Expect sets up expected params for MatchDater.TryParseGameMap
func (mmTryParseGameMap *mMatchDaterMockTryParseGameMap) Expect(msg string) *mMatchDaterMockTryParseGameMap {
	if mmTryParseGameMap.mock.funcTryParseGameMap != nil {
		mmTryParseGameMap.mock.t.Fatalf("MatchDaterMock.TryParseGameMap mock is already set by Set")
	}

	if mmTryParseGameMap.defaultExpectation == nil {
		mmTryParseGameMap.defaultExpectation = &MatchDaterMockTryParseGameMapExpectation{}
	}

	mmTryParseGameMap.defaultExpectation.params = &MatchDaterMockTryParseGameMapParams{msg}
	for _, e := range mmTryParseGameMap.expectations {
		if minimock.Equal(e.params, mmTryParseGameMap.defaultExpectation.params) {
			mmTryParseGameMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTryParseGameMap.defaultExpectation.params)
		}
	}

	return mmTryParseGameMap
}

// Inspect accepts an inspector function that has same arguments as the MatchDater.TryParseGameMap
func (mmTryParseGameMap *mMatchDaterMockTryParseGameMap) Inspect(f func(msg string)) *mMatchDaterMockTryParseGameMap {
	if mmTryParseGameMap.mock.inspectFuncTryParseGameMap != nil {
		mmTryParseGameMap.mock.t.Fatalf("Inspect function is already set for MatchDaterMock.TryParseGameMap")
	}

	mmTryParseGameMap.mock.inspectFuncTryParseGameMap = f

	return mmTryParseGameMap
}

// Return sets up results that will be returned by MatchDater.TryParseGameMap
func (mmTryParseGameMap *mMatchDaterMockTryParseGameMap) Return() *MatchDaterMock {
	if mmTryParseGameMap.mock.funcTryParseGameMap != nil {
		mmTryParseGameMap.mock.t.Fatalf("MatchDaterMock.TryParseGameMap mock is already set by Set")
	}

	if mmTryParseGameMap.defaultExpectation == nil {
		mmTryParseGameMap.defaultExpectation = &MatchDaterMockTryParseGameMapExpectation{mock: mmTryParseGameMap.mock}
	}

	return mmTryParseGameMap.mock
}

//Set uses given function f to mock the MatchDater.TryParseGameMap method
func (mmTryParseGameMap *mMatchDaterMockTryParseGameMap) Set(f func(msg string)) *MatchDaterMock {
	if mmTryParseGameMap.defaultExpectation != nil {
		mmTryParseGameMap.mock.t.Fatalf("Default expectation is already set for the MatchDater.TryParseGameMap method")
	}

	if len(mmTryParseGameMap.expectations) > 0 {
		mmTryParseGameMap.mock.t.Fatalf("Some expectations are already set for the MatchDater.TryParseGameMap method")
	}

	mmTryParseGameMap.mock.funcTryParseGameMap = f
	return mmTryParseGameMap.mock
}

// TryParseGameMap implements stats.MatchDater
func (mmTryParseGameMap *MatchDaterMock) TryParseGameMap(msg string) {
	mm_atomic.AddUint64(&mmTryParseGameMap.beforeTryParseGameMapCounter, 1)
	defer mm_atomic.AddUint64(&mmTryParseGameMap.afterTryParseGameMapCounter, 1)

	if mmTryParseGameMap.inspectFuncTryParseGameMap != nil {
		mmTryParseGameMap.inspectFuncTryParseGameMap(msg)
	}

	mm_params := &MatchDaterMockTryParseGameMapParams{msg}

	// Record call args
	mmTryParseGameMap.TryParseGameMapMock.mutex.Lock()
	mmTryParseGameMap.TryParseGameMapMock.callArgs = append(mmTryParseGameMap.TryParseGameMapMock.callArgs, mm_params)
	mmTryParseGameMap.TryParseGameMapMock.mutex.Unlock()

	for _, e := range mmTryParseGameMap.TryParseGameMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmTryParseGameMap.TryParseGameMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTryParseGameMap.TryParseGameMapMock.defaultExpectation.Counter, 1)
		mm_want := mmTryParseGameMap.TryParseGameMapMock.defaultExpectation.params
		mm_got := MatchDaterMockTryParseGameMapParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTryParseGameMap.t.Errorf("MatchDaterMock.TryParseGameMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmTryParseGameMap.funcTryParseGameMap != nil {
		mmTryParseGameMap.funcTryParseGameMap(msg)
		return
	}
	mmTryParseGameMap.t.Fatalf("Unexpected call to MatchDaterMock.TryParseGameMap. %v", msg)

}

// TryParseGameMapAfterCounter returns a count of finished MatchDaterMock.TryParseGameMap invocations
func (mmTryParseGameMap *MatchDaterMock) TryParseGameMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTryParseGameMap.afterTryParseGameMapCounter)
}

// TryParseGameMapBeforeCounter returns a count of MatchDaterMock.TryParseGameMap invocations
func (mmTryParseGameMap *MatchDaterMock) TryParseGameMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTryParseGameMap.beforeTryParseGameMapCounter)
}

// Calls returns a list of arguments used in each call to MatchDaterMock.TryParseGameMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTryParseGameMap *mMatchDaterMockTryParseGameMap) Calls() []*MatchDaterMockTryParseGameMapParams {
	mmTryParseGameMap.mutex.RLock()

	argCopy := make([]*MatchDaterMockTryParseGameMapParams, len(mmTryParseGameMap.callArgs))
	copy(argCopy, mmTryParseGameMap.callArgs)

	mmTryParseGameMap.mutex.RUnlock()

	return argCopy
}

// MinimockTryParseGameMapDone returns true if the count of the TryParseGameMap invocations corresponds
// the number of defined expectations
func (m *MatchDaterMock) MinimockTryParseGameMapDone() bool {
	for _, e := range m.TryParseGameMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TryParseGameMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTryParseGameMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTryParseGameMap != nil && mm_atomic.LoadUint64(&m.afterTryParseGameMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockTryParseGameMapInspect logs each unmet expectation
func (m *MatchDaterMock) MinimockTryParseGameMapInspect() {
	for _, e := range m.TryParseGameMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatchDaterMock.TryParseGameMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TryParseGameMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTryParseGameMapCounter) < 1 {
		if m.TryParseGameMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatchDaterMock.TryParseGameMap")
		} else {
			m.t.Errorf("Expected call to MatchDaterMock.TryParseGameMap with params: %#v", *m.TryParseGameMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTryParseGameMap != nil && mm_atomic.LoadUint64(&m.afterTryParseGameMapCounter) < 1 {
		m.t.Error("Expected call to MatchDaterMock.TryParseGameMap")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MatchDaterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDomainInspect()

		m.MinimockFlushPlayerStatsMapInspect()

		m.MinimockLengthSecondsInspect()

		m.MinimockMapInspect()

		m.MinimockPickupIDInspect()

		m.MinimockPickupPlayersInspect()

		m.MinimockPlayerStatsMapInspect()

		m.MinimockSetLengthInspect()

		m.MinimockSetMapInspect()

		m.MinimockSetPickupIDInspect()

		m.MinimockSetPlayersInspect()

		m.MinimockSetStartTimeInspect()

		m.MinimockStringInspect()

		m.MinimockTryParseGameMapInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MatchDaterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MatchDaterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDomainDone() &&
		m.MinimockFlushPlayerStatsMapDone() &&
		m.MinimockLengthSecondsDone() &&
		m.MinimockMapDone() &&
		m.MinimockPickupIDDone() &&
		m.MinimockPickupPlayersDone() &&
		m.MinimockPlayerStatsMapDone() &&
		m.MinimockSetLengthDone() &&
		m.MinimockSetMapDone() &&
		m.MinimockSetPickupIDDone() &&
		m.MinimockSetPlayersDone() &&
		m.MinimockSetStartTimeDone() &&
		m.MinimockStringDone() &&
		m.MinimockTryParseGameMapDone()
}
